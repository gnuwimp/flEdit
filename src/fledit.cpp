// Copyright 2024 - 2025 gnuwimp@gmail.com
// Released under the GNU General Public License v3.0
// This source file is an amalgamation of many files
// All empty lines and comments have been removed
#ifdef GNU_USE_SQLITE3
#include <cstdint>
#include <string>
#include <vector>
struct sqlite3;
struct sqlite3_stmt;
namespace gnu {
namespace db2 {
class Row;
typedef std::vector<Row> Rows;
enum class LOAD {
                                FILE,
                                BACKUP,
                                BACKUP_ON_ERROR,
};
static constexpr const char*    ERROR_ARGUMENTS = "error: invalid arguments!";
static constexpr const char*    ERROR_CHECKSUM  = "error: could not load data due to checksum error!";
static constexpr const char*    ERROR_CLOSED    = "error: database is closed!";
static constexpr const char*    ERROR_FILENAME  = "error: empty filename!";
static constexpr const char*    ERROR_OPEN      = "error: database could not be opened!";
class Row {
public:
                                Row()
                                    { _value = nullptr; _size = 0; _time = -1; }
                                Row(const std::string& key, char* value, size_t size, int64_t time = -1);
                                Row(const std::string& key, const char* value, size_t size, int64_t time = -1);
                                Row(const std::string& key, const std::string& value, int64_t time = -1);
                                Row(const Row& r);
                                Row(Row&& r);
    virtual                     ~Row()
                                    { free(_value); }
    Row&                        operator=(const Row& r);
    Row&                        operator=(Row&& r);
    const char*                 c_str() const
                                    { return _value; }
    const std::string&          key() const
                                    { return _key; }
    void                        debug(bool print_value = false) const;
    bool                        is_null() const
                                    { return _value == nullptr; }
    size_t                      size() const
                                    { return _size; }
    int64_t                     time() const
                                    { return _time; }
    static void                 Debug(const Rows& rows, bool print_value = false);
private:
    std::string                 _key;
    char*                       _value;
    size_t                      _size;
    int64_t                     _time;
};
class DB {
public:
    std::string                 err_msg;
    int                         err_code;
                                DB(const DB&) = delete;
    DB&                         operator=(const DB&) = delete;
                                DB();
    explicit                    DB(const std::string& filename);
                                DB(DB&& other);
    virtual                     ~DB()
                                    { close(); }
    DB&                         operator=(DB&&  other);
    bool                        begin()
                                    { return execute("BEGIN TRANSACTION"); }
    bool                        close();
    bool                        commit()
                                    { return execute("COMMIT TRANSACTION"); }
    bool                        defrag()
                                    { return execute("VACUUM"); }
    bool                        execute(const std::string& sql);
    std::string                 filename() const
                                    { return _filename; }
    Row                         get(const std::string& ns, const std::string& key);
    Rows                        get_keys(const std::string& ns, const std::string& wildcard = "", int64_t from_time = -1, int64_t to_time = -1);
    Rows                        get_rows(const std::string& ns, const std::string& wildcard = "", int64_t from_time = -1, int64_t to_time = -1);
    sqlite3*                    handle()
                                    { return _sql; }
    bool                        has_key(const std::string& ns, const std::string& key);
    bool                        is_busy() const
                                    { return err_code == 5; }
    bool                        is_open() const
                                    { return _sql != nullptr; }
    bool                        open(const std::string& filename);
    bool                        put(const std::string& ns, const std::string& key, const char* in, size_t in_size, int64_t time = -1);
    bool                        put(const std::string& ns, const std::string& key, const std::string& value, int64_t time = -1)
                                    { return put(ns, key, value.c_str(), value.length(), time); }
    bool                        put(const std::string& ns, const Row& r)
                                    { return put(ns, r.key(), r.c_str(), r.size(), r.time()); }
    int                         remove(const std::string& ns, const std::string& key, bool wildcard = false);
    bool                        rename(const std::string& ns, const std::string& key, const std::string& new_key);
    bool                        rollback()
                                    { return execute("ROLLBACK TRANSACTION"); }
    int64_t                     rows(const std::string& ns)
                                    { return _count(ns, "rows"); }
    int64_t                     size(const std::string& ns)
                                    { return _count(ns, "size"); }
    static bool                 Defrag(std::string& err, const std::string& filename);
    static Row                  Load(std::string& err, const std::string& filename, const std::string& key, LOAD load = LOAD::FILE);
    static Rows                 LoadRows(std::string& err, const std::string& filename, const std::string& wildcard = "");
    static bool                 Save(std::string& err, const std::string& filename, const Row& row, bool backup = false);
    static bool                 Save(std::string& err, const std::string& filename, const std::string& key, const char* value, size_t size, int64_t time = -1, bool backup = false);
    static bool                 SaveRows(std::string& err, const std::string& filename, const Rows& rows, bool backup = false);
    static std::string          Version();
private:
    bool                        _clear_error_and_free_stmt();
    int                         _clear_error_and_free_stmt_and_return_changes();
    int64_t                     _count(const std::string& ns, std::string what);
    bool                        _error_invalid_arguments();
    bool                        _prepare(const char* sql);
    bool                        _set_error_and_close_db();
    bool                        _set_error_and_free_stmt();
    sqlite3*                    _sql;
    sqlite3_stmt*               _stmt;
    std::string                 _filename;
};
}
}
#endif
#ifdef GNU_USE_PCRE
#include <cassert>
#include <cstring>
#include <string>
#include <vector>
namespace gnu {
namespace pcre8 {
class Match;
typedef std::vector<Match>       MatchVector;
typedef std::vector<MatchVector> MatchCaptures;
std::string                     escape(std::string string);
std::string                     format512(const char* format, ...);
std::string                     replace_all(const std::string& string, const std::string& find, const std::string& replace = "");
std::vector<std::string>        split(const std::string& string, const std::string& separator);
std::string                     version();
class Match {
public:
                                Match()
                                    { _start = _count = 0; }
                                Match(const std::string& word, int start, int count, const std::string& name = "")
                                    { _word = word; _start = start; _count = count; _name = name; assert(start >= 0 && count >= 0);  }
    bool                        operator==(const Match& m) const
                                    { return _word == m._word && _start == m._start && _count == m._count; }
    int                         count() const
                                    { return _count; }
    Match&                      count(size_t count)
                                    { _count = count; return *this; }
    void                        debug() const;
    int                         end() const
                                    { return _start + _count; }
    void                        inc_start()
                                    { _start++; }
    const std::string&          name() const
                                    { return _name; }
    Match&                      name(const std::string& name)
                                    { _name = name; return *this; }
    void                        print(int i = 0) const;
    bool                        replace(std::string& subject) const;
    int                         start() const
                                    { return _start; }
    const std::string&          word() const
                                    { return _word; }
    Match&                      word(const std::string& word)
                                    { _word = word; return *this; }
    static Match                Find(const MatchVector& matches, const std::string& name);
    static void                 Print(const MatchVector& matches, bool header = true, int capture = 0);
    static void                 Print(const MatchCaptures& captures);
    static std::string          ReplaceDollar(const MatchVector& matches, const std::string& replace);
    static std::string          ReplaceDollar(const MatchCaptures& captures, const std::string& replace);
    static size_t               ReplaceSub(const MatchCaptures& captures, std::string& replace);
private:
    int                         _count;
    int                         _start;
    std::string                 _name;
    std::string                 _word;
};
class PCRE {
public:
                                PCRE(const PCRE&) = delete;
    PCRE&                       operator=(const PCRE&) = delete;
                                PCRE();
    explicit                    PCRE(const std::string& pattern, bool useutf = false);
                                PCRE(PCRE&& other);
                                ~PCRE();
    PCRE&                       operator=(PCRE&& other);
    MatchCaptures               capture_all(const std::string& subject, const std::vector<std::string>& names = std::vector<std::string>());
    void                        clear();
    std::string                 compile(const std::string& pattern, bool useutf = false);
    void                        debug(bool print_matches = false);
    const std::string&          err() const
                                    { return _error; }
    MatchVector                 exec(const char* subject, size_t length);
    MatchVector                 exec(const std::string& subject)
                                    { return exec(subject.c_str(), subject.length()); }
    MatchVector                 exec_next(const Match& last);
    bool                        find(const char* subject)
                                    { return exec(subject, strlen(subject)).size() > 0; }
    bool                        find(const std::string& subject)
                                    { return exec(subject.c_str(), subject.length()).size() > 0; }
    bool                        has_error() const
                                    { return _error != ""; }
    bool                        is_compiled() const
                                    { return _pcre != nullptr; }
    bool                        has_utf() const
                                    { return _utf; }
    Match                       match(const std::string& name) const;
    MatchVector                 matches() const
                                    { return _matches; }
    PCRE&                       notbol(bool val = false)
                                    { _notbol = val; return *this; }
    PCRE&                       noteol(bool val = false)
                                    { _noteol = val; return *this; }
    PCRE&                       notempty(bool val = false)
                                    { _notempty = val; return *this; }
    const std::string&          pattern() const
                                    { return _pattern; }
    PCRE&                       reset_options()
                                    { _notbol = _noteol = _notempty = false; return *this; }
    PCRE&                       set_names(const std::vector<std::string>& names)
                                    { _names = names; return *this; }
    const std::string&          subject() const
                                    { return _subject; }
    std::string                 to_string() const;
    static MatchCaptures        Captures(const std::string& regex, const std::string& subject);
    static size_t               Find(const std::string& regex, const std::string& subject);
    static MatchVector          Matches(const std::string& regex, const std::string& subject);
private:
    MatchVector                 _set_matches(int count);
    static const size_t         SIZE_OFF = 60;
    bool                        _notbol;
    bool                        _notempty;
    bool                        _noteol;
    int                         _off[SIZE_OFF];
    int                         _utf;
    std::string                 _error;
    std::string                 _pattern;
    std::string                 _subject;
    MatchVector                 _matches;
    std::vector<std::string>    _names;
    void*                       _pcre;
};
}
}
#endif
#include <cassert>
#include <cstdint>
#include <map>
#include <string>
#include <vector>
namespace gnu {
namespace pile {
std::string make_key(unsigned key, uint8_t width = 3);
class Buf {
public:
                                Buf()
                                    { _p = nullptr; _s = 0; }
    explicit                    Buf(size_t s);
                                Buf(const char* p, size_t s);
                                Buf(const Buf& b);
                                Buf(Buf&& b)
                                    { _p = b._p; _s = b._s; b._p = nullptr; }
    virtual                     ~Buf()
                                    { free(_p); }
    Buf&                        operator=(const Buf& b);
    Buf&                        operator=(Buf&& b)
                                    { free(_p); _p = b._p; _s = b._s; b._p = nullptr; return *this; }
    Buf&                        operator+=(const Buf& b);
    bool                        operator==(const Buf& b) const;
    const char*                 c_str() const
                                    { return _p; }
    void                        set(char c, size_t index)
                                    { assert(index < _s); if (index < _s) _p[index] = c; }
    size_t                      size() const
                                    { return _s; }
    static inline Buf           Grab(char* p, size_t s)
                                    { auto res = Buf(); res._p = p; res._s = s; return res; }
private:
    char*                       _p;
    size_t                      _s;
};
class Pile {
public:
    explicit                    Pile(const char* values = nullptr)
                                    { _buf[0] = 0; import_data(values); }
    void                        clear()
                                    { _values.clear(); }
    void                        debug() const;
    std::string                 export_data() const;
    Buf                         get_buf(const std::string& section, const std::string& key) const;
    double                      get_double(const std::string& section, const std::string& key, double def = 0.0) const;
    int64_t                     get_int(const std::string& section, const std::string& key, int64_t def = 0) const;
    std::string                 get_string(const std::string& section, const std::string& key, const std::string& def = "") const;
    size_t                      import_data(const char* values);
    std::vector<std::string>    keys(const std::string& section) const;
    std::vector<std::string>    sections() const;
    bool                        set(const std::string& section, const std::string& key, const char* buffer, size_t buffer_len);
    bool                        set_buf(const std::string& section, const std::string& key, const Buf& buf)
                                    { return set(section, key, buf.c_str(), buf.size()); }
    bool                        set_double(const std::string& section, const std::string& key, double value)
                                    { snprintf(_buf, 500, "%f", value); return set_string(section, key, _buf); }
    bool                        set_int(const std::string& section, const std::string& key, int64_t value)
                                    { snprintf(_buf, 500, "%lld", (long long int) value); return set_string(section, key, _buf); }
    bool                        set_string(const std::string& section, const std::string& key, const std::string& string);
    size_t                      size() const
                                    { return _values.size(); }
private:
    std::map<std::string, std::string> _values;
    char                            _buf[500];
};
}
}
#include <cstdint>
#include <string>
#include <vector>
namespace gnu {
namespace str {
size_t                          find_first_of(const std::string& string, const std::string& list, size_t pos = 0);
size_t                          find_last_of(const std::string& string, const std::string& list, size_t pos = -1);
std::string                     format(const char* format, ...);
std::string                     format_int(int64_t num, char del = ' ');
std::string                     format_double(double num, size_t decimals, char del = ' ');
inline std::string              grab(char* string)
                                    { std::string res = (string != nullptr) ? string : ""; free(string); return res;}
bool                            has_whitespace(const std::string& string);
bool                            is_whitespace(const std::string& string);
size_t                          list_append(std::vector<std::string>& strings, const std::string& string, size_t max_size);
size_t                          list_insert(std::vector<std::string>& strings, const std::string& string, size_t max_size);
std::string&                    replace(std::string& string, const std::string& find, const std::string& replace = "", size_t max = -1);
std::string                     replace_const(const std::string& string, const std::string& find, const std::string& = "", size_t max = -1);
std::string                     replace_std(const std::string& string, const std::string& find, const std::string& replace);
std::string                     reverse(const std::string& string);
std::vector<std::string>        split(const std::string& string, const std::string& split);
std::vector<const char*>        split_fast(char* string, char split);
std::string                     substr(const std::string& string, std::string::size_type pos, std::string::size_type count = std::string::npos);
std::string                     substr_utf(const std::string& string, std::string::size_type pos, std::string::size_type count = std::string::npos);
double                          to_double(const std::string& string, double def = 0.0);
long long int                   to_int(const std::string& string, long long int def = 0);
inline std::string              to_string(const char* string)
                                    { return (string != nullptr) ? string : ""; }
std::string&                    trim(std::string& string);
std::string                     trim_const(const std::string& string);
std::string                     utf_char(const char* string);
std::vector<std::string>        utf_chars(const char* string);
size_t                          utf_len(const char* string);
}
}
#include <cstdint>
#include <string>
namespace gnu {
class Time {
public:
    explicit                    Time(bool start = false)
                                    { reset(); if (start == true) this->start(); }
    unsigned                    count()
                                    { return _count; }
    void                        reset()
                                    { _micro = 0; _count = 0; _paused = true; }
    void                        start()
                                    { if (_paused == true) { _paused = false; _micro = Time::Micro() - _micro; } }
    void                        stop()
                                    { if (_paused == false) { _paused = true; _count++; _micro = Time::Micro() - _micro; } }
    int64_t                     micro()
                                    { return _micro; }
    int64_t                     milli()
                                    { return _micro / 1'000; }
    double                      sec()
                                    { return (double) _micro / 1'000'000.0; }
    double                      split_micro()
                                    { return (_count > 0) ? (double) _micro / (double) _count : (double) _micro; }
    double                      split_milli()
                                    { return split_micro() / 1'000.0; }
    double                      split_sec()
                                    { return (double) split_micro() / 1'000'000.0; }
    static double               Clock();
    static std::string          FormatMilliToTime(int64_t milliseconds);
    static std::string          FormatUnixToISO(int64_t seconds, bool utc = false, bool date_only = false);
    static int64_t              Micro();
    static inline int64_t       Milli()
                                    { return Time::Micro() / 1'000;  }
    static inline double        Sec()
                                    { return (double) Time::Micro() / 1'000'000.0;  }
    static void                 SleepMilli(unsigned milliseconds);
private:
    int64_t                     _micro;
    unsigned                    _count;
    bool                        _paused;
};
}
#include <cstdint>
#include <string>
namespace gnu {
class Date {
public:
    enum class UTC {
                                ON,
                                OFF,
    };
    enum class US {
                                ON,
                                OFF,
    };
    enum class Compare {
                                YYYYMM,
                                YYYYMMDD,
                                YYYYMMDDHH,
                                YYYYMMDDHHMM,
                                YYYYMMDDHHMMSS,
                                LAST = YYYYMMDDHHMMSS,
    };
    enum class Day {
                                INVALID,
                                MONDAY,
                                TUESDAY,
                                WENDSDAY,
                                THURSDAY,
                                FRIDAY,
                                SATURDAY,
                                SUNDAY,
                                LAST = SUNDAY,
    };
    enum class Format {
                                ISO,
                                ISO_LONG,
                                ISO_TIME,
                                ISO_TIME_LONG,
                                TIME,
                                TIME_LONG,
                                US,
                                WORLD,
                                DAY_MONTH_YEAR,
                                DAY_MONTH_YEAR_SHORT,
                                WEEKDAY_MONTH_YEAR,
                                WEEKDAY_MONTH_YEAR_SHORT,
                                WEEKDAY,
                                WEEKDAY_SHORT,
                                MONTH,
                                MONTH_SHORT,
                                LAST = MONTH_SHORT,
    };
    static const int            SECS_PER_HOUR = 3600;
    static const int            SECS_PER_DAY  = 3600 * 24;
    static const int            SECS_PER_WEEK = 3600 * 24 * 7;
    explicit                    Date(Date::UTC utc = Date::UTC::OFF);
                                Date(int year, int month, int day, int hour = 0, int min = 0, int sec = 0);
    explicit                    Date(int64_t unix_time, Date::UTC utc = Date::UTC::OFF);
    explicit                    Date(const std::string& date, Date::US us = Date::US::OFF);
    bool                        operator<(const Date& other) const
                                    { return compare(other) < 0 ? true : false; }
    bool                        operator<=(const Date& other) const
                                    { return compare(other) <= 0 ? true : false; }
    bool                        operator>(const Date& other) const
                                    { return compare(other) > 0 ? true : false; }
    bool                        operator>=(const Date& other) const
                                    { return compare(other) >= 0 ? true : false; }
    bool                        operator==(const Date& other) const
                                    { return compare(other) == 0 ? true : false; }
    bool                        operator!=(const Date& other) const
                                    { return compare(other) != 0 ? true : false; }
    bool                        add_days(int days);
    bool                        add_months(int months);
    bool                        add_seconds(int64_t seconds);
    bool                        add_years(int years)
                                    { return add_months(years * 12); }
    Date&                       clear()
                                    { _year = _month = _day = _hour = _min = _sec = 0; return *this; }
    Date&                       clear_time()
                                    { _hour = _min = _sec = 0; return *this; }
    int                         compare(const Date& other, Compare flag = Compare::YYYYMMDDHHMMSS) const;
    int                         day() const
                                    { return _day; }
    int                         days_in_month() const;
    int                         days_into_year() const;
    void                        debug() const;
    int                         diff_days(const Date& other) const;
    int                         diff_months(const Date& other) const;
    int64_t                     diff_seconds(const Date& other) const;
    std::string                 format(Format format = Format::ISO) const;
    int                         hour() const
                                    { return _hour; }
    bool                        is_invalid() const
                                    { return _year == 0 || _month == 0 || _day == 0; }
    bool                        is_leapyear() const;
    int                         minute() const
                                    { return _min; }
    int                         month() const
                                    { return _month; }
    const char*                 month_name() const;
    const char*                 month_name_short() const;
    int                         second() const
                                    { return _sec; }
    Date&                       set(const Date& other);
    Date&                       set(const std::string& date, Date::US us = Date::US::OFF);
    Date&                       set(int year, int month, int day, int hour = 0, int min = 0, int sec = 0);
    Date&                       set_day(int day);
    Date&                       set_day_to_last_in_month()
                                    { _day = days_in_month(); return *this; }
    Date&                       set_hour(int hour);
    Date&                       set_minute(int min);
    Date&                       set_month(int month);
    Date&                       set_second(int sec);
    Date&                       set_weekday(Day weekday);
    Date&                       set_year(int year);
    int64_t                     time() const;
    int                         week() const;
    Day                         weekday() const;
    const char*                 weekday_name() const;
    const char*                 weekday_name_short() const;
    int                         year() const
                                    { return _year; }
    static inline bool          CompareDates(const Date& a, const Date& b)
                                    { return a.compare(b) < 0; }
private:
    short                       _year;
    char                        _month;
    char                        _day;
    char                        _hour;
    char                        _min;
    char                        _sec;
};
}
#include <cassert>
#include <cstdint>
#include <cstring>
#include <string>
#include <vector>
#include <array>
namespace gnu {
namespace file {
class File;
class Buf;
typedef bool (*CallbackCopy)(int64_t size, int64_t copied, void* data);
typedef std::vector<File> Files;
enum class Type {
    MISSING,
    DIR,
    FILE,
    OTHER,
};
#ifdef _WIN32
    static const int            DEFAULT_DIR_MODE  = 0x00000080;
    static const int            DEFAULT_FILE_MODE = 0x00000080;
#else
    static const int            DEFAULT_DIR_MODE  = 0755;
    static const int            DEFAULT_FILE_MODE = 0664;
#endif
char*                           allocate(char* resize_or_null, size_t size);
File                            canonical(const std::string& path);
bool                            chdir(const std::string& path);
std::string                     check_filename(const std::string& name);
bool                            chmod(const std::string& path, int mode);
bool                            chtime(const std::string& path, int64_t time);
Buf                             close_stderr();
Buf                             close_stdout();
bool                            copy(const std::string& from, const std::string& to, CallbackCopy callback = nullptr, void* data = nullptr, bool flush_write = true);
uint64_t                        fletcher64(const char* buffer, size_t buffer_size);
void                            flush(FILE* file);
File                            home_dir();
bool                            is_circular(const std::string& path);
File                            linkname(const std::string& path);
bool                            mkdir(const std::string& path);
FILE*                           open(const std::string& path, const std::string& mode);
std::string                     os();
FILE*                           popen(const std::string& cmd, bool write = false);
Buf                             read(const std::string& path);
Buf*                            read2(const std::string& path);
Files                           read_dir(const std::string& path);
Files                           read_dir_rec(const std::string& path);
bool                            redirect_stderr();
bool                            redirect_stdout();
bool                            remove(const std::string& path);
bool                            remove_rec(const std::string& path);
bool                            rename(const std::string& from, const std::string& to);
int                             run(const std::string& cmd, bool background, bool hide_win32_window = false);
File                            tmp_dir();
File                            tmp_file(const std::string& prepend = "");
File                            work_dir();
bool                            write(const std::string& path, const char* buffer, size_t size, bool flush = true);
bool                            write(const std::string& path, const Buf& buf, bool flush = true);
class Buf {
public:
                                Buf()
                                    { _str = nullptr; _size = 0; }
    explicit                    Buf(size_t size);
                                Buf(const char* buffer, size_t size);
                                Buf(const Buf& b);
                                Buf(Buf&& b)
                                    { _str = b._str; _size = b._size; b._str = nullptr; }
                                Buf(const std::string& string)
                                    { _str = nullptr; add(string.c_str(), string.length()); }
    virtual                     ~Buf()
                                    { free(_str); }
    unsigned char&              operator[](size_t index)
                                    { if (index >= _size || _str == nullptr) throw std::string("error: gnu::file::Buf::[]: index is out of range"); return ((unsigned char*) _str)[index]; }
    unsigned char               operator[](size_t index) const
                                    { if (index >= _size || _str == nullptr) throw std::string("error: gnu::file::Buf::[]: index is out of range"); return ((unsigned char*) _str)[index]; }
    Buf&                        operator=(const Buf& b)
                                    { return set(b._str, b._size); }
    Buf&                        operator=(Buf&& b)
                                    { free(_str); _str = b._str; _size = b._size; b._str = nullptr; return *this; }
    Buf&                        operator=(const std::string& string)
                                    { free(_str); _str = nullptr; add(string.c_str(), string.length()); return *this; }
    Buf&                        operator+=(const Buf& b)
                                    { return add(b._str, b._size); }
    bool                        operator==(const Buf& other) const;
    bool                        operator!=(const Buf& other) const
                                    { return (*this == other) == false; }
    Buf&                        add(const char* buffer, size_t size);
    const char*                 c_str() const
                                    { return _str; }
    void                        clear()
                                    { free(_str); _str = nullptr; _size = 0; }
    std::array<size_t, 257>     count() const
                                    { return Buf::Count(_str, _size); }
    void                        debug() const
                                    { printf("gnu::Buf(0x%p, %llu)\n", _str, (long long unsigned) _size); }
    uint64_t                    fletcher64() const
                                    { return file::fletcher64(_str, _size); }
    Buf&                        grab(char* buffer, size_t size)
                                    { free(_str); _str = buffer; _size = size; return *this; }
    Buf                         insert_cr(bool dos = true, bool trailing = false) const
                                    { return Buf::InsertCR(_str, _size, dos, trailing); }
    char*                       release()
                                    { auto res = _str; _str = nullptr; _size = 0; return res; }
    Buf                         remove_cr() const
                                    { return Buf::RemoveCR(_str, _size); }
    Buf&                        set(const char* buffer, size_t size);
    size_t                      size() const
                                    { return _size; }
    void                        size(size_t size)
                                    {  if (size >= _size) throw std::string("error: gnu::file::Buf::size(): size is out of range"); _size = size; }
    char*                       str()
                                    { return _str; }
    bool                        write(const std::string& path, bool flush = true) const;
    static std::array<size_t, 257> Count(const char* buffer, size_t size);
    static inline Buf           Grab(char* string)
                                    { auto res = Buf(); res._str = string; res._size = strlen(string); return res; }
    static inline Buf           Grab(char* buffer, size_t size)
                                    { auto res = Buf(); res._str = buffer; res._size = size; return res; }
    static Buf                  InsertCR(const char* buffer, size_t size, bool dos, bool trailing = false);
    static Buf                  RemoveCR(const char* buffer, size_t size);
private:
    char*                       _str;
    size_t                      _size;
};
class File {
public:
    explicit                    File(const std::string& path = "", bool realpath = false);
    bool                        operator==(const File& other) const
                                    { return _filename == other._filename; }
    bool                        operator<(const File& other) const
                                    { return _filename < other._filename; }
    bool                        operator<=(const File& other) const
                                    { return _filename <= other._filename; }
    const char*                 c_str() const
                                    { return _filename.c_str(); }
    File                        canonical() const
                                    { return file::canonical(_filename); }
    int64_t                     ctime() const
                                    { return _ctime; }
    void                        debug(bool short_version = true) const
                                    { printf("%s\n", to_string(short_version).c_str()); fflush(stdout); }
    bool                        exist() const
                                    { return _type != Type::MISSING; }
    const std::string&          ext() const
                                    { return _ext; }
    const std::string&          filename() const
                                    { return _filename; }
    bool                        is_circular() const
                                    { return file::is_circular(_filename); }
    bool                        is_dir() const
                                    { return _type == Type::DIR; }
    bool                        is_file() const
                                    { return _type == Type::FILE; }
    bool                        is_link() const
                                    { return _link; }
    bool                        is_missing() const
                                    { return _type == Type::MISSING; }
    bool                        is_other() const
                                    { return _type == Type::OTHER; }
    File                        linkname() const
                                    { return file::linkname(_filename); }
    int                         mode() const
                                    { return _mode; }
    int64_t                     mtime() const
                                    { return _mtime; }
    const std::string&          name() const
                                    { return _name; }
    std::string                 name_without_ext() const;
    const std::string&          parent() const
                                    { return _path; }
    const std::string&          path() const
                                    { return _path; }
    int64_t                     size() const
                                    { return _size; }
    std::string                 to_string(bool short_version = true) const;
    Type                        type() const
                                    { return _type; }
    std::string                 type_name() const;
private:
    Type                        _type;
    bool                        _link;
    int                         _mode;
    int64_t                     _ctime;
    int64_t                     _mtime;
    int64_t                     _size;
    std::string                 _ext;
    std::string                 _filename;
    std::string                 _name;
    std::string                 _path;
};
}
}
#include <string>
#include <map>
#include <vector>
#include <cmath>
#include <FL/Fl_Group.H>
#include <FL/Fl_Menu_.H>
#include <FL/Fl_Preferences.H>
#include <FL/Fl_PostScript.H>
#ifdef DEBUG
#include <iostream>
#include <iomanip>
#define FLW_LINE                        { ::printf("\033[31m%6u: \033[34m%s::%s\033[0m\n", __LINE__, __FILE__, __func__); fflush(stdout); }
#define FLW_RED                         { ::printf("\033[7m\033[31m%6u: %s::%s  \033[0m\n", __LINE__, __FILE__, __func__); fflush(stdout); }
#define FLW_GREEN                       { ::printf("\033[7m\033[32m%6u: %s::%s  \033[0m\n", __LINE__, __FILE__, __func__); fflush(stdout); }
#define FLW_YELLOW                      { ::printf("\033[7m\033[33m%6u: %s::%s  \033[0m\n", __LINE__, __FILE__, __func__); fflush(stdout); }
#define FLW_BLUE                        { ::printf("\033[7m\033[34m%6u: %s::%s  \033[0m\n", __LINE__, __FILE__, __func__); fflush(stdout); }
#define FLW_MAGENTA                     { ::printf("\033[7m\033[35m%6u: %s::%s  \033[0m\n", __LINE__, __FILE__, __func__); fflush(stdout); }
#define FLW_CYAN                        { ::printf("\033[7m\033[36m%6u: %s::%s  \033[0m\n", __LINE__, __FILE__, __func__); fflush(stdout); }
#define FLW_RGB                         { ::printf("\033[7m\033[31m%6u: \033[32m%s::\033[34m%s  \033[0m\n", __LINE__, __FILE__, __func__); fflush(stdout); }
#define FLW_PRINT(...)                  FLW_PRINT_MACRO(__VA_ARGS__, FLW_PRINT7, FLW_PRINT6, FLW_PRINT5, FLW_PRINT4, FLW_PRINT3, FLW_PRINT2, FLW_PRINT1)(__VA_ARGS__);
#define FLW_PRINT1(A)                   { std::cout << "\033[31m" << std::setw(6) << __LINE__ << ": \033[34m" << __func__ << ":\033[0m 1=" << (A) << std::endl; fflush(stdout); }
#define FLW_PRINT2(A,B)                 { std::cout << "\033[31m" << std::setw(6) << __LINE__ << ": \033[34m" << __func__ << ":\033[0m 1=" << (A) << ",  \033[32m2=" << (B) << "\033[0m" << std::endl; fflush(stdout); }
#define FLW_PRINT3(A,B,C)               { std::cout << "\033[31m" << std::setw(6) << __LINE__ << ": \033[34m" << __func__ << ":\033[0m 1=" << (A) << ",  \033[32m2=" << (B) << "\033[0m,  3=" << (C) << "" << std::endl; fflush(stdout); }
#define FLW_PRINT4(A,B,C,D)             { std::cout << "\033[31m" << std::setw(6) << __LINE__ << ": \033[34m" << __func__ << ":\033[0m 1=" << (A) << ",  \033[32m2=" << (B) << "\033[0m,  3=" << (C) << ",  \033[32m4=" << (D) << "\033[0m" << std::endl; fflush(stdout); }
#define FLW_PRINT5(A,B,C,D,E)           { std::cout << "\033[31m" << std::setw(6) << __LINE__ << ": \033[34m" << __func__ << ":\033[0m 1=" << (A) << ",  \033[32m2=" << (B) << "\033[0m,  3=" << (C) << ",  \033[32m4=" << (D) << "\033[0m,  5=" << (E) << std::endl; fflush(stdout); }
#define FLW_PRINT6(A,B,C,D,E,F)         { std::cout << "\033[31m" << std::setw(6) << __LINE__ << ": \033[34m" << __func__ << ":\033[0m 1=" << (A) << ",  \033[32m2=" << (B) << "\033[0m,  3=" << (C) << ",  \033[32m4=" << (D) << "\033[0m,  5=" << (E) << ",  \033[32m6=" << (F) << "\033[0m " << std::endl; fflush(stdout); }
#define FLW_PRINT7(A,B,C,D,E,F,G)       { std::cout << "\033[31m" << std::setw(6) << __LINE__ << ": \033[34m" << __func__ << ":\033[0m 1=" << (A) << ",  \033[32m2=" << (B) << "\033[0m,  3=" << (C) << ",  \033[32m4=" << (D) << "\033[0m,  5=" << (E) << ",  \033[32m6=" << (F) << "\033[0m,  7=" << (G) << std::endl; fflush(stdout); }
#define FLW_PRINT_MACRO(A,B,C,D,E,F,G,N,...) N
#define FLW_PRINTV(...)                 FLW_PRINTV_MACRO(__VA_ARGS__, FLW_PRINTV7, FLW_PRINTV6, FLW_PRINTV5, FLW_PRINTV4, FLW_PRINTV3, FLW_PRINTV2, FLW_PRINTV1)(__VA_ARGS__);
#define FLW_PRINTV1(A)                  { std::cout << "\033[31m" << std::setw(6) << __LINE__ << ": \033[34m" << __func__ << ":\033[0m " #A "=" << (A) << "" << std::endl; fflush(stdout); }
#define FLW_PRINTV2(A,B)                { std::cout << "\033[31m" << std::setw(6) << __LINE__ << ": \033[34m" << __func__ << ":\033[0m " #A "=" << (A) << ",  \033[32m" #B "=" << (B) << "\033[0m" << std::endl; fflush(stdout); }
#define FLW_PRINTV3(A,B,C)              { std::cout << "\033[31m" << std::setw(6) << __LINE__ << ": \033[34m" << __func__ << ":\033[0m " #A "=" << (A) << ",  \033[32m" #B "=" << (B) << "\033[0m,  " #C "=" << (C) << "" << std::endl; fflush(stdout); }
#define FLW_PRINTV4(A,B,C,D)            { std::cout << "\033[31m" << std::setw(6) << __LINE__ << ": \033[34m" << __func__ << ":\033[0m " #A "=" << (A) << ",  \033[32m" #B "=" << (B) << "\033[0m,  " #C "=" << (C) << ",  \033[32m" #D "=" << (D) << "\033[0m" << std::endl; fflush(stdout); }
#define FLW_PRINTV5(A,B,C,D,E)          { std::cout << "\033[31m" << std::setw(6) << __LINE__ << ": \033[34m" << __func__ << ":\033[0m " #A "=" << (A) << ",  \033[32m" #B "=" << (B) << "\033[0m,  " #C "=" << (C) << ",  \033[32m" #D "=" << (D) << "\033[0m,  " #E "=" << (E) << "" << std::endl; fflush(stdout); }
#define FLW_PRINTV6(A,B,C,D,E,F)        { std::cout << "\033[31m" << std::setw(6) << __LINE__ << ": \033[34m" << __func__ << ":\033[0m " #A "=" << (A) << ",  \033[32m" #B "=" << (B) << "\033[0m,  " #C "=" << (C) << ",  \033[32m" #D "=" << (D) << "\033[0m,  " #E "=" << (E) << ",  \033[32m" #F "=" << (F) << "\033[0m" << std::endl; fflush(stdout); }
#define FLW_PRINTV7(A,B,C,D,E,F,G)      { std::cout << "\033[31m" << std::setw(6) << __LINE__ << ": \033[34m" << __func__ << ":\033[0m " #A "=" << (A) << ",  \033[32m" #B "=" << (B) << "\033[0m,  " #C "=" << (C) << ",  \033[32m" #D "=" << (D) << "\033[0m,  " #E "=" << (E) << ",  \033[32m" #F "=" << (F) << "\033[0m,  " #G "=" << (G) << "" << std::endl; fflush(stdout); }
#define FLW_PRINTV_MACRO(A,B,C,D,E,F,G,N,...) N
#define FLW_PRINTD(...)                 FLW_PRINTD_MACRO(__VA_ARGS__, FLW_PRINTD4, FLW_PRINTD3, FLW_PRINTD2, FLW_PRINTD1)(__VA_ARGS__);
#define FLW_PRINTD1(A)                  { ::printf("\033[31m%6d: \033[34m%s:\033[0m  %s = %.10f\n", __LINE__, __func__, #A, static_cast<double>(A)); fflush(stdout); }
#define FLW_PRINTD2(A,B)                { ::printf("\033[31m%6d: \033[34m%s:\033[0m  %s = %.10f,  \033[32m%s = %.10f\033[0m\n", __LINE__, __func__, #A, static_cast<double>(A), #B, static_cast<double>(B)); fflush(stdout); }
#define FLW_PRINTD3(A,B,C)              { ::printf("\033[31m%6d: \033[34m%s:\033[0m  %s = %.10f,  \033[32m%s = %.10f\033[0m,  %s = %.10f\n", __LINE__, __func__, #A, static_cast<double>(A), #B, static_cast<double>(B), #C, static_cast<double>(C)); fflush(stdout); }
#define FLW_PRINTD4(A,B,C,D)            { ::printf("\033[31m%6d: \033[34m%s:\033[0m  %s = %.10f,  \033[32m%s = %.10f\033[0m,  %s = %.10f, \033[32m %s = %.10f\033[0m\n", __LINE__, __func__, #A, static_cast<double>(A), #B, static_cast<double>(B), #C, static_cast<double>(C), #D, static_cast<double>(D)); fflush(stdout); }
#define FLW_PRINTD_MACRO(A,B,C,D,N,...) N
#define FLW_PRINTDS(...)                FLW_PRINTDS_MACRO(__VA_ARGS__, FLW_PRINTDS4, FLW_PRINTDS3, FLW_PRINTDS2, FLW_PRINTDS1)(__VA_ARGS__);
#define FLW_PRINTDS1(A)                 { ::printf("\033[31m%6d: \033[34m%s:\033[0m  %s = %s\n", __LINE__, __func__, #A, flw::util::format_double(static_cast<double>(A), 0, '\'').c_str()); fflush(stdout); }
#define FLW_PRINTDS2(A,B)               { ::printf("\033[31m%6d: \033[34m%s:\033[0m  %s = %s,  \033[32m%s = %s\033[0m\n", __LINE__, __func__, #A, flw::util::format_double(static_cast<double>(A), 0, '\'').c_str(), #B, flw::util::format_double(static_cast<double>(B), 0, '\'').c_str()); fflush(stdout); }
#define FLW_PRINTDS3(A,B,C)             { ::printf("\033[31m%6d: \033[34m%s:\033[0m  %s = %s,  \033[32m%s = %s\033[0m,  %s = %s\n", __LINE__, __func__, #A, flw::util::format_double(static_cast<double>(A), 0, '\'').c_str(), #B, flw::util::format_double(static_cast<double>(B), 0, '\'').c_str(), #C, flw::util::format_double(static_cast<double>(C), 0, '\'').c_str()); fflush(stdout); }
#define FLW_PRINTDS4(A,B,C,D)           { ::printf("\033[31m%6d: \033[34m%s:\033[0m  %s = %s,  \033[32m%s = %s\033[0m,  %s = %s,  \033[32m%s = %s\033[0m\n", __LINE__, __func__, #A, flw::util::format_double(static_cast<double>(A), 0, '\'').c_str(), #B, flw::util::format_double(static_cast<double>(B), 0, '\'').c_str(), #C, flw::util::format_double(static_cast<double>(C), 0, '\'').c_str(), #D, flw::util::format_double(static_cast<double>(D), 0, '\'').c_str()); fflush(stdout); }
#define FLW_PRINTDS_MACRO(A,B,C,D,N,...) N
#define FLW_NL                          { ::printf("\n"); fflush(stdout); }
#define FLW_ASSERT(X,Y)                 if ((X) == 0) fl_alert("assert in %s on line %d: %s", __func__, __LINE__, Y);
#define FLW_TEST(X,Y)                   flw::debug::test(X,Y,__LINE__,__func__);
#define FLW_TEST_FLOAT(X,Y,Z)           flw::debug::test(X,Y,Z,__LINE__,__func__);
#define FLW_TEST_TRUE(X)                flw::debug::test(X,__LINE__,__func__);
#else
#define FLW_LINE
#define FLW_RED
#define FLW_GREEN
#define FLW_YELLOW
#define FLW_BLUE
#define FLW_MAGENTA
#define FLW_CYAN
#define FLW_RGB
#define FLW_PRINT(...)
#define FLW_PRINTV(...)
#define FLW_PRINTD(...)
#define FLW_PRINTDS(...)
#define FLW_NL
#define FLW_ASSERT(X,Y)
#define FLW_TEST(X,Y)
#define FLW_TEST_FLOAT(X,Y,Z)
#define FLW_TEST_TRUE(X)
#endif
namespace flw {
typedef std::map<std::string, std::string> StringHash;
typedef std::vector<std::string> StringVector;
typedef std::vector<void*> VoidVector;
typedef std::vector<Fl_Widget*> WidgetVector;
typedef bool (*PrintCallback)(void* data, int pw, int ph, int page);
extern int                      PREF_FIXED_FONT;
extern std::string              PREF_FIXED_FONTNAME;
extern int                      PREF_FIXED_FONTSIZE;
extern Fl_Font                  PREF_FONT;
extern int                      PREF_FONTSIZE;
extern std::string              PREF_FONTNAME;
extern std::vector<char*>       PREF_FONTNAMES;
extern double                   PREF_SCALE_VAL;
extern bool                     PREF_SCALE_ON;
extern std::string              PREF_THEME;
extern const StringVector       PREF_THEMES;
namespace color {
    extern Fl_Color             BEIGE;
    extern Fl_Color             CHOCOLATE;
    extern Fl_Color             CRIMSON;
    extern Fl_Color             DARKOLIVEGREEN;
    extern Fl_Color             DODGERBLUE;
    extern Fl_Color             FORESTGREEN;
    extern Fl_Color             GOLD;
    extern Fl_Color             GRAY;
    extern Fl_Color             INDIGO;
    extern Fl_Color             OLIVE;
    extern Fl_Color             PINK;
    extern Fl_Color             ROYALBLUE;
    extern Fl_Color             SIENNA;
    extern Fl_Color             SILVER;
    extern Fl_Color             SLATEGRAY;
    extern Fl_Color             TEAL;
    extern Fl_Color             TURQUOISE;
    extern Fl_Color             VIOLET;
}
namespace debug {
    void                        print(const Fl_Widget* widget, bool recursive = true);
    void                        print(const Fl_Widget* widget, std::string& indent, bool recursive = true);
    bool                        test(bool val, int line, const char* func);
    bool                        test(const char* ref, const char* val, int line, const char* func);
    bool                        test(int64_t ref, int64_t val, int line, const char* func);
    bool                        test(double ref, double val, double diff, int line, const char* func);
}
namespace label {
    extern std::string          BROWSE;
    extern std::string          CANCEL;
    extern std::string          CLOSE;
    extern std::string          DEL;
    extern std::string          DISCARD;
    extern std::string          MONO;
    extern std::string          NEXT;
    extern std::string          NO;
    extern std::string          OK;
    extern std::string          PREV;
    extern std::string          PRINT;
    extern std::string          REGULAR;
    extern std::string          SAVE;
    extern std::string          SAVE_DOT;
    extern std::string          SELECT;
    extern std::string          UPDATE;
    extern std::string          YES;
}
namespace menu {
    void                        enable_item(Fl_Menu_* menu, const char* text, bool value);
    Fl_Menu_Item*               get_item(Fl_Menu_* menu, const char* text);
    Fl_Menu_Item*               get_item(Fl_Menu_* menu, void* v);
    bool                        item_value(Fl_Menu_* menu, const char* text);
    void                        set_item(Fl_Menu_* menu, const char* text, bool value);
    void                        setonly_item(Fl_Menu_* menu, const char* text);
}
namespace util {
    void                        center_window(Fl_Window* window, Fl_Window* parent = nullptr);
    double                      clock();
    int                         count_decimals(double number);
    Fl_Widget*                  find_widget(Fl_Group* group, const std::string& label);
    std::string                 fix_menu_string(const std::string& label);
    std::string                 format(const std::string& format, ...);
    std::string                 format_double(double num, int decimals = 0, char del = ' ');
    std::string                 format_int(int64_t num, char del = ' ');
    bool                        icon(Fl_Widget* widget, const std::string& svg_image, unsigned max_size);
    bool                        is_empty(const std::string& string);
    void                        labelfont(Fl_Widget* widget, Fl_Font font = flw::PREF_FONT, int size = flw::PREF_FONTSIZE);
    int64_t                     microseconds();
    int32_t                     milliseconds();
    bool                        png_save(Fl_Window* window, const std::string& opt_name = "", int X = 0, int Y = 0, int W = 0, int H = 0);
    std::string                 print(const std::string& ps_filename, Fl_Paged_Device::Page_Format format, Fl_Paged_Device::Page_Layout layout, PrintCallback cb, void* data);
    std::string                 print(const std::string& ps_filename, Fl_Paged_Device::Page_Format format, Fl_Paged_Device::Page_Layout layout, PrintCallback cb, void* data, int from, int to);
    std::string                 remove_browser_format(const std::string& text);
    std::string&                replace_string(std::string& string, const std::string& find, const std::string& replace);
    void                        sleep(unsigned milli);
    StringVector                split_string(const std::string& string, const std::string& split);
    std::string                 substr(const std::string& string, std::string::size_type pos, std::string::size_type size = std::string::npos);
    void                        swap_rect(Fl_Widget* w1, Fl_Widget* w2);
    double                      to_double(const std::string& string);
    size_t                      to_doubles(const std::string& string, double numbers[], size_t size);
    int64_t                     to_int(const std::string& string, int64_t def = 0);
    long long                   to_long(const std::string& string, long long def = 0);
    static inline std::string   to_string(const char* text)
                                    { return text != nullptr ? text : ""; }
    std::string                 trim(const std::string& string);
    void*                       zero_memory(char* mem, size_t size);
class PrintText {
public:
                                PrintText(const std::string& filename,
                                    Fl_Paged_Device::Page_Format format = Fl_Paged_Device::Page_Format::A4,
                                    Fl_Paged_Device::Page_Layout layout = Fl_Paged_Device::Page_Layout::PORTRAIT,
                                    Fl_Font font = FL_COURIER,
                                    Fl_Fontsize fontsize = 14,
                                    Fl_Align align = FL_ALIGN_LEFT,
                                    bool wrap = true,
                                    bool border = false,
                                    int line_num = 0);
                                ~PrintText();
    Fl_Fontsize                 fontsize() const
                                    { return _fontsize; }
    int                         page_count() const
                                    { return _page_count; }
    std::string                 print(const char* text, unsigned replace_tab_with_space = 0);
    std::string                 print(const std::string& text, unsigned replace_tab_with_space = 0);
    std::string                 print(const StringVector& lines, unsigned replace_tab_with_space = 0);
private:
    void                        _check_for_new_page();
    void                        _measure_lw_lh(const std::string& text);
    void                        _print_line(const std::string& line);
    void                        _print_wrapped_line(const std::string& line);
    std::string                 _start();
    std::string                 _stop();
    Fl_Align                    _align;
    Fl_Font                     _font;
    Fl_Fontsize                 _fontsize;
    Fl_PostScript_File_Device*  _printer;
    Fl_Paged_Device::Page_Format _page_format;
    Fl_Paged_Device::Page_Layout _page_layout;
    FILE*                       _file;
    bool                        _border;
    bool                        _wrap;
    int                         _lh;
    int                         _line_count;
    int                         _line_num;
    int                         _lw;
    int                         _nw;
    int                         _page_count;
    int                         _ph;
    int                         _pw;
    int                         _px;
    int                         _py;
    std::string                 _filename;
};
}
namespace theme {
    bool                        is_dark();
    bool                        load(const std::string& name);
    Fl_Font                     load_font(const std::string& requested_font);
    void                        load_fonts(bool iso8859_only = true);
    void                        load_icon(Fl_Window* win, int win_resource, const char** xpm_resource = nullptr, const char* name = nullptr);
    Fl_Rect                     load_rect_from_pref(Fl_Preferences& pref, const std::string& basename);
    double                      load_theme_from_pref(Fl_Preferences& pref, unsigned screen_num = 0);
    void                        load_win_from_pref(Fl_Preferences& pref, const std::string& basename, Fl_Window* window, bool show = true, int defw = 800, int defh = 600);
    bool                        parse(int argc, const char** argv);
    void                        save_rect_to_pref(Fl_Preferences& pref, const std::string& basename, const Fl_Rect& rect);
    void                        save_theme_to_pref(Fl_Preferences& pref);
    void                        save_win_to_pref(Fl_Preferences& pref, const std::string& basename, Fl_Window* window);
}
namespace priv {
enum {
    THEME_DEFAULT,
    THEME_GLEAM,
    THEME_GLEAM_BLUE,
    THEME_GLEAM_DARK,
    THEME_GLEAM_TAN,
    THEME_GTK,
    THEME_GTK_BLUE,
    THEME_GTK_DARK,
    THEME_GTK_TAN,
    THEME_OXY,
    THEME_OXY_TAN,
    THEME_PLASTIC,
    THEME_PLASTIC_TAN,
    THEME_NIL,
};
}
}
namespace flw {
namespace icons {
static const std::string ALERT = R"(
<?xml version="1.0" encoding="iso-8859-1"?>
<!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools -->
<svg height="800px" width="800px" version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" 
	 viewBox="0 0 506.4 506.4" xml:space="preserve">
<circle style="fill:#DF5C4E;" cx="253.2" cy="253.2" r="249.2"/>
<g>
	<path style="fill:#F4EFEF;" d="M253.2,332.4c-10.8,0-20-8.8-20-19.6v-174c0-10.8,9.2-19.6,20-19.6s20,8.8,20,19.6v174
		C273.2,323.6,264,332.4,253.2,332.4z"/>
	<path style="fill:#F4EFEF;" d="M253.2,395.6c-5.2,0-10.4-2-14-5.6s-5.6-8.8-5.6-14s2-10.4,5.6-14s8.8-6,14-6s10.4,2,14,6
		c3.6,3.6,6,8.8,6,14s-2,10.4-6,14C263.6,393.6,258.4,395.6,253.2,395.6z"/>
</g>
<path d="M253.2,506.4C113.6,506.4,0,392.8,0,253.2S113.6,0,253.2,0s253.2,113.6,253.2,253.2S392.8,506.4,253.2,506.4z M253.2,8
	C118,8,8,118,8,253.2s110,245.2,245.2,245.2s245.2-110,245.2-245.2S388.4,8,253.2,8z"/>
<path d="M249.2,336.4c-13.2,0-24-10.8-24-23.6v-174c0-13.2,10.8-23.6,24-23.6s24,10.8,24,23.6v174
	C273.2,325.6,262.4,336.4,249.2,336.4z M249.2,122.8c-8.8,0-16,7.2-16,15.6v174c0,8.8,7.2,15.6,16,15.6s16-7.2,16-15.6v-174
	C265.2,130,258,122.8,249.2,122.8z"/>
<path d="M249.2,399.6c-6.4,0-12.4-2.4-16.8-6.8c-4.4-4.4-6.8-10.4-6.8-16.8s2.4-12.4,6.8-16.8c4.4-4.4,10.8-6.8,16.8-6.8
	c6.4,0,12.4,2.4,16.8,6.8c4.4,4.4,6.8,10.4,6.8,16.8s-2.4,12.4-7.2,16.8C261.6,397.2,255.6,399.6,249.2,399.6z M249.2,360
	c-4,0-8.4,1.6-11.2,4.8c-2.8,2.8-4.4,6.8-4.4,11.2c0,4,1.6,8.4,4.8,11.2c2.8,2.8,7.2,4.8,11.2,4.8s8.4-1.6,11.2-4.8
	c2.8-2.8,4.8-7.2,4.8-11.2s-1.6-8.4-4.8-11.2C257.2,361.6,253.2,360,249.2,360z"/>
</svg>
)";
static const std::string BACK = R"(
<?xml version="1.0" encoding="iso-8859-1"?>
<!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools -->
<svg height="800px" width="800px" version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" 
	 viewBox="0 0 511.999 511.999" xml:space="preserve">
<g>
	<path style="fill:#B3404A;" d="M382.795,358.347h-263.03c-7.958,0-14.411-6.452-14.411-14.411s6.453-14.411,14.411-14.411h263.029
		c55.352,0,100.384-45.032,100.384-100.384v-25.501c0-55.352-45.032-100.384-100.384-100.384h-84.939v42.04h84.939
		c7.958,0,14.411,6.452,14.411,14.411s-6.453,14.411-14.411,14.411h-99.349c-7.958,0-14.411-6.452-14.411-14.411V88.846
		c0-7.959,6.453-14.411,14.411-14.411h99.349c71.243,0,129.205,57.961,129.205,129.205v25.501
		C512,300.386,454.038,358.347,382.795,358.347z"/>
	<path style="fill:#B3404A;" d="M382.795,287.487H265.631c-7.958,0-14.411-6.452-14.411-14.411c0-7.959,6.453-14.411,14.411-14.411
		h117.164c15.728,0,29.523-13.797,29.523-29.523v-25.501c0-7.959,6.453-14.411,14.411-14.411s14.411,6.452,14.411,14.411v25.501
		C441.139,260.768,414.42,287.487,382.795,287.487z"/>
</g>
<polygon style="fill:#F4B2B0;" points="200.171,423.152 14.411,307.407 200.171,191.663 "/>
<path style="fill:#B3404A;" d="M200.171,437.563c-2.649,0-5.293-0.729-7.62-2.18L6.79,319.638C2.567,317.006,0,312.383,0,307.407
	s2.567-9.599,6.79-12.23l185.761-115.744c4.441-2.77,10.038-2.909,14.615-0.369c4.578,2.541,7.416,7.364,7.416,12.599v231.49
	c0,5.235-2.839,10.059-7.416,12.599C204.987,436.961,202.578,437.563,200.171,437.563z M41.661,307.407l144.1,89.786V217.62
	L41.661,307.407z"/>
</svg>
)";
static const std::string CANCEL = R"(
<?xml version="1.0" encoding="UTF-8"?>
<!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools -->
<svg width="800px" height="800px" enable-background="new 0 0 32 32" version="1.1" viewBox="0 0 32 32" xml:space="preserve" xmlns="http://www.w3.org/2000/svg">
<g id="Close">
<path d="m26.6 5.4c-2.8-2.8-6.6-4.4-10.6-4.4s-7.8 1.6-10.6 4.4-4.4 6.6-4.4 10.6 1.6 7.8 4.4 10.6 6.6 4.4 10.6 4.4 7.8-1.6 10.6-4.4 4.4-6.6 4.4-10.6-1.6-7.8-4.4-10.6z" fill="#FE9803"/>
<path d="m17.4 16 5-5c0.2-0.2 0.3-0.5 0.3-0.7 0-0.3-0.1-0.5-0.3-0.7-0.4-0.4-1-0.4-1.4 0l-5 4.9-5-4.9c-0.4-0.4-1-0.4-1.4 0-0.2 0.2-0.3 0.4-0.3 0.7s0.1 0.5 0.3 0.7l5 5-5 5c-0.2 0.2-0.3 
0.4-0.3 0.7s0.1 0.5 0.3 0.7 0.5 0.3 0.7 0.3c0.3 0 0.5-0.1 0.7-0.3l5-5 5 5c0.2 0.2 0.5 0.3 0.7 0.3 0.3 0 0.5-0.1 0.7-0.3s0.3-0.5 0.3-0.7c0-0.3-0.1-0.5-0.3-0.7l-5-5z" fill="#673AB7"/>
</g>
</svg>
)";
static const std::string CONFIRM = R"(
<?xml version="1.0" encoding="iso-8859-1"?>
<!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools -->
<svg height="800px" width="800px" version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" 
	 viewBox="0 0 506.4 506.4" xml:space="preserve">
<circle style="fill:#54B265;" cx="253.2" cy="253.2" r="249.2"/>
<path style="fill:#F4EFEF;" d="M372.8,200.4l-11.2-11.2c-4.4-4.4-12-4.4-16.4,0L232,302.4l-69.6-69.6c-4.4-4.4-12-4.4-16.4,0
	L134.4,244c-4.4,4.4-4.4,12,0,16.4l89.2,89.2c4.4,4.4,12,4.4,16.4,0l0,0l0,0l10.4-10.4l0.8-0.8l121.6-121.6
	C377.2,212.4,377.2,205.2,372.8,200.4z"/>
<path d="M253.2,506.4C113.6,506.4,0,392.8,0,253.2S113.6,0,253.2,0s253.2,113.6,253.2,253.2S392.8,506.4,253.2,506.4z M253.2,8
	C118,8,8,118,8,253.2s110,245.2,245.2,245.2s245.2-110,245.2-245.2S388.4,8,253.2,8z"/>
<path d="M231.6,357.2c-4,0-8-1.6-11.2-4.4l-89.2-89.2c-6-6-6-16,0-22l11.6-11.6c6-6,16.4-6,22,0l66.8,66.8L342,186.4
	c2.8-2.8,6.8-4.4,11.2-4.4c4,0,8,1.6,11.2,4.4l11.2,11.2l0,0c6,6,6,16,0,22L242.8,352.4C239.6,355.6,235.6,357.2,231.6,357.2z
	 M154,233.6c-2,0-4,0.8-5.6,2.4l-11.6,11.6c-2.8,2.8-2.8,8,0,10.8l89.2,89.2c2.8,2.8,8,2.8,10.8,0l132.8-132.8c2.8-2.8,2.8-8,0-10.8
	l-11.2-11.2c-2.8-2.8-8-2.8-10.8,0L234.4,306c-1.6,1.6-4,1.6-5.6,0l-69.6-69.6C158,234.4,156,233.6,154,233.6z"/>
</svg>
)";
static const std::string DEL = R"(
<?xml version="1.0" encoding="iso-8859-1"?>
<!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools -->
<svg height="800px" width="800px" version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" 
	 viewBox="0 0 506.4 506.4" xml:space="preserve">
<circle style="fill:#DF5C4E;" cx="253.2" cy="253.2" r="249.2"/>
<path style="fill:#F4EFEF;" d="M373.2,244.8c0-6.4-5.2-11.6-11.6-11.6H140.8c-6.4,0-11.6,5.2-11.6,11.6v16.8
	c0,6.4,5.2,11.6,11.6,11.6h220.8c6.4,0,11.6-5.2,11.6-11.6V244.8z"/>
<path d="M253.2,506.4C113.6,506.4,0,392.8,0,253.2S113.6,0,253.2,0s253.2,113.6,253.2,253.2S392.8,506.4,253.2,506.4z M253.2,8
	C118,8,8,118,8,253.2s110,245.2,245.2,245.2s245.2-110,245.2-245.2S388.4,8,253.2,8z"/>
<path d="M357.6,277.2H136.8c-8.8,0-15.6-7.2-15.6-15.6v-16.8c0-8.8,7.2-15.6,15.6-15.6h220.8c8.8,0,15.6,7.2,15.6,15.6v16.8
	C373.2,270,366,277.2,357.6,277.2z M136.8,237.2c-4.4,0-7.6,3.6-7.6,7.6v16.8c0,4.4,3.6,7.6,7.6,7.6h220.8c4.4,0,7.6-3.6,7.6-7.6
	v-16.8c0-4.4-3.6-7.6-7.6-7.6H136.8z"/>
</svg>
)";
static const std::string EDIT = R"(
<?xml version="1.0" encoding="utf-8"?>
<!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools -->
<svg width="800px" height="800px" viewBox="0 0 1024 1024" class="icon"  version="1.1" xmlns="http://www.w3.org/2000/svg">
<path d="M823.3 938.8H229.4c-71.6 0-129.8-58.2-129.8-129.8V215.1c0-71.6 58.2-129.8 129.8-129.8h297c23.6 0 42.7 19.1 42.7 42.7s-19.1 42.7-42.7 42.7h-297c-24.5 0-44.4 19.9-44.4 
44.4V809c0 24.5 19.9 44.4 44.4 44.4h593.9c24.5 0 44.4-19.9 44.4-44.4V512c0-23.6 19.1-42.7 42.7-42.7s42.7 19.1 42.7 42.7v297c0 71.6-58.2 129.8-129.8 129.8z" fill="#3688FF" />
<path d="M483 756.5c-1.8 0-3.5-0.1-5.3-0.3l-134.5-16.8c-19.4-2.4-34.6-17.7-37-37l-16.8-134.5c-1.6-13.1 2.9-26.2 12.2-35.5l374.6-374.6c51.1-51.1 134.2-51.1 185.3 0l26.3 26.3c24.8 
24.7 38.4 57.6 38.4 92.7 0 35-13.6 67.9-38.4 92.7L513.2 744c-8.1 8.1-19 12.5-30.2 12.5z m-96.3-97.7l80.8 10.1 359.8-359.8c8.6-8.6 13.4-20.1 13.4-32.3 0-12.2-4.8-23.7-13.4-32.3L801 218.2c-17.9-17.8-46.8-17.8-64.6 0L376.6 578l10.1 80.8z" fill="#5F6379" /></svg>
)";
static const std::string ERR = R"(
<?xml version="1.0" encoding="UTF-8"?>
<!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools -->
<svg width="800px" height="800px" version="1.1" viewBox="0 0 512 512" xml:space="preserve" xmlns="http://www.w3.org/2000/svg">
<circle cx="256" cy="256" r="245.8" fill="#FF757C"/>
<polygon points="395.56 164.04 347.96 116.44 256 208.4 164.04 116.44 116.44 164.04 208.4 256 116.44 347.96 164.04 395.56 256 303.6 347.96 395.56 395.56 347.96 303.6 256" fill="#F2F2F2"/>
<g fill="#4D4D4D">
	<path d="M256,512c-68.38,0-132.667-26.628-181.02-74.98S0,324.38,0,256S26.628,123.333,74.98,74.98   S187.62,0,256,0s132.667,26.628,181.02,74.98S512,187.62,512,256s-26.628,132.667-74.98,181.02S324.38,512,256,512z M256,20.398   C126.089,20.398,20.398,126.089,20.398,256S126.089,491.602,256,491.602S491.602,385.911,491.602,256S385.911,20.398,256,20.398z"/>
	<path d="m347.96 405.76c-2.61 0-5.221-0.996-7.212-2.987l-84.75-84.75-84.749 84.75c-3.983 3.982-10.441 3.982-14.425 0l-47.599-47.599c-3.983-3.983-3.983-10.441 0-14.425l84.751-84.748-84.75-84.749c-3.983-3.983-3.983-10.441 0-14.425l47.599-47.599c3.983-3.982 10.441-3.982 14.425 0l84.748 84.751 84.749-84.75c3.983-3.982 10.441-3.982 14.425 0l47.599 
	47.599c3.983 3.983 3.983 10.441 0 14.425l-84.751 84.748 84.75 84.749c3.983 3.983 3.983 10.441 0 14.425l-47.599 47.599c-1.991 1.991-4.601 2.986-7.211 2.986zm-91.962-112.36c2.61 0 5.221 0.996 7.212 2.987l84.749 84.75 33.175-33.175-84.75-84.749c-3.983-3.983-3.983-10.441 0-14.425l84.75-84.749-33.175-33.175-84.749 84.75c-3.983 3.982-10.441 3.982-14.425 
	0l-84.749-84.75-33.175 33.175 84.75 84.749c3.983 3.983 3.983 10.441 0 14.425l-84.75 84.749 33.175 33.175 84.749-84.75c1.992-1.99 4.603-2.987 7.213-2.987z"/>	
</g>
</svg>
)";
static const std::string FORWARD = R"(
<?xml version="1.0" encoding="iso-8859-1"?>
<!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools -->
<svg height="800px" width="800px" version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" 
	 viewBox="0 0 512 512" xml:space="preserve">
<g>
	<path style="fill:#B3404A;" d="M392.235,358.347h-263.03C57.962,358.347,0,300.386,0,229.143v-25.501
		C0,132.399,57.962,74.437,129.205,74.437h99.349c7.958,0,14.411,6.453,14.411,14.411v70.861c0,7.958-6.453,14.411-14.411,14.411
		h-99.349c-7.958,0-14.411-6.453-14.411-14.411c0-7.958,6.453-14.411,14.411-14.411h84.939v-42.041h-84.939
		c-55.352,0-100.384,45.032-100.384,100.384v25.501c0,55.351,45.032,100.383,100.384,100.383h263.029
		c7.958,0,14.411,6.453,14.411,14.411S400.193,358.347,392.235,358.347z"/>
	<path style="fill:#B3404A;" d="M246.369,287.486H129.205c-31.625,0-58.344-26.717-58.344-58.343v-25.501
		c0-7.958,6.453-14.411,14.411-14.411s14.411,6.453,14.411,14.411v25.501c0,15.726,13.795,29.521,29.523,29.521h117.164
		c7.958,0,14.411,6.453,14.411,14.411C260.779,281.033,254.326,287.486,246.369,287.486z"/>
</g>
<polygon style="fill:#F4B2B0;" points="311.829,423.152 497.589,307.407 311.829,191.663 "/>
<path style="fill:#B3404A;" d="M311.829,437.563c-2.407,0-4.816-0.602-6.995-1.811c-4.578-2.542-7.416-7.364-7.416-12.599v-231.49
	c0-5.235,2.839-10.057,7.416-12.599c4.575-2.541,10.172-2.401,14.615,0.369L505.21,295.177c4.224,2.631,6.79,7.254,6.79,12.23
	c0,4.976-2.567,9.599-6.79,12.23L319.449,435.381C317.122,436.834,314.477,437.563,311.829,437.563z M326.239,217.62v179.574
	l144.1-89.788L326.239,217.62z"/>
</svg>
)";
static const std::string INFO = R"(
<?xml version="1.0" encoding="UTF-8"?>
<!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools -->
<svg width="800px" height="800px" version="1.1" viewBox="0 0 512 512" xml:space="preserve" xmlns="http://www.w3.org/2000/svg">
<circle cx="256" cy="256" r="245.8" fill="#BCC987"/>
<g fill="#FFE6B8">
	<path d="m256 411.54c-14.082 0-25.498-11.416-25.498-25.498v-177.47c0-14.082 11.416-25.498 25.498-25.498s25.498 11.416 25.498 25.498v177.47c0 14.082-11.416 25.498-25.498 25.498z"/>
	<path d="m256 151.46c-6.711 0-13.28-2.723-18.033-7.466-4.742-4.753-7.465-11.321-7.465-18.032s2.723-13.29 7.465-18.033c4.753-4.742 11.322-7.465 18.033-7.465s13.279 2.723 18.032 7.465c4.743 4.743 7.466 11.322 7.466 18.033s-2.723 13.279-7.466 18.032c-4.753 4.743-11.321 7.466-18.032 7.466z"/>
</g>
<g fill="#4D3D36">
	<path d="M256,512c-68.381,0-132.667-26.628-181.019-74.981C26.628,388.667,0,324.381,0,256   S26.628,123.333,74.981,74.981C123.333,26.628,187.619,0,256,0s132.667,26.628,181.019,74.981C485.372,123.333,512,187.619,512,256   s-26.628,132.667-74.981,181.019C388.667,485.372,324.381,512,256,512z M256,20.398C126.089,20.398,20.398,126.089,20.398,256   S126.089,491.602,256,491.602S491.602,385.911,491.602,256S385.911,20.398,256,20.398z"/>
	
	
	<path d="m256 421.74c-19.683 0-35.697-16.014-35.697-35.697v-177.47c0-19.683 16.014-35.697 35.697-35.697s35.697 16.014 35.697 35.697v177.47c0 19.683-16.014 35.697-35.697 35.697zm0-228.46c-8.436 0-15.299 6.863-15.299 15.299v177.47c0 8.436 6.863 15.299 15.299 15.299s15.299-6.863 15.299-15.299v-177.47c0-8.436-6.863-15.299-15.299-15.299z"/>
	<path d="m256 161.66c-9.386 0-18.585-3.807-25.237-10.446-6.654-6.668-10.46-15.867-10.46-25.251 0-9.4 3.809-18.6 10.451-25.244 6.662-6.647 15.861-10.453 25.246-10.453 9.384 0 18.583 3.806 25.235 10.444 6.653 6.652 10.462 15.853 10.462 25.253 0 9.385-3.807 18.584-10.446 25.236-6.667 6.654-15.866 10.461-25.251 10.461zm0-50.996c-4.025 0-7.972 1.636-10.829 4.486-2.836 2.837-4.469 6.781-4.469 10.813 0 4.024 1.636 7.971 4.486 10.829 2.841 2.834 6.788 4.47 10.813 4.47 4.024 0 7.97-1.636 10.827-4.486 2.835-2.843 4.471-6.789 4.471-10.813 0-4.031-1.633-7.974-4.479-10.82-2.849-2.843-6.796-4.479-10.82-4.479z"/>
</g>
</svg>
)";
static const std::string PASSWORD = R"(
<?xml version="1.0" encoding="utf-8"?>
<!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools -->
<svg width="800px" height="800px" viewBox="0 0 1024 1024" class="icon"  version="1.1" xmlns="http://www.w3.org/2000/svg"><path d="M512.340992 730.22464c28.653568 0 
51.883008-23.228416 51.883008-51.883008 0-28.653568-23.22944-51.881984-51.883008-51.881984-28.653568 0-51.883008 23.228416-51.883008 51.881984 0 28.654592 23.22944 
51.883008 51.883008 51.883008zM97.28 591.720448c0-76.327936 62.0544-138.203136 138.476544-138.203136h553.168896c76.478464 0 138.476544 62.006272 138.476544 
138.203136v190.537728c0 76.326912-62.0544 138.203136-138.476544 138.203136H235.756544C159.27808 920.461312 97.28 858.454016 97.28 782.258176V591.720448z" 
fill="#FFF200" /><path d="M661.95456 171.87328C622.099456 128.39424 568.96512 104.448 512.342016 104.448c-56.623104 0-109.75744 23.94624-149.613568 67.426304-39.40352 
42.984448-61.10208 100.01408-61.10208 160.584704h40.96C342.585344 229.318656 418.737152 145.408 512.340992 145.408c93.60384 0 169.756672 83.91168 169.756672 
187.051008h40.96c0-60.5696-21.699584-117.600256-61.10208-160.58368M512.340992 730.22464c-28.653568 0-51.881984-23.228416-51.881984-51.883008 0-28.653568 23.228416-51.881984 
51.881984-51.881984 28.654592 0 51.883008 23.228416 51.883008 51.881984 0 28.654592-23.228416 51.883008-51.883008 51.883008m276.584448-276.707328H235.75552C159.3344 453.517312 
97.28 515.393536 97.28 591.720448v190.537728c0 76.196864 61.99808 138.203136 138.47552 138.203136h553.16992c76.42112 0 138.47552-61.876224 138.47552-138.203136V591.720448c0-76.19584-61.997056-138.203136-138.47552-138.203136M512.340992 
771.18464c51.193856 0 92.843008-41.649152 92.843008-92.843008 0-51.192832-41.649152-92.841984-92.843008-92.841984s-92.841984 41.649152-92.841984 92.841984c0 51.193856 41.648128 92.843008 92.841984 92.843008m276.584448-276.707328c53.77024 0 97.51552 43.623424 97.51552 97.243136v190.537728c0 53.619712-43.74528 97.243136-97.51552 97.243136H235.75552c-53.77024 0-97.516544-43.6224-97.516544-97.243136V591.720448c0-53.619712 43.74528-97.243136 97.51552-97.243136h553.16992" fill="#000000" /></svg>
)";
static const std::string PAUSE = R"(
<?xml version="1.0" encoding="iso-8859-1"?>
<!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools -->
<svg height="800px" width="800px" version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" 
	 viewBox="0 0 506.4 506.4" xml:space="preserve">
<path style="fill:#E07D46;" d="M502.4,253.2c0,137.6-111.6,249.2-249.2,249.2S4,390.8,4,253.2S115.6,4,253.2,4
	S502.4,115.6,502.4,253.2z"/>
<g>
	<path style="fill:#F4EFEF;" d="M225.2,145.2V364c0,6.4-4.8,13.2-11.2,13.2h-8.4c-6.4,0-8.4-6.8-8.4-13.2V142.4c0-6.4,2-9.2,8.4-9.2
		h8.4c6.4,0,10.8,5.6,10.8,12"/>
	<path style="fill:#F4EFEF;" d="M309.2,145.2V364c0,6.4-5.6,13.2-12,13.2h-8.4c-6.4,0-7.6-6.8-7.6-13.2V142.4c0-6.4,1.2-9.2,7.6-9.2
		h8.4c6.4,0,10.8,5.6,10.8,12"/>
</g>
<path d="M253.2,506.4C113.6,506.4,0,392.8,0,253.2S113.6,0,253.2,0s253.2,113.6,253.2,253.2S392.8,506.4,253.2,506.4z M253.2,8
	C118,8,8,118,8,253.2s110,245.2,245.2,245.2s245.2-110,245.2-245.2S388.4,8,253.2,8z"/>
<path d="M298.4,385.2h-9.2c-8.8,0-16-7.2-16-15.6V144.8c0-8.4,8-16,16.8-16h7.6c8.4,0,15.6,7.2,15.6,16v224.4
	C313.2,378.4,306.8,385.2,298.4,385.2z M290,137.2c-4.4,0-8.8,3.6-8.8,8V370c0,4,3.6,7.6,8,7.6h9.2c4.4,0,6.8-4,6.8-8V145.2
	c0-4.4-3.2-8-7.6-8H290z"/>
<path d="M216.4,383.2h-9.2c-8.8,0-16-7.2-16-15.6V142.8c0-8.4,8-16,16.8-16h7.6c8.4,0,15.6,7.2,15.6,16v224.4
	C231.2,376.4,224.8,383.2,216.4,383.2z M208,135.2c-4.4,0-8.8,3.6-8.8,8V368c0,4,3.6,7.6,8,7.6h9.2c4.4,0,6.8-4,6.8-8V143.2
	c0-4.4-3.2-8-7.6-8H208z"/>
</svg>
)";
static const std::string PLAY = R"(
<?xml version="1.0" encoding="utf-8"?>
<!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools -->
<svg width="800px" height="800px" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg">
  <g id="Group_17" data-name="Group 17" transform="translate(-776 -253) ">
    <circle id="Ellipse_5" data-name="Ellipse 5" cx="15" cy="15" r="15" transform="translate(777 254) " fill="#e8f7f9" stroke="#333" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"/>
    <path id="Path_20" data-name="Path 20" d="M788,274l10-5-10-5Z" fill="#ffc2c2" stroke="#333" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"/>
  </g>
</svg>
)";
static const std::string STOP = R"(
<?xml version="1.0" encoding="UTF-8"?>
<!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools -->
<svg width="800px" height="800px" version="1.1" viewBox="0 0 506.4 506.4" xml:space="preserve" xmlns="http://www.w3.org/2000/svg">
<circle cx="253.2" cy="253.2" r="249.2" fill="#80b3ff"/>
<path d="m349.2 331.6c0 12-9.6 21.6-21.6 21.6h-152.8c-12 0-21.6-9.6-21.6-21.6v-152.8c0-12 9.6-21.6 21.6-21.6h152.8c12 0 21.6 9.6 21.6 21.6v152.8z" fill="#F4EFEF"/>
<path d="M253.2,506.4C113.6,506.4,0,392.8,0,253.2S113.6,0,253.2,0s253.2,113.6,253.2,253.2S392.8,506.4,253.2,506.4z M253.2,8  C118,8,8,118,8,253.2s110,245.2,245.2,245.2s245.2-110,245.2-245.2S388.4,8,253.2,8z"/>
<path d="m323.6 357.2h-152.8c-14 0-25.6-11.6-25.6-25.6v-152.8c0-14 11.6-25.6 25.6-25.6h152.8c14 0 25.6 11.6 25.6 25.6v152.8c0 14-11.6 25.6-25.6 25.6zm-152.8-196c-9.6 0-17.6 8-17.6 17.6v152.8c0 9.6 8 17.6 17.6 17.6h152.8c9.6 0 17.6-8 17.6-17.6v-152.8c0-9.6-8-17.6-17.6-17.6h-152.8z"/>
</svg>
)";
static const std::string QUESTION = R"(
<?xml version="1.0" encoding="iso-8859-1"?>
<!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools -->
<svg height="800px" width="800px" version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" 
	 viewBox="0 0 506.4 506.4" xml:space="preserve">
<circle style="fill:#ACD9EA;" cx="253.2" cy="253.2" r="249.2"/>
<g>
	<path style="fill:#F4EFEF;" d="M253.2,332.4c-10.8,0-20-8.8-20-19.6v-36c0-10.8,8.8-19.6,20-19.6c28,0,51.2-22.8,51.2-50.8
		s-22.8-50.8-50.8-50.8s-50.8,22.8-50.8,50.8c0,10.8-8.8,19.6-19.6,19.6s-19.6-8.8-19.6-19.6c0-50,40.8-90.4,90.4-90.4
		s90.8,40.8,90.8,90.4c0,43.2-26.8,79.2-70.8,88.4v18.4C273.2,323.6,264,332.4,253.2,332.4z"/>
	<path style="fill:#F4EFEF;" d="M252.4,395.6c-5.2,0-10.4-2-14-6c-3.6-3.6-5.6-8.8-5.6-14s2-10.4,5.6-14s8.8-5.6,14-5.6
		s10.4,2,14,5.6s6,8.8,6,14s-2,10.4-6,14C262.4,393.6,257.6,395.6,252.4,395.6z"/>
</g>
<path d="M253.2,506.4C113.6,506.4,0,392.8,0,253.2S113.6,0,253.2,0s253.2,113.6,253.2,253.2S392.8,506.4,253.2,506.4z M253.2,8
	C118,8,8,118,8,253.2s110,245.2,245.2,245.2s245.2-110,245.2-245.2S388.4,8,253.2,8z"/>
<path d="M249.2,336.4c-13.2,0-24-10.8-24-23.6v-36c0-12.8,12-23.6,26-23.6c26,0,48-21.6,48-46.8c0-26-20.8-46.8-46.4-46.8
	c-25.6,0-46.8,21.2-46.8,46.8c0,13.2-10.8,23.6-23.6,23.6c-13.2,0-23.6-10.8-23.6-23.6c0-52,42.4-94.4,94.4-94.4
	s92.8,41.6,92.8,94.4c0,44.8-29.2,81.2-72.8,91.6v15.2C273.2,325.6,262.4,336.4,249.2,336.4z M252.8,150.8c30,0,54.4,24.8,54.4,54.8
	c0,29.6-25.6,54.8-56,54.8c-8.4,0-18,6.8-18,15.6v36c0,8.8,7.2,15.6,16,15.6s16-7.2,16-15.6v-18.4c0-2,1.2-3.6,3.2-4
	c41.6-8.4,69.6-42.4,69.6-84.4c0-48.4-37.2-86.4-84.8-86.4s-86.4,38.8-86.4,86.4c0,8.8,7.2,15.6,15.6,15.6c8.8,0,15.6-7.2,15.6-15.6
	C198,175.2,222.4,150.8,252.8,150.8z"/>
<path d="M252.4,399.6c-6.4,0-12.4-2.4-16.8-7.2c-4.4-4.4-6.8-10.4-6.8-16.8s2.4-12.4,6.8-16.8c4.4-4.4,10.4-6.8,16.8-6.8
	c6.4,0,12.4,2.4,16.8,6.8c4.4,4.4,6.8,10.8,6.8,16.8c0,6.4-2.4,12.4-6.8,16.8C264.8,397.2,258.4,399.6,252.4,399.6z M252.4,360
	c-4,0-8.4,1.6-11.2,4.8c-2.8,2.8-4.4,6.8-4.4,11.2s1.6,8.4,4.4,11.2c2.8,2.8,7.2,4.8,11.2,4.8s8.4-1.6,11.2-4.8
	c2.8-2.8,4.8-7.2,4.8-11.2s-1.6-8-4.8-11.2C260.4,361.6,256.4,360,252.4,360z"/>
</svg>
)";
static const std::string WARNING = R"(
<?xml version="1.0" encoding="iso-8859-1"?>
<!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools -->
<svg height="800px" width="800px" version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" 
	 viewBox="0 0 507.425 507.425" xml:space="preserve">
<path style="fill:#FFC52F;" d="M329.312,129.112l13.6,22l150.8,242.4c22.4,36,6,65.2-36.8,65.2h-406.4c-42.4,0-59.2-29.6-36.8-65.6
	l198.8-320.8c22.4-36,58.8-36,81.2,0L329.312,129.112z"/>
<g>
	<path style="fill:#F4EFEF;" d="M253.712,343.512c-10.8,0-20-8.8-20-20v-143.2c0-10.8,9.2-20,20-20s20,8.8,20,20v143.2
		C273.712,334.312,264.512,343.512,253.712,343.512z"/>
	<path style="fill:#F4EFEF;" d="M253.312,407.112c-5.2,0-10.4-2-14-6c-3.6-3.6-6-8.8-6-14s2-10.4,6-14c3.6-3.6,8.8-6,14-6
		s10.4,2,14,6c3.6,3.6,6,8.8,6,14s-2,10.4-6,14C263.712,404.712,258.512,407.112,253.312,407.112z"/>
</g>
<path d="M456.912,465.512h-406.4c-22,0-38.4-7.6-46-21.6s-5.6-32.8,6-51.2l198.8-321.6c11.6-18.8,27.2-29.2,44.4-29.2l0,0
	c16.8,0,32.4,10,43.6,28.4l35.2,56.4l0,0l13.6,22l150.8,243.6c11.6,18.4,13.6,37.2,6,51.2
	C495.312,457.912,478.912,465.512,456.912,465.512z M253.312,49.912L253.312,49.912c-14,0-27.2,8.8-37.6,25.2l-198.8,321.6
	c-10,16-12,31.6-5.6,43.2s20.4,17.6,39.2,17.6h406.4c18.8,0,32.8-6.4,39.2-17.6c6.4-11.2,4.4-27.2-5.6-43.2l-150.8-243.6l-13.6-22
	l-35.2-56.4C280.512,58.712,267.312,49.912,253.312,49.912z"/>
<path d="M249.712,347.512c-13.2,0-24-10.8-24-24v-143.2c0-13.2,10.8-24,24-24s24,10.8,24,24v143.2
	C273.712,336.712,262.912,347.512,249.712,347.512z M249.712,164.312c-8.8,0-16,7.2-16,16v143.2c0,8.8,7.2,16,16,16s16-7.2,16-16
	v-143.2C265.712,171.512,258.512,164.312,249.712,164.312z"/>
<path d="M249.712,411.112L249.712,411.112c-6.4,0-12.4-2.4-16.8-6.8c-4.4-4.4-6.8-10.8-6.8-16.8c0-6.4,2.4-12.4,6.8-16.8
	c4.4-4.4,10.8-7.2,16.8-7.2c6.4,0,12.4,2.4,16.8,7.2c4.4,4.4,7.2,10.4,7.2,16.8s-2.4,12.4-7.2,16.8
	C262.112,408.312,256.112,411.112,249.712,411.112z M249.712,371.112c-4,0-8.4,1.6-11.2,4.8c-2.8,2.8-4.8,7.2-4.8,11.2
	c0,4.4,1.6,8.4,4.8,11.2c2.8,2.8,7.2,4.8,11.2,4.8s8.4-1.6,11.2-4.8c2.8-2.8,4.8-7.2,4.8-11.2s-1.6-8.4-4.8-11.2
	C258.112,372.712,253.712,371.112,249.712,371.112z"/>
</svg>
)";
}
}
#include <FL/Fl_Group.H>
namespace flw {
class GridGroup : public Fl_Group {
public:
    explicit                    GridGroup(int X = 0, int Y = 0, int W = 0, int H = 0, const char* l = nullptr);
                                ~GridGroup();
    void                        add(Fl_Widget* widget, int X, int Y, int W, int H, Fl_Widget* F = nullptr);
    void                        adjust(Fl_Widget* widget, int L = 0, int R = 0, int T = 0, int B = 0);
    void                        clear();
    void                        do_layout()
                                    { resize(x(), y(), w(), h()); Fl::redraw(); }
    int                         handle(int event) override;
    Fl_Widget*                  remove(Fl_Widget* widget);
    void                        resize(int X, int Y, int W, int H) override;
    void                        resize(Fl_Widget* widget, int X, int Y, int W, int H);
    int                         size() const
                                    { return _size; }
    void                        size(int size)
                                    { _size = (size >= 4 && size <= 72) ? size : 0; }
private:
    void                        _last_active_widget(Fl_Widget** first, Fl_Widget** last);
    VoidVector                  _widgets;
    int                         _size;
};
}
#include <FL/Fl_Group.H>
namespace flw {
class ToolGroup : public Fl_Group {
public:
    enum class Pos {
                                HORIZONTAL,
                                VERTICAL,
    };
                                ToolGroup(int X = 0, int Y = 0, int W = 0, int H = 0, const char* l = nullptr);
                                ~ToolGroup();
    Fl_Widget*                  add(Fl_Widget* widget, unsigned size = 0);
    void                        clear();
    void                        do_layout()
                                    { resize(x(), y(), w(), h()); Fl::redraw(); }
    bool                        expand_last() const
                                    { return _expand; }
    void                        expand_last(bool value)
                                    { _expand = value; do_layout(); }
    Pos                         pos() const
                                    { return _pos; }
    void                        pos(Pos pos)
                                    { _pos = pos; do_layout(); }
    Fl_Widget*                  remove(Fl_Widget* widget);
    Fl_Widget*                  replace(Fl_Widget* old_widget, Fl_Widget* new_widget);
    void                        resize(int X, int Y, int W, int H) override;
    void                        size(Fl_Widget* widget, unsigned size);
    void                        size(unsigned size);
private:
    Pos                         _pos;
    VoidVector                  _widgets;
    bool                        _expand;
};
}
#include <FL/Fl_Hold_Browser.H>
#include <FL/Fl_Menu_Button.H>
namespace flw {
class ScrollBrowser : public Fl_Hold_Browser {
public:
                                ScrollBrowser(int lines = 9, int X = 0, int Y = 0, int W = 0, int H = 0, const char* l = nullptr);
    void                        disable_menu()
                                    { _flag_menu = false; }
    void                        disable_scrollmode()
                                    { _flag_move = false; }
    void                        enable_menu()
                                    { _flag_menu = true; }
    void                        enable_scrollmode()
                                    { _flag_move = true; }
    bool                        is_menu_enabled() const
                                    { return _flag_menu; }
    bool                        is_scrollmode_enabled() const
                                    { return _flag_move; }
    int                         handle(int event) override;
    Fl_Menu_Button*             menu()
                                    { return _menu; }
    int                         scroll_lines() const
                                    { return _scroll; }
    void                        scroll_lines(int lines)
                                    { if (lines > 0) _scroll = lines; }
    std::string                 text2() const
                                    { return util::remove_browser_format(util::to_string(text(value()))); }
    std::string                 text2(int line) const
                                    { return util::remove_browser_format(util::to_string(text(line))); }
    void                        update_pref(Fl_Font text_font = flw::PREF_FONT, Fl_Fontsize text_size = flw::PREF_FONTSIZE);
    static void                 Callback(Fl_Widget*, void*);
private:
    Fl_Menu_Button*             _menu;
    bool                        _flag_menu;
    bool                        _flag_move;
    int                         _scroll;
};
}
#include <FL/Fl_Box.H>
#include <FL/Fl_Button.H>
#include <FL/Fl_Group.H>
namespace flw {
class DateChooser : public GridGroup {
public:
    explicit                    DateChooser(int X = 0, int Y = 0, int W = 0, int H = 0, const char* l = nullptr);
    void                        draw() override;
    void                        focus();
    gnu::Date                   get() const;
    int                         handle(int event) override;
    void                        set(const gnu::Date& date);
private:
    static void                 _Callback(Fl_Widget* w, void* o);
    void                        _set_label();
    Fl_Box*                     _month_label;
    Fl_Button*                  _b1;
    Fl_Button*                  _b2;
    Fl_Button*                  _b3;
    Fl_Button*                  _b4;
    Fl_Button*                  _b5;
    Fl_Button*                  _b6;
    Fl_Button*                  _b7;
    Fl_Widget*                  _canvas;
    ToolGroup*                  _buttons;
};
}
#include <FL/Fl_Box.H>
#include <FL/Fl_Button.H>
#include <FL/Fl_Double_Window.H>
#include <FL/Fl_Hold_Browser.H>
#include <FL/Fl_Hor_Fill_Slider.H>
#include <FL/Fl_Toggle_Button.H>
namespace flw {
namespace dlg {
Fl_Button*                      button(int X, int Y, int W, int H, const std::string& l);
Fl_Button*                      button(int X, int Y, int W, int H, const std::string& l, const std::string& icon, bool ret = false);
void                            center_fl_message_dialog();
bool                            date(const std::string& title, gnu::Date& date, int W = 33, int H = 21);
bool                            font(Fl_Font& font, Fl_Fontsize& fontsize, std::string& fontname, bool limit_to_default = false);
void                            html(const std::string& title, const std::string& text, int W = 40, int H = 23);
std::string                     input(const std::string& title, const std::string& message, std::string& value, int W = 40, int H = 11);
std::string                     input_double(const std::string& title, const std::string& message, double& value, int W = 40, int H = 11);
std::string                     input_int(const std::string& title, const std::string& message, int64_t& value, int W = 40, int H = 11);
std::string                     input_multi(const std::string& title, const std::string& message, std::string& value, int W = 54, int H = 22);
std::string                     input_secret(const std::string& title, const std::string& message, std::string& value, int W = 40, int H = 11);
void                            list(const std::string& title, const StringVector& list, bool fixed_font = false, int W = 40, int H = 23);
void                            list(const std::string& title, const std::string& list, bool fixed_font = false, int W = 40, int H = 23);
void                            list_file(const std::string& title, const std::string& file, bool fixed_font = false, int W = 40, int H = 23);
void                            msg(const std::string& title, const std::string& message, int W = 40, int H = 9);
std::string                     msg_ask(const std::string& title, const std::string& message, const std::string& b1 = label::YES, const std::string& b2 = label::NO, const std::string& b3 = "", const std::string& b4 = "", const std::string& b5 = "", int W = 54, int H = 9);
void                            msg_alert(const std::string& title, const std::string& message, int W = 40, int H = 9);
void                            msg_error(const std::string& title, const std::string& message, int W = 40, int H = 9);
std::string                     msg_warning(const std::string& title, const std::string& message, const std::string& b1 = label::YES, const std::string& b2 = label::NO, int W = 40, int H = 9);
void                            options(Fl_Window* parent = Fl::first_window(), bool msg_icon_border = true, bool msg_label_border = false, bool msg_active_color = false);
void                            options_pop();
void                            options_push();
void                            panic(const std::string& message);
bool                            password(const std::string& title, std::string& password);
bool                            password_confirm(const std::string& title, std::string& password);
bool                            password_confirm_and_file(const std::string& title, std::string& password, std::string& file);
bool                            password_and_file(const std::string& title, std::string& password, std::string& file);
void                            print(const std::string& title, PrintCallback cb, void* data = nullptr, int from = 1, int to = 0);
bool                            print_text(const std::string& title, const std::string& text);
bool                            print_text(const std::string& title, const StringVector& text);
StringVector                    select_checkboxes(const std::string& title, const StringVector& list);
int                             select_choice(const std::string& title, const StringVector& list, int selected = 0);
int                             select_string(const std::string& title, const StringVector& list, int select_row, bool fixed_font = false, int W = 40, int H = 23);
int                             select_string(const std::string& title, const StringVector& list, const std::string& select_row, bool fixed_font = false, int W = 40, int H = 23);
bool                            slider(const std::string& title, double min, double max, double& value, double step = 1.0);
void                            text(const std::string& title, const std::string& text, int W = 40, int H = 23);
bool                            text_edit(const std::string& title, std::string& text, int W = 40, int H = 23);
void                            theme(bool enable_font = false, bool enable_fixedfont = false);
class Font : public Fl_Double_Window {
public:
                                Font(Fl_Font font, Fl_Fontsize fontsize, const std::string& title = "Select Font", bool limit_to_default = false);
                                Font(const std::string& font, Fl_Fontsize fontsize, const std::string& title = "Select Font", bool limit_to_default = false);
    void                        activate_font()
                                    { static_cast<Fl_Widget*>(_fonts)->activate(); }
    void                        activate_font_size()
                                    { static_cast<Fl_Widget*>(_fonts)->activate(); }
    void                        deactivate_font()
                                    { static_cast<Fl_Widget*>(_fonts)->deactivate(); }
    void                        deactivate_fontsize()
                                    { static_cast<Fl_Widget*>(_sizes)->deactivate(); }
    int                         font()
                                    { return _font; }
    std::string                 fontname()
                                    { return _fontname; }
    int                         fontsize()
                                    { return _fontsize; }
    bool                        run();
private:
    void                        _activate();
    void                        _create(Fl_Font font, const std::string& fontname, Fl_Fontsize fontsize, const std::string& label, bool limit_to_default);
    void                        _select_name(const std::string& font_name);
    static void                 Callback(Fl_Widget* w, void* o);
    Fl_Box*                     _label;
    Fl_Button*                  _cancel;
    Fl_Button*                  _select;
    GridGroup*                  _grid;
    ScrollBrowser*              _fonts;
    ScrollBrowser*              _sizes;
    bool                        _ret;
    bool                        _run;
    int                         _font;
    int                         _fontsize;
    std::string                 _fontname;
};
class Progress : public Fl_Double_Window {
public:
                                Progress(const std::string& title, bool cancel = false, bool pause = false, double min = 0.0, double max = 0.0);
    void                        range(double min, double max);
    void                        start();
    bool                        update(const StringVector& messages, unsigned milli = 100);
    bool                        update(double value, const StringVector& messages, unsigned milli = 100);
    bool                        update(const std::string& message, unsigned milli = 100);
    bool                        update(double value, const std::string& message, unsigned milli = 100);
    double                      value() const
                                    { return _progress->value(); }
    void                        value(double value);
private:
    static void                 Callback(Fl_Widget* w, void* o);
    Fl_Button*                  _cancel;
    Fl_Hold_Browser*            _label;
    Fl_Hor_Fill_Slider*         _progress;
    Fl_Toggle_Button*           _pause;
    GridGroup*                  _grid;
    bool                        _ret;
    unsigned                    _last;
};
}
}
#include <FL/Fl_Group.H>
#include <FL/Fl_Input.H>
#include <FL/Fl_Menu_Button.H>
namespace flw {
class _InputMenu;
class InputMenu : public Fl_Group {
public:
                                InputMenu(const InputMenu&) = delete;
                                InputMenu(InputMenu&&) = delete;
    InputMenu&                  operator=(const InputMenu&) = delete;
    InputMenu&                  operator=(InputMenu&&) = delete;
    explicit                    InputMenu(int X = 0, int Y = 0, int W = 0, int H = 0, const char* l = nullptr);
    void                        clear();
    Fl_Input*                   input()
                                    { return reinterpret_cast<Fl_Input*>(_input); }
    void                        insert(const std::string& string, unsigned max_list_len);
    Fl_Menu_Button*             menu()
                                    { return _menu; }
    bool                        menu_visible() const
                                    { return _menu->visible() != 0; }
    void                        menu_visible(bool value)
                                    { if (value == true) _menu->show(); else _menu->hide(); resize(x(), y(), w(), h()); }
    StringVector                get_history() const;
    void                        resize(int X, int Y, int W, int H) override;
    void                        update_pref(Fl_Font text_font = flw::PREF_FONT, Fl_Fontsize text_size = flw::PREF_FONTSIZE);
    std::string                 value() const;
    void                        value(const std::string& string);
    void                        values(const StringVector& list, const std::string& input_value)
                                    { _values(list, input_value); }
    void                        values(const StringVector& list, size_t list_index = -1)
                                    { _values(list, list.size() > list_index ? list[list_index] : ""); }
private:
    void                        _add(bool insert, const std::string& string, int max_list_len);
    void                        _add(bool insert, const StringVector& list);
    void                        _values(const StringVector& list, const std::string& value);
    static void                 _CallbackInput(Fl_Widget*, void*);
    static void                 _CallbackMenu(Fl_Widget*, void*);
    _InputMenu*                 _input;
    Fl_Menu_Button*             _menu;
};
}
#include <FL/Fl_Menu_.H>
#include <FL/Fl_Preferences.H>
namespace flw {
namespace util {
class RecentMenu {
public:
                                RecentMenu(Fl_Menu_* menu, Fl_Callback* callback, void* userdata = nullptr, const std::string& base_label = "&File/Open Recent", const std::string& clear_label = "/Clear");
    void                        append(const std::string& item)
                                    { return _add(item, true); }
    void                        clear()
                                    { return _add("", false); }
    void                        insert(const std::string& item)
                                    { return _add(item, false); }
    StringVector                items() const
                                    { return _items; }
    void                        items(const StringVector& names);
    size_t                      max_items() const
                                    { return _max; }
    void                        max_items(size_t max)
                                    { if (max > 0 && max <= 100) _max = max; }
    Fl_Menu_*                   menu()
                                    { return _menu; }
    void                        load_pref(Fl_Preferences& pref, const std::string& base_name = "files");
    void                        save_pref(Fl_Preferences& pref, const std::string& base_name = "files");
    void*                       user_data()
                                    { return _user; }
    void                        user_data(void* data)
                                    { _user = data; }
private:
    void                        _add(const std::string& item, bool append);
    size_t                      _add_string(StringVector& items, size_t max_size, const std::string& string);
    size_t                      _insert_string(StringVector& items, size_t max_size, const std::string& string);
    static void                 _Callback(Fl_Widget*, void* o);
    std::string                 _base;
    Fl_Callback*                _callback;
    std::string                 _clear;
    StringVector                _items;
    size_t                      _max;
    Fl_Menu_*                   _menu;
    void*                       _user;
};
}
}
#include <FL/Fl.H>
#include <FL/Fl_Group.H>
namespace flw {
class SplitGroup : public Fl_Group {
public:
    enum class Pos {
                                HORIZONTAL,
                                VERTICAL,
    };
    explicit                    SplitGroup(int X = 0, int Y = 0, int W = 0, int H = 0, const char* l = nullptr);
    void                        add(Fl_Widget* widget, bool first);
    Fl_Widget*                  child(bool first)
                                    { return _widgets[first]; }
    void                        clear();
    void                        do_layout()
                                    { SplitGroup::resize(x(), y(), w(), h()); Fl::redraw(); }
    int                         handle(int event) override;
    void                        hide_child(bool first);
    int                         min_split_pos() const
                                    { return _min_split_pos; }
    void                        min_split_pos(unsigned min_size)
                                    { _min_split_pos = min_size; }
    Pos                         pos() const
                                    { return _pos; }
    void                        pos(Pos pos);
    void                        resize(int X, int Y, int W, int H) override;
    int                         split_pos() const
                                    { return _split_pos; }
    void                        split_pos(int split_pos)
                                    { if (split_pos > 0 || split_pos == -1) _split_pos = split_pos; }
    void                        show_child(bool first);
    void                        swap()
                                    { auto tmp = _widgets[0]; _widgets[0] = _widgets[1]; _widgets[1] = tmp; do_layout(); }
private:
    Pos                         _pos;
    Fl_Widget*                  _widgets[2];
    bool                        _drag;
    int                         _min_split_pos;
    int                         _split_pos;
};
}
#include <FL/Fl_Flex.H>
#include <FL/Fl_Scroll.H>
namespace flw {
class TabsGroup : public Fl_Group {
public:
    static const int            DEFAULT_SPACE             =  2;
    static const int            DEFAULT_MAX_HOR_TAB_WIDTH = 12;
    static const int            DEFAULT_VER_TAB_WIDTH     = 12;
    static const int            HEIGHT                    =  8;
    static const int            MAX_SPACE                 = 20;
    static const int            MIN_WIDTH                 =  4;
    enum class Pos {
                                TOP,
                                BOTTOM,
                                LEFT,
                                RIGHT,
                                TOP2,
                                BOTTOM2,
                                LEFT2,
                                RIGHT2,
                                LAST = RIGHT2,
    };
    explicit                    TabsGroup(int X = 0, int Y = 0, int W = 0, int H = 0, const char* l = nullptr);
    void                        add(const std::string& label, Fl_Widget* widget, const Fl_Widget* after =  nullptr, const std::string& tooltip = "");
    void                        border(int n = 0, int s = 0, int w = 0, int e = 0)
                                    { _n = n; _s = s; _w = w; _e = e; do_layout(); }
    Fl_Widget*                  child(int index) const;
    int                         children() const
                                    { return static_cast<int>(_widgets.size()); }
    void                        clear();
    void                        debug(bool all = true) const;
    void                        disable_keyboard()
                                    { _keyboard = false; }
    void                        do_layout()
                                    { TabsGroup::resize(x(), y(), w(), h()); Fl::redraw(); }
    void                        enable_keyboard()
                                    { _keyboard = true; }
    int                         find(const Fl_Widget* widget) const;
    int                         handle(int event) override;
    void                        hide_tabs();
    void                        insert(const std::string& label, Fl_Widget* widget, const Fl_Widget* before = nullptr, const std::string& tooltip = "");
    bool                        is_tabs_bottom() const
                                    { return _tab_pos == Pos::BOTTOM || _tab_pos == Pos::BOTTOM2; }
    bool                        is_tabs_left() const
                                    { return _tab_pos == Pos::LEFT || _tab_pos == Pos::LEFT2; }
    bool                        is_tabs_horizontal() const
                                    { return _tab_pos == Pos::TOP || _tab_pos == Pos::TOP2 || _tab_pos == Pos::BOTTOM || _tab_pos == Pos::BOTTOM2; }
    bool                        is_tabs_right() const
                                    { return _tab_pos == Pos::RIGHT || _tab_pos == Pos::RIGHT2; }
    bool                        is_tabs_top() const
                                    { return _tab_pos == Pos::TOP || _tab_pos == Pos::TOP2; }
    bool                        is_tabs_visible() const
                                    { return _tabs->visible(); }
    bool                        is_tabs_vertical() const
                                    { return _tab_pos == Pos::LEFT || _tab_pos == Pos::LEFT2 || _tab_pos == Pos::RIGHT || _tab_pos == Pos::RIGHT2; }
    void                        max_top_width(unsigned characters = TabsGroup::DEFAULT_MAX_HOR_TAB_WIDTH)
                                    { if (characters >= TabsGroup::MIN_WIDTH && characters <= 100) _width2 = characters; }
    Fl_Widget*                  remove(int index);
    Fl_Widget*                  remove(Fl_Widget* widget)
                                    { return TabsGroup::remove(find(widget)); }
    void                        resize(int X, int Y, int W, int H) override;
    void                        show_tabs();
    void                        sort(bool ascending = true, bool casecompare = false);
    void                        tab_box(Fl_Boxtype up_box = FL_MAX_BOXTYPE, Fl_Boxtype down_box = FL_MAX_BOXTYPE);
    void                        tab_color(Fl_Color color = FL_SELECTION_COLOR);
    std::string                 tab_label(const Fl_Widget* widget);
    void                        tab_label(const std::string& label, Fl_Widget* widget);
    Pos                         tab_pos() const
                                    { return _tab_pos; }
    void                        tab_pos(Pos pos, int space = TabsGroup::DEFAULT_SPACE);
    int                         swap(int from, int to);
    std::string                 tooltip(Fl_Widget* widget) const;
    void                        tooltip(const std::string& label, Fl_Widget* widget);
    void                        update_pref(Fl_Font font = flw::PREF_FONT, Fl_Fontsize fontsize = flw::PREF_FONTSIZE);
    Fl_Widget*                  value() const;
    void                        value(int num);
    void                        value(Fl_Widget* widget)
                                    { _activate(widget); }
    static void                 CallbackButton(Fl_Widget* sender, void* object);
    static void                 CallbackScrollbar(Fl_Widget* sender, void* object);
    static const char*          Help();
private:
    void                        _activate(Fl_Widget* widget);
    Fl_Widget*                  _active_button();
    void                        _resize_active_widget();
    void                        _resize_left_right(int X, int Y, int W, int H);
    void                        _resize_top_bottom(int X, int Y, int W, int H);
    Fl_Boxtype                  _down_box;
    Fl_Boxtype                  _up_box;
    Fl_Color                    _color;
    Fl_Group*                   _tabs;
    Fl_Rect                     _area;
    Fl_Scrollbar*               _scroll;
    Pos                         _tab_pos;
    WidgetVector                _widgets;
    bool                        _keyboard;
    bool                        _drag;
    int                         _active1;
    int                         _active2;
    int                         _e;
    int                         _n;
    int                         _s;
    int                         _space;
    int                         _visible;
    int                         _w;
    int                         _width1;
    int                         _width2;
};
}
namespace flw {
class WaitCursor {
    static WaitCursor*          WAITCURSOR;
public:
                                WaitCursor();
                                ~WaitCursor();
};
}
#include <set>
#include <unordered_map>
#include <unordered_set>
#include <inttypes.h>
#include <FL/Fl_Text_Display.H>
class Fl_Menu_Button;
class Fl_Preferences;
class Fl_Window;
namespace flw {
class ScrollBrowser;
class SplitGroup;
}
namespace fle {
class Editor;
class FindReplace;
class Message;
class TextBuffer;
class View;
extern std::string                              APPLICATION;
typedef std::vector<int>                        IntVector;
typedef std::set<std::string>                   StringSet;
typedef std::unordered_map<std::string, int>    StringIntHash;
typedef std::unordered_set<std::string>         StringHash;
typedef std::vector<Message*>                   MessageVector;
enum class FBinFile {
    NO,
    TEXT,
    HEX_16,
    HEX_32,
};
enum class FCase {
    LOWER,
    UPPER,
};
enum class FCaseCompare {
    NO,
    YES,
};
enum class FChecksum {
    NO,
    YES,
};
enum class FCopy {
    COPY_LINE,
    CUT_LINE,
};
enum class FDelKey {
    NIL,
    BACKSPACE,
    DEL,
};
enum class FDelText {
    WORD,
    LINE,
};
enum class FHideFind {
    NO,
    YES,
};
enum class FIndent {
    BREAKLINE,
    ADDLINE,
};
enum class FFindLines {
    GETINPUT,
    RUNAGAIN,
};
enum FKEY {
    FKEY_KOMMAND_START,
    FKEY_KOMMAND_STOP,
    FKEY_AUTOCOMPLETE,
    FKEY_BOOKMARKS_NEXT,
    FKEY_BOOKMARKS_PREV,
    FKEY_BOOKMARKS_TOGGLE,
    FKEY_CASE_LOWER,
    FKEY_CASE_UPPER,
    FKEY_COMMENT_BLOCK,
    FKEY_COMMENT_LINE,
    FKEY_COPY_TEXT,
    FKEY_CUT_TEXT,
    FKEY_DELETE_LINE_LEFT,
    FKEY_DELETE_LINE_RIGHT,
    FKEY_DELETE_WORD_LEFT,
    FKEY_DELETE_WORD_RIGHT,
    FKEY_DUP_TEXT,
    FKEY_ENTER1,
    FKEY_ENTER2,
    FKEY_FIND_LINES,
    FKEY_FIND_LINES_AGAIN,
    FKEY_GOTO_LINE,
    FKEY_HELP,
    FKEY_HOME,
    FKEY_JUMP_DOWN,
    FKEY_JUMP_UP,
    FKEY_MENU,
    FKEY_MOVE_DOWN,
    FKEY_MOVE_UP,
    FKEY_OUTPUT_NEXT,
    FKEY_OUTPUT_PREV,
    FKEY_OUTPUT_TOGGLE,
    FKEY_QUICK_FIND,
    FKEY_REDO,
    FKEY_REPLACE,
    FKEY_SEARCH_BACKWARD,
    FKEY_SEARCH_FORWARD,
    FKEY_SELECT_LINE,
    FKEY_SELECT_PAIR1,
    FKEY_SELECT_PAIR2,
    FKEY_SELECT_STYLE,
    FKEY_SHIFT_LEFT,
    FKEY_SHIFT_RIGHT,
    FKEY_SHOW_CUSTOM1,
    FKEY_SHOW_CUSTOM2,
    FKEY_SHOW_FIND_REPLACE,
    FKEY_SORT_ASCENDING,
    FKEY_SORT_DESCENDING,
    FKEY_UNDO,
    FKEY_VIEW_1,
    FKEY_VIEW_2,
    FKEY_VIEW_CLOSE,
    FKEY_SIZE,
};
enum class FLineEnding {
    UNIX,
    WINDOWS,
};
enum class FMoveH {
    LEFT,
    RIGHT,
};
enum class FMoveV {
    UP,
    DOWN,
};
enum class FNlTab {
    NO,
    FIND,
    REPLACE,
    YES,
};
enum class FOutput {
    SHOW_HORIZONTAL,
    SHOW_VERTICAL,
    SHOW,
    TOGGLE,
};
enum class FRegex {
    NO,
    YES,
};
enum class FRegexType {
    REPLACE,
    INSERT,
    APPEND,
};
enum class FSaveWord {
    NO,
    YES,
};
enum class FSearchDir {
    FORWARD,
    BACKWARD,
};
enum class FSelection {
    NO,
    YES,
};
enum class FSort {
    ASCENDING,
    DESCENDING,
};
enum class FSplitView {
    NO,
    VERTICAL,
    HORIZONTAL,
};
enum class FTab {
    HARD,
    SOFT,
};
enum class FTrim {
    NO,
    YES,
};
enum class FUndoMode {
    FLE_V1,
    FLTK,
    NONE,
    FLE_V2,
    FLE_V3,
};
enum class FUndoModeFle {
    TYPE,
    TIME,
    HARD,
};
enum class FUndoRange {
    ONE,
    ALL,
    SAVEPOINT,
};
enum class FWordCompare {
    NO,
    YES,
};
enum class FWrap {
    NO,
    YES,
};
namespace ascii {
    constexpr const unsigned char BACKSLASH    = '\\';
    constexpr const unsigned char CLOSE_PARENT = ')';
    constexpr const unsigned char NEWLINE      = '\n';
    constexpr const unsigned char OPEN_PARENT  = '(';
    constexpr const unsigned char QUOTE        = '"';
    constexpr const unsigned char SINGLE_QUOTE = '\'';
    constexpr const unsigned char SPACE        = ' ';
}
namespace errors {
    static const std::string FILE_DELETED        = "error: file has been deleted!";
    static const std::string FILE_IS_DIR         = "error: can't open <%s> because it is a directory!";
    static const std::string FILE_TOO_LARGE      = "error: file too large <%s>!";
    static const std::string HEX_TOO_LARGE       = "error: binary file too large to view as hex <%s>!";
    static const std::string LOADING_BIN         = "error: can't load binary file <%s>, binary file loading has been turned off.";
    static const std::string LOADING_FILE        = "error: failed to read file <%s>!";
    static const std::string NO_FILENAME         = "error: no filename!";
    static const std::string SAVE_FILE           = "error: failed to save file <%s>!";
    static const std::string TEXT_DIFF_FROM_FILE = "error: file is not same as on disk (%s)";
    static const std::string TEXT_IS_READ_ONLY   = "error: text is in readonly mode!";
}
namespace info {
    static const std::string ASK_RELOAD           = "File %s has been changed on disk\nWould you like to load it again and discard changes?";
    static const std::string BACKUP_LOADED        = "file is missing but found backup file!";
    static const std::string BIN_LOADED           = "Binary file has been loaded as text";
    static const std::string FILE_RELOAD          = "File changed on disk and reloaded";
    static const std::string FILE_WRAPPED         = "Word wrapping has been turned on due to very long text lines";
    static const std::string FOUND_LINES          = "Found %u lines in %d mS";
    static const std::string FOUND_STRING_POS     = "Found string at pos %d";
    static const std::string FOUND_STRING_LINE    = "Found string at line %d";
    static const std::string FOUND_STRING_LINECOL = "Found string at line %d, column %d";
    static const std::string HEX_LOADED           = "Binary file has been loaded as hex";
    static const std::string NO_SPACES_REPLACED   = "Unable to convert spaces to tabs!";
    static const std::string NO_STRINGS_REPLACED  = "Unable to replace <%s> with <%s>";
    static const std::string NO_STRING_FOUND      = "Unable to find <%s>";
    static const std::string NO_TABS_REPLACED     = "Unable to convert tabs to spaces!";
    static const std::string PAIRS                = "Could not found matching pairs";
    static const std::string REDID_CHANGES        = "Redid %d changes";
    static const std::string REMOVED_TRAILING     = "Removed whitespace from %u lines";
    static const std::string REPLACED_STRINGS     = "Replaced %u strings in %d mS";
    static const std::string SPACES_REPLACED      = "Replaced spaces with %d tabs";
    static const std::string STYLE_OFF            = "Styling has been turned off!";
    static const std::string TABS_REPLACED        = "Replaced %d tabs with spaces";
    static const std::string TEXT_SAME_AS_FILE    = "File and buffer are the same";
    static const std::string UNDID_CHANGES        = "Undid %d changes";
    static const std::string UNDO_MEMORY          = "Warning: memory usage for undo has reached %lld bytes";
}
namespace message {
    const std::string CUSTOM_AUTOCOMPLETE     = "message: custom wordfile has changed settings";
    const std::string CUSTOM_CALLBACK         = "message: custom callback (s = selected, p = editor)";
    const std::string DND_EVENT               = "message: editor has received an dnd event (p = bool*)";
    const std::string EDITOR_FOCUS            = "message: editor has focus (p = Editor*)";
    const std::string FILE_LOADED             = "message: editor has loaded a file (p = Editor*)";
    const std::string FONTSIZE2_CHANGED       = "message: fontsize overruled";
    const std::string HIDE_FIND               = "message: hide find widget (p = FindReplace*)";
    const std::string PREF_CHANGED            = "message: pref has been changed";
    const std::string RESET_INSERT_MODE       = "message: reset insert mode to default";
    const std::string SHOW_CUSTOM1            = "message: show custom1 widget (p = Editor*)";
    const std::string SHOW_CUSTOM2            = "message: show custom2 widget (p = Editor*)";
    const std::string SHOW_FIND               = "message: show find widget (p = FindReplace*)";
    const std::string STATUSBAR_LINE_UNIX     = "message: unix line ending";
    const std::string STATUSBAR_LINE_WIN      = "message: windows line ending";
    const std::string STATUSBAR_STYLE_CHANGED = "message: style has changed (p = style name)";
    const std::string STATUSBAR_TAB_CHANGED   = "message: tab has changed";
    const std::string STATUSBAR_TO_SPACES     = "message: convert to spaces";
    const std::string STATUSBAR_TO_TABS       = "message: convert to tabs";
    const std::string TEXT_CHANGED            = "message: text has changed saved status (p = Editor*)";
    const std::string UNDO_MODE_CHANGED       = "message: undo mode has changed";
}
enum {
    LIMIT_MIN,
    LIMIT_VAL,
    LIMIT_MAX,
    LIMIT_DEF,
};
namespace limits {
    extern const size_t         FIND_LIST_MAX;
    extern const size_t         HEXFILE_DIVIDER;
    extern const size_t         MOUSE_SCROLL_MAX;
    extern const size_t         TAB_WIDTH_MAX;
    extern const size_t         UNDO_WARNING;
    extern const size_t         WRAP_DEF;
    extern const size_t         WRAP_MAX;
    extern const size_t         WRAP_MIN;
    extern const size_t         AUTOCOMPLETE_FILESIZE_DEF;
    extern const size_t         AUTOCOMPLETE_FILESIZE_MAX;
    extern const size_t         AUTOCOMPLETE_FILESIZE_MIN;
    extern const size_t         AUTOCOMPLETE_FILESIZE_STEP;
    extern size_t               AUTOCOMPLETE_FILESIZE_VAL;
    extern const size_t         AUTOCOMPLETE_LINES_DEF;
    extern const size_t         AUTOCOMPLETE_LINES_MAX;
    extern const size_t         AUTOCOMPLETE_LINES_MIN;
    extern const size_t         AUTOCOMPLETE_LINES_STEP;
    extern size_t               AUTOCOMPLETE_LINES_VAL;
    extern const size_t         AUTOCOMPLETE_WORD_SIZE_DEF;
    extern const size_t         AUTOCOMPLETE_WORD_SIZE_MAX;
    extern const size_t         AUTOCOMPLETE_WORD_SIZE_MIN;
    extern const size_t         AUTOCOMPLETE_WORD_SIZE_STEP;
    extern size_t               AUTOCOMPLETE_WORD_SIZE_VAL;
    extern const size_t         COUNT_CHAR_DEF;
    extern const size_t         COUNT_CHAR_MAX;
    extern const size_t         COUNT_CHAR_MIN;
    extern const size_t         COUNT_CHAR_STEP;
    extern size_t               COUNT_CHAR_VAL;
    extern const size_t         FILE_BACKUP_SIZE_DEF;
    extern const size_t         FILE_BACKUP_SIZE_MAX;
    extern const size_t         FILE_BACKUP_SIZE_MIN;
    extern const size_t         FILE_BACKUP_SIZE_STEP;
    extern size_t               FILE_BACKUP_SIZE_VAL;
    extern const size_t         FILE_SIZE_DEF;
    extern const size_t         FILE_SIZE_MAX;
    extern const size_t         FILE_SIZE_MIN;
    extern const size_t         FILE_SIZE_STEP;
    extern size_t               FILE_SIZE_VAL;
    extern size_t               FORCE_RESTYLING;
    extern const size_t         OUTPUT_LINES_DEF;
    extern const size_t         OUTPUT_LINES_MAX;
    extern const size_t         OUTPUT_LINES_MIN;
    extern const size_t         OUTPUT_LINES_STEP;
    extern size_t               OUTPUT_LINES_VAL;
    extern const size_t         OUTPUT_LINE_LENGTH_DEF;
    extern const size_t         OUTPUT_LINE_LENGTH_MAX;
    extern const size_t         OUTPUT_LINE_LENGTH_MIN;
    extern const size_t         OUTPUT_LINE_LENGTH_STEP;
    extern size_t               OUTPUT_LINE_LENGTH_VAL;
    extern const size_t         SCROLL_DEF;
    extern const size_t         SCROLL_MAX;
    extern const size_t         SCROLL_MIN;
    extern const size_t         SCROLL_STEP;
    extern size_t               SCROLL_VAL;
    extern const size_t         STYLE_FILESIZE_DEF;
    extern const size_t         STYLE_FILESIZE_MAX;
    extern const size_t         STYLE_FILESIZE_MIN;
    extern const size_t         STYLE_FILESIZE_STEP;
    extern size_t               STYLE_FILESIZE_VAL;
    extern const size_t         WRAP_LINE_LENGTH_DEF;
    extern const size_t         WRAP_LINE_LENGTH_MAX;
    extern const size_t         WRAP_LINE_LENGTH_MIN;
    extern const size_t         WRAP_LINE_LENGTH_STEP;
    extern size_t               WRAP_LINE_LENGTH_VAL;
}
namespace strings {
    static const std::string COMMAND_MODE = "Command mode";
    constexpr const char* SOFT_TABS[]  = {
        "",
        " ",
        "  ",
        "   ",
        "    ",
        "     ",
        "      ",
        "       ",
        "        ",
        "         ",
        "          ",
        "           ",
        "            ",
        "             ",
        "              ",
    };
static const std::string FILE_FILTER = "All files (*)\t"
    "C/C++ files (*.{c,cpp,cxx,cc,h,hpp})\t"
    "Lua files (*.{lua,p8})\t"
    "Python files (*.{py})\t"
    "Ruby files (*.{rb})\t"
    "Java files (*.{java})\t"
    "Kotlin files (*.{kt})\t"
    "Go Files (*.{go})\t"
    "Rust files (*.{rs})\t"
    "C# files (*.{cs})\t"
    "JavaScript files (*.{js,jsx,json})\t"
    "TypeScript files (*.{ts,tsx})\t"
    "PHP files (*{php})\t"
    "Markup files (*{xml,html})\t"
    "Shell scripts (*{sh,bash})\t"
    "Makefiles (*{makeinclude,Makefile,makefile,GNUmakefile,make})\t"
    "Batch scripts (*{bat,cmd})";
}
namespace style {
static const int WORD_GROUP0 = 0;
static const int WORD_GROUP1 = 1;
static const int WORD_GROUP2 = 2;
static const int WORD_GROUP4 = 4;
static const int WORD_GROUP8 = 8;
enum STYLE : uint8_t {
    STYLE_FG                    = 'A',
    STYLE_BG                    = 'B',
    STYLE_BG_SEL                = 'C',
    STYLE_CUR_LINE              = 'D',
    STYLE_FG_NUM                = 'E',
    STYLE_BG_NUM                = 'F',
    STYLE_CURSOR                = 'G',
    STYLE_KEYWORD               = 'H',
    STYLE_VAR                   = 'I',
    STYLE_FUNCTION              = 'J',
    STYLE_PRAGMA                = 'K',
    STYLE_TYPE                  = 'L',
    STYLE_NUMBER                = 'M',
    STYLE_PUNCTUATOR            = 'N',
    STYLE_STRING                = 'O',
    STYLE_RAW_STRING            = 'P',
    STYLE_COMMENT               = 'Q',
    STYLE_BLOCK_COMMENT         = 'R',
    STYLE_INIT                  = 'S',
};
static constexpr const size_t STYLE_PROPS = 19;
static constexpr const size_t STYLE_LAST  = 18;
static constexpr const char* FONTS[] = {
    "Foreground",
    nullptr,
    nullptr,
    "Current line",
    "",
    nullptr,
    nullptr,
    "Keyword",
    "Var",
    "Function",
    "Pragma",
    "Type",
    "Number",
    "Punctuator",
    "String",
    "Raw string",
    "Line comment",
    "Block comment",
    nullptr,
    nullptr,
};
static constexpr const char* NAMES[] = {
    "Foreground",
    "Background",
    "Background selection",
    "Current line",
    "Foreground linenumbers",
    "Background linenumbers",
    "Cursor",
    "Keyword",
    "Var",
    "Function",
    "Pragma",
    "Type",
    "Number",
    "Punctuator",
    "String",
    "Raw string",
    "Line comment",
    "Block comment",
    "INIT",
    "SIZE",
};
static const std::string   SCHEME_BLUE     = "Blue";
static const std::string   SCHEME_DARK     = "Dark";
static const std::string   SCHEME_DEF      = "Default";
static const std::string   SCHEME_LIGHT    = "Light";
static const std::string   SCHEME_NEON     = "Neon";
static const std::string   SCHEME_TAN      = "Tan";
static const std::string   BAT             = "Batch script";
static const std::string   CPP             = "C && C++";
static const std::string   CS              = "C#";
static const std::string   GO              = "Go";
static const std::string   JAVA            = "Java";
static const std::string   JS              = "JavaScript";
static const std::string   KOTLIN          = "Kotlin";
static const std::string   LUA             = "Lua";
static const std::string   MAKEFILE        = "Makefile";
static const std::string   MARKUP          = "Markup";
static const std::string   PHP             = "PHP";
static const std::string   PYTHON          = "Python";
static const std::string   RUBY            = "Ruby";
static const std::string   RUST            = "Rust";
static const std::string   SHELL           = "Shell script";
static const std::string   TEXT            = "Text";
static const std::string   TS              = "TypeScript";
}
class Bookmarks {
public:
    explicit                    Bookmarks(Editor* editor)
                                    { _editor = editor; }
                                Bookmarks(Editor* editor, std::string bookmarks);
                                Bookmarks() = delete;
                                Bookmarks(const Bookmarks&) = delete;
                                Bookmarks(Bookmarks&& other) = delete;
    Bookmarks&                  operator=(const Bookmarks&) = delete;
    Bookmarks&                  operator=(Bookmarks&&  other)
                                    { _editor = other._editor; _vec    = other._vec; return *this; }
    bool                        add(int pos);
    void                        clear()
                                    { _vec.clear(); }
    void                        debug() const;
    int                         find_next(int pos, size_t& index);
    int                         find_prev(int pos, size_t& index);
    void                        goto_next();
    void                        goto_prev();
    size_t                      size() const
                                    { return _vec.size(); }
    void                        toggle();
    std::string                 tostring() const;
    size_t                      update(int pos, int inserted, int deleted);
private:
    Editor*                     _editor;
    fle::IntVector              _vec;
};
struct KeyConf {
    static const int            VERSION = 0;
    FKEY                        num;
    bool                        alt_d;
    bool                        alt_u;
    bool                        ctrl_d;
    bool                        ctrl_u;
    bool                        shift_d;
    bool                        shift_u;
    bool                        kommand_d;
    bool                        kommand_u;
    int                         key_d;
    int                         key_u;
    const char*                 help;
    bool                        has_custom_key() const;
    int                         to_int() const;
    std::string                 to_string() const;
    std::string                 make_help(int w) const;
    static std::string          KeyDescr(int key);
};
struct StyleProp {
    static constexpr Fl_Color   DEFAULT_BG = -1;
    Fl_Color                    color_d;
    Fl_Color                    color_u;
    Fl_Color                    bgcolor_d;
    Fl_Color                    bgcolor_u;
    unsigned                    attr_d;
    unsigned                    attr_u;
    unsigned                    bgattr_d;
    unsigned                    bgattr_u;
    bool                        bold_u;
    bool                        bold_d;
    bool                        italic_u;
    bool                        italic_d;
                                StyleProp();
                                StyleProp(Fl_Color color, unsigned attr = 0, bool bold = false, bool italic = false, Fl_Color bgcolor = StyleProp::DEFAULT_BG, unsigned bgattr = 0);
    unsigned                    attr() const
                                    { return (attr_u != attr_d) ? attr_u : attr_d; }
    unsigned                    bgattr() const
                                    { return (bgattr_u != bgattr_d) ? bgattr_u : bgattr_d; }
    Fl_Color                    bgcolor() const
                                    { return (bgcolor_u != bgcolor_d) ? bgcolor_u : bgcolor_d; }
    Fl_Color                    color() const
                                    { return (color_u != color_d) ? color_u : color_d; }
    void                        debug(int index = 0) const;
    int                         font() const;
    void                        reset();
};
struct Config {
                                Config(const Config&) = delete;
                                Config(Config&&) = delete;
    Config&                     operator=(const Config&) = delete;
    Config&                     operator=(Config&&) = delete;
    Editor*                     active;
    FBinFile                    pref_binary;
    FUndoMode                   pref_undo;
    Fl_Text_Display::Style_Table_Entry scheme[style::STYLE_PROPS];
    KeyConf                     keys[FKEY_SIZE];
    StyleProp                   blue[style::STYLE_PROPS];
    StyleProp                   dark[style::STYLE_PROPS];
    StyleProp                   def[style::STYLE_PROPS];
    StyleProp                   light[style::STYLE_PROPS];
    StyleProp                   neon[style::STYLE_PROPS];
    StyleProp                   styles[style::STYLE_PROPS];
    StyleProp                   tan[style::STYLE_PROPS];
    bool                        disable_autoreload;
    bool                        disable_lineending;
    bool                        disable_style;
    bool                        disable_tab;
    bool                        pref_autocomplete;
    bool                        pref_autoreload;
    bool                        pref_highlight;
    bool                        pref_indentation;
    bool                        pref_insert;
    bool                        pref_linenumber;
    bool                        pref_statusbar;
    bool                        pref_undo_buffer;
    gnu::file::File             pref_backup;
    int                         pref_cursor;
    int                         pref_shrink_status;
    int                         pref_tmp_fontsize;
    std::string                 pref_scheme;
    unsigned                    pref_mouse_scroll;
    unsigned                    pref_wrap;
    FTab                        tab_bat;
    FTab                        tab_cpp;
    FTab                        tab_cs;
    FTab                        tab_go;
    FTab                        tab_java;
    FTab                        tab_js;
    FTab                        tab_kotlin;
    FTab                        tab_lua;
    FTab                        tab_makefile;
    FTab                        tab_markup;
    FTab                        tab_php;
    FTab                        tab_python;
    FTab                        tab_ruby;
    FTab                        tab_rust;
    FTab                        tab_shell;
    FTab                        tab_text;
    FTab                        tab_ts;
    unsigned                    tab_bat_width;
    unsigned                    tab_cpp_width;
    unsigned                    tab_cs_width;
    unsigned                    tab_go_width;
    unsigned                    tab_java_width;
    unsigned                    tab_js_width;
    unsigned                    tab_kotlin_width;
    unsigned                    tab_lua_width;
    unsigned                    tab_makefile_width;
    unsigned                    tab_markup_width;
    unsigned                    tab_php_width;
    unsigned                    tab_python_width;
    unsigned                    tab_ruby_width;
    unsigned                    tab_rust_width;
    unsigned                    tab_shell_width;
    unsigned                    text_tab_width;
    unsigned                    tab_ts_width;
    std::vector<std::string>    find_list;
    std::vector<std::string>    replace_list;
    fle::StringSet              custom_words;
                                Config();
    bool                        add_find_word(const std::string& word, bool append = false);
    int                         add_receiver(Message* object);
    bool                        add_replace_word(const std::string& word, bool append = false);
    std::string                 create_backup_filename(const std::string& filename);
    void                        debug() const;
    bool                        has_fle_undo() const;
    void                        init_scheme(Fl_Fontsize fs = flw::PREF_FIXED_FONTSIZE);
    void                        init_scheme_to_default();
    size_t                      load_custom_wordlist(const std::string& filename);
    void                        load_pref(Fl_Preferences& pref, FindReplace* findreplace = nullptr);
    void                        remove_receiver(const Message* object);
    void                        save_pref(Fl_Preferences& pref, FindReplace* findreplace = nullptr);
    void                        send_message(const std::string& message, const std::string& s1 = "", const std::string& s2 = "", void* p = nullptr);
    StyleProp*                  style_prop(style::STYLE style);
    FTab                        tab_mode(const std::string& style_name);
    void                        tab_mode(const std::string& style_name, FTab tab);
    unsigned                    tab_width(const std::string& style_name);
    void                        tab_width(const std::string& style_name, unsigned width);
private:
    void                        _init_colors();
    void                        _init_keys();
    void                        _init_tabs();
    void                        _load_color_pref(Fl_Preferences& pref);
    void                        _load_color_pref(Fl_Preferences& pref, const std::string& name, StyleProp props[style::STYLE_PROPS]);
    void                        _load_key_pref(Fl_Preferences& pref);
    void                        _save_color_pref(Fl_Preferences& pref);
    void                        _save_color_pref(Fl_Preferences& pref, const std::string& name, const StyleProp props[style::STYLE_PROPS]);
    void                        _save_key_pref(Fl_Preferences& pref);
    int                         _id;
    bool                        _del;
    fle::MessageVector          _list;
};
struct CursorPos {
    int                         pos1;
    int                         pos2;
    int                         drag;
    int                         start;
    int                         top1;
    int                         top2;
    int                         end;
    int                         sel;
    bool                        swap;
                                CursorPos();
                                CursorPos(int pos1, int pos2, int start, int end, bool swap);
                                CursorPos(int pos1, int pos2, int drag, int start, int end, bool swap);
    bool                        operator==(const CursorPos& pos)
                                    { return pos1 == pos.pos1 && pos2 == pos.pos2; }
    bool                        operator!=(const CursorPos& pos)
                                    { return pos1 != pos.pos1 || pos2 != pos.pos2; }
    void                        clear_selection()
                                    { start = end = drag = -1; }
    void                        debug(int line = 0, const char* file = "") const;
    bool                        has_cursor() const
                                    { return pos1 >= 0 || pos2 >= 0; }
    bool                        is_empty() const
                                    { return pos1 < 0 && pos2 < 0 && top1 < 0 && top2 < 0; }
    bool                        text_has_selection() const
                                    { return start >= 0 && end > start; }
    int                         len() const
                                    { return (start >= 0 && end > start) ? end - start : 0; }
    void                        set_drag()
                                    { drag = (pos1 > start) ? start : end; }
    void                        to_default()
                                    { _convert(false); }
    void                        to_swapped()
                                    { _convert(true); }
private:
    void                        _convert(bool swapped);
};
struct EditorFlags {
    FSearchDir                  fsearchdir;
    FSplitView                  fsplitview;
    FTab                        tab_mode;
    FWrap                       fwrap;
    bool                        dnd;
    bool                        kommand;
    bool                        ro;
    unsigned                    tab_width;
    unsigned                    wrap_col;
                                EditorFlags();
    void                        debug() const;
    void                        set_tab_from_string(std::string s);
};
struct FileInfo {
    FLineEnding                 flineending;
    bool                        binary;
    gnu::file::File             fi;
    int64_t                     reload_time;
    std::string                 filename_backup_today;
                                FileInfo();
    void                        debug() const;
    std::string                 to_string() const
                                    { return gnu::str::format("%s, bin=%d, type=%d", fi.name().c_str(), binary, static_cast<int>(flineending)); }
    static std::string          TodayExt();
};
namespace help {
    std::string                 find_lines();
    std::string                 flags(const Config& config);
    std::string                 general(const Config& config);
    std::string                 pcre();
    std::string                 replace_text();
}
class Message {
public:
    enum class CTRL {
                                CONTINUE,
                                ABORT,
    };
                                Message() = delete;
                                Message(const Message&) = delete;
                                Message(Message&&) = delete;
    Message&                    operator=(const Message&) = delete;
    Message&                    operator=(Message&&) = delete;
                                Message(Config& config);
    virtual                     ~Message();
    virtual Message::CTRL       message(const std::string& message, const std::string& s1 = "", const std::string& s2 = "", void* p = nullptr) = 0;
    int                         object_id() const
                                    { return _id; }
private:
    int                         _id;
    Config&                     _config;
};
struct StatusBarInfo {
    int                         col;
    int                         end;
    int                         pos;
    int                         row;
    int                         rows;
    int                         start;
                                StatusBarInfo();
    void                        debug() const;
    bool                        has_selection() const
                                    { return start != end; }
};
namespace string {
    gnu::file::Buf              binary_to_hex(const void* in, size_t in_size, bool wide = false);
    gnu::file::Buf              binary_to_text(const void* in, size_t in_size);
    std::string                 buffer_to_hex(const void* in, size_t in_size);
    std::string                 fix_dnd_filename(std::string filename);
    std::string                 fnltab(std::string text);
    bool                        is_one_char(const char* in);
    int                         make_word_list(const char* text, fle::StringSet& words, const fle::StringSet& custom = fle::StringSet());
    std::string                 rainbow_hex(const void* in, size_t in_size);
    void                        replace_char(char* in, char find, char replace);
    int                         toints(const std::string& string, int numbers[], int size, int def = -1);
    std::string                 tolower(std::string in);
}
class Token {
public:
    enum Type : uint16_t {
                                NIL           =     0,
                                CTRL          =     1,
                                NEWLINE       =     2,
                                SPACE         =     4,
                                PUNCTUATOR    =     8,
                                DECIMAL       =    16,
                                LETTER        =    32,
                                IDENT1        =    64,
                                IDENT2        =   128,
                                HEX           =   256,
                                NUM_SEPARATOR =   512,
                                VALUE         =  1024,
                                PRAGMA        =  2048,
                                UTF1          =  4096,
                                UTF2          =  8192,
                                STRING        = 16384,
    };
                                Token();
                                Token(const Token& other);
                                Token(Token&& other);
    Token&                      operator=(const Token& other);
    Token&                      operator=(Token&& other);
    Type                        operator[](uint8_t index) const
                                    { return static_cast<Type>(_char[index]); }
    Type                        get(uint8_t index) const
                                    { return static_cast<Type>(_char[index]); }
    Type                        get_first(const char* in) const;
    Type                        get_last(const char* in, int len) const;
    Token&                      set(uint8_t index, uint16_t value);
    Token&                      set(uint8_t index_from, uint8_t index_to, uint16_t value);
    static void                 Debug(unsigned t);
    static Token                MakeWord();
private:
    uint16_t                    _char[256];
};
}
#include <cassert>
#include <FL/Fl_Text_Display.H>
namespace fle {
class Style {
public:
                                Style(const Style&) = delete;
                                Style(Style&&) = delete;
    Style&                      operator=(const Style&) = delete;
    Style&                      operator=(Style&&) = delete;
    explicit                    Style(const std::string& name = style::TEXT);
    virtual                     ~Style()
                                    { ; }
    std::string                 block_end() const
                                    { return _block_end; }
    int                         block_end_size() const
                                    { return _block_end_size; }
    std::string                 block_start() const
                                    { return _block_start; }
    int                         block_start_size() const
                                    { return _block_start_size; }
    void                        debug() const;
    bool                        insert_word(const std::string& word, int word_type);
    bool                        is_paused() const
                                    { return _pause; }
    fle::StringIntHash          keywords() const
                                    { return _lookup; }
    std::string                 line_comment() const
                                    { return _line_comment; }
    int                         line_comment_size() const
                                    { return _line_comment_size; }
    void                        make_words();
    std::string                 name() const
                                    { return _name; }
    void                        pause(bool pause)
                                    { _pause = pause; }
    void                        set_buffers(TextBuffer* text_buffer, TextBuffer* style_buffer)
                                    { _text  = text_buffer; _style = style_buffer; }
    int                         update();
    virtual int                 update(int pos, int inserted_size, int deleted_size, const char* deleted_text, const char* deleted_style, Editor* editor);
    fle::StringSet              words() const
                                    { return _words; }
    static Style*               MakeFromFile(const gnu::file::File& file);
    static Style*               MakeFromName(const std::string& name);
protected:
    static const size_t         MAX_RAW = 5;
    fle::StringIntHash          _lookup;
    fle::StringSet              _custom;
    fle::StringSet              _words;
    TextBuffer*                 _style;
    TextBuffer*                 _text;
    Token                       _tokens;
    bool                        _bin;
    bool                        _hex;
    bool                        _oct;
    bool                        _pause;
    bool                        _raw_escape[MAX_RAW];
    const char*                 _block_end;
    const char*                 _block_start;
    const char*                 _line_comment;
    const char*                 _raw_end[MAX_RAW];
    const char*                 _raw_start[MAX_RAW];
    std::string                 _name;
    unsigned                    _block_end_size;
    unsigned                    _block_start_size;
    unsigned                    _line_comment_size;
    unsigned                    _raw_end_size[MAX_RAW];
    unsigned                    _raw_start_size[MAX_RAW];
    unsigned                    _single_quote_str;
};
class StyleDef : public Style {
public:
    explicit                    StyleDef(const std::string& name);
    int                         update(int pos, int inserted_size, int deleted_size, const char* deleted_text, const char* deleted_style, Editor* editor) override;
protected:
    int                         _expand_left(int& start);
    int                         _expand_right(int& end);
    virtual int                 _update(int start, int end);
};
class StyleBat : public StyleDef {
public:
                                StyleBat();
};
class StyleCpp : public StyleDef {
public:
                                StyleCpp();
};
class StyleCS : public StyleDef {
public:
                                StyleCS();
};
class StyleGo : public StyleDef {
public:
                                StyleGo();
};
class StyleJava : public StyleDef {
public:
                                StyleJava();
};
class StyleJS : public StyleDef {
public:
                                StyleJS(const std::string& name = style::JS);
};
class StyleKotlin : public StyleDef {
public:
                                StyleKotlin();
};
class StyleLua : public StyleDef {
public:
                                StyleLua();
};
class StyleMakefile : public StyleDef {
public:
                                StyleMakefile();
};
class StyleMarkup : public StyleDef {
public:
                                StyleMarkup();
    int                         update(int pos, int inserted_size, int deleted_size, const char* deleted_text, const char* deleted_style, Editor* editor) override;
protected:
    void                        _tag(int& start, int& end, int last, bool term);
    int                         _update(int start, int end) override;
};
class StylePHP : public StyleDef {
public:
                                StylePHP();
};
class StylePython : public StyleDef {
public:
                                StylePython();
};
class StyleRuby : public StyleDef {
public:
                                StyleRuby();
};
class StyleRust : public StyleDef {
public:
                                StyleRust();
};
class StyleShell : public StyleDef {
public:
                                StyleShell();
};
class StyleTS : public StyleJS {
public:
                                StyleTS();
};
}
namespace fle {
namespace undo {
enum class EVENT : uint8_t {
                                NIL       =   0,
                                INSERT    =   1,
                                ERASED    =   2,
                                REPLACE   =   4,
                                BACKSPACE =   8,
                                SELECTED  =  16,
                                CUSTOM1   =  32,
                                CUSTOM2   =  64,
};
enum class STATUS : unsigned {
                                INIT,
                                ADDED,
                                APPENDED,
                                REMOVED,
};
class Event {
    friend class VectorStore;
public:
                                Event()
                                    { _flag = static_cast<uint8_t>(EVENT::NIL); _group = 0; _pos = 0; }
                                Event(uint8_t flag, uint16_t group, int pos, const char* str1, const char* str2 = "") : _str1(str1), _str2(str2 ? str2 : "")
                                    { _flag = flag; _group = group; _pos = pos; }
    void                        append_str1(const char* in)
                                    { _str1 += in; }
    void                        append_str2(const char* in)
                                    { _str2 += in; }
    const char*                 c_str1() const
                                    { return _str1.c_str(); }
    const char*                 c_str2() const
                                    { return _str2.c_str(); }
    void                        debug(ssize_t buffer_pos = 0, int count = 0) const;
    uint8_t                     flag() const
                                    { return _flag; }
    void                        flag(uint8_t flag)
                                    { _flag = flag; }
    uint16_t                    group() const
                                    { return _group; }
    void                        insert_str1(const char* in)
                                    { _str1 = in + _str1; }
    bool                        is_backspace() const
                                    { return _flag & static_cast<uint8_t>(EVENT::BACKSPACE); }
    bool                        is_custom1() const
                                    { return _flag & static_cast<uint8_t>(EVENT::CUSTOM1); }
    bool                        is_custom2() const
                                    { return _flag & static_cast<uint8_t>(EVENT::CUSTOM2); }
    bool                        is_delete() const
                                    { return _flag & static_cast<uint8_t>(EVENT::ERASED); }
    bool                        is_insert() const
                                    { return _flag & static_cast<uint8_t>(EVENT::INSERT); }
    bool                        is_nil() const
                                    { return _flag == static_cast<uint8_t>(EVENT::NIL); }
    bool                        is_null() const
                                    { return _str1.length() == 0; }
    bool                        is_replace() const
                                    { return _flag & static_cast<uint8_t>(EVENT::REPLACE); }
    bool                        is_selected() const
                                    { return _flag & static_cast<uint8_t>(EVENT::SELECTED); }
    int                         len1() const
                                    { return (int) _str1.length(); }
    int                         len2() const
                                    { return (int) _str2.length(); }
    int32_t                     pos() const
                                    { return _pos; }
    void                        pos(int32_t pos)
                                    { _pos = pos; }
    uint32_t                    size() const
                                    { return static_cast<uint32_t>(Event::NumberSize() + _str1.length() + 1 + _str2.length() + 1); }
    std::string                 str1() const
                                    { return _str1; }
    void                        str1(const char* in)
                                    { _str1 = in; }
    int                         str1_toint(int r[3]) const
                                    { return string::toints(_str1, r, 3); }
    std::string                 str2() const
                                    { return _str2; }
    void                        str2(const char* in)
                                    { _str2 = in; }
    int                         str2_toint(int r[3]) const
                                    { return string::toints(_str2, r, 3); }
    static inline uint32_t      NumberSize()
                                    { return static_cast<uint32_t>(sizeof(_flag) + sizeof(_group) + sizeof(_pos)); }
private:
    ssize_t                     _capacity() const;
    uint8_t                     _flag;
    uint16_t                    _group;
    int32_t                     _pos;
    std::string                 _str1;
    std::string                 _str2;
};
class Store {
    friend class Undo;
public:
                                Store(const Store&) = delete;
                                Store(Store&&) = delete;
    Store&                      operator=(const Store&) = delete;
    Store&                      operator=(Store&&) = delete;
                                Store()
                                    { ; }
    virtual                     ~Store()
                                    { ; }
    virtual ssize_t             capacity() const = 0;
    virtual void                clear() = 0;
    virtual ssize_t             cursor() const = 0;
    virtual ssize_t             debug(bool all = false) const = 0;
    virtual const Event         get_node() const = 0;
    virtual const Event         get_node(ssize_t cursor) const = 0;
    virtual bool                go_left() = 0;
    virtual bool                go_left(ssize_t& cursor) const = 0;
    virtual bool                go_right() = 0;
    virtual bool                go_right(ssize_t& cursor) const = 0;
    virtual void                go_right_before_cut() = 0;
    virtual bool                has_left() const = 0;
    virtual bool                has_right() const = 0;
    virtual void                invalidate_group_counter_at_cursor() = 0;
    virtual bool                is_cursor_at_end() const = 0;
    virtual const Event         peek_left() const = 0;
    virtual const Event         peek_right() const = 0;
    virtual void                pop() = 0;
    virtual void                set_node(const Event& node) = 0;
    virtual ssize_t             size() const = 0;
protected:
    enum class MOVE : int {
                                LEFT  = -1,
                                END   = 0,
                                RIGHT = 1,
    };
};
class BufferStore : public Store {
    friend class Undo;
public:
                                BufferStore(const BufferStore&) = delete;
                                BufferStore(BufferStore&&) = delete;
    BufferStore&                operator=(const BufferStore&) = delete;
    BufferStore&                operator=(BufferStore&&) = delete;
                                BufferStore()
                                    { _buf = nullptr; clear(); }
                                ~BufferStore()
                                    { free(_buf); }
    ssize_t                     capacity() const override
                                    { return _bcap; }
    void                        clear() override;
    ssize_t                     cursor() const override
                                    { auto left = _bcur; go_left(left); return (_move < MOVE::RIGHT) ? left : _bcur; }
    ssize_t                     debug(bool all = false) const override;
    const Event                 get_node() const override
                                    { return get_node(_bcur); }
    const Event                 get_node(ssize_t cursor) const override;
    bool                        go_left() override;
    bool                        go_left(ssize_t& cursor) const override;
    bool                        go_right() override;
    bool                        go_right(ssize_t& cursor) const override;
    void                        go_right_before_cut() override;
    bool                        has_left() const override
                                    { auto test = _bcur; go_left(test); return _move == MOVE::RIGHT || test >= 0; }
    bool                        has_right() const override
                                    { auto test = _bcur; go_right(test); return _move == MOVE::LEFT || test < _bend; }
    void                        invalidate_group_counter_at_cursor() override;
    bool                        is_cursor_at_end() const override
                                    { return _bcur == _bend; }
    const Event                 peek_left() const override;
    const Event                 peek_right() const override;
    void                        pop() override;
    void                        set_node(const Event& node) override;
    ssize_t                     size() const override
                                    { return _bcur; }
private:
    bool                        _buffer_decrease();
    bool                        _buffer_increase(ssize_t requested_bcap);
    char*                       _buf;
    MOVE                        _move;
    ssize_t                     _bcap;
    ssize_t                     _bcur;
    ssize_t                     _bend;
};
class VectorStore : public Store {
    friend class Undo;
public:
                                VectorStore(const VectorStore&) = delete;
                                VectorStore(VectorStore&&) = delete;
    VectorStore&                operator=(const VectorStore&) = delete;
    VectorStore&                operator=(VectorStore&&) = delete;
                                VectorStore()
                                    { clear(); }
    ssize_t                     capacity() const override;
    void                        clear() override;
    ssize_t                     cursor() const override
                                    { auto left = _cur; go_left(left); return (_move < MOVE::RIGHT) ? left : _cur; }
    ssize_t                     debug(bool all = false) const override;
    const Event                 get_node() const override
                                    { return get_node(_cur); }
    const Event                 get_node(ssize_t cursor) const override;
    bool                        go_left() override;
    bool                        go_left(ssize_t& cursor) const override;
    bool                        go_right() override;
    bool                        go_right(ssize_t& cursor) const override;
    void                        go_right_before_cut() override;
    bool                        has_left() const override
                                    { auto test = _cur; go_left(test); return _move == MOVE::RIGHT || test >= 0; }
    bool                        has_right() const override
                                    { auto test = _cur; go_right(test); return _move == MOVE::LEFT || test < static_cast<ssize_t>(_events.size()); }
    void                        invalidate_group_counter_at_cursor() override;
    bool                        is_cursor_at_end() const override
                                    { return _cur == static_cast<ssize_t>(_events.size()); }
    const Event                 peek_left() const override;
    const Event                 peek_right() const override;
    void                        pop() override;
    void                        set_node(const Event& node) override;
    ssize_t                     size() const override
                                    { return _cur; }
private:
    std::vector<Event>          _events;
    ssize_t                     _cur;
    MOVE                        _move;
};
class Undo {
public:
                                Undo(const Undo&) = delete;
                                Undo(Undo&&) = delete;
    Undo&                       operator=(const Undo&) = delete;
    Undo&                       operator=(Undo&&) = delete;
                                Undo(Store* store, FUndoModeFle fundoappend = FUndoModeFle::TYPE, size_t break_at = 21, double break_time = 1.0);
    virtual                     ~Undo()
                                    { delete _store; }
    [[nodiscard]] virtual STATUS add(FDelKey delkey, bool selection, int pos, const char* inserted_text, const int inserted_size, const char* deleted_text = nullptr, const int deleted_size = 0);
    void                        add_custom1(std::string str1)
                                    { auto custom = Event(static_cast<uint8_t>(EVENT::CUSTOM1), _group, -1, str1.c_str()); _push_node_to_buf(custom); }
    void                        break_append()
                                    { _break = (_fundoappend == FUndoModeFle::TYPE) ? 1 : 2; }
    ssize_t                     capacity() const
                                    { return _store->capacity(); }
    virtual void                clear();
    void                        clear_custom1()
                                    { _custom1 = Event(); }
    virtual ssize_t             debug(bool all = false);
    void                        group_add()
                                    { if (_group_lock == false) _group++; }
    void                        group_lock()
                                    { _group_lock = true; }
    void                        group_unlock()
                                    { _group_lock = false; }
    void                        group_unlock_and_add()
                                    { _group_lock = false; _group++; }
    bool                        has_redo() const
                                    { return _store->has_right(); }
    bool                        has_undo() const
                                    { return _store->has_left(); }
    bool                        is_at_save_point() const
                                    { return _save_point == _store->cursor(); }
    bool                        is_before_save_point() const
                                    { return _save_point > _store->cursor(); }
    bool                        is_group_locked() const
                                    { return _group_lock; }
    Event                       peek_redo() const
                                    { return _store->peek_right(); }
    Event                       peek_undo() const
                                    { return _store->peek_left(); }
    void                        prepare_custom1(std::string str1)
                                    { _custom1 = Event(static_cast<uint8_t>(EVENT::CUSTOM1), _group, -1, str1.c_str()); }
    void                        prepare_custom2(const char* str2)
                                    { _custom2 = str2; }
    Event                       redo()
                                    { _prev_type = Token::NIL; return (_store->go_right() == true) ? _store->get_node() : Event(); }
    void                        set_save_point();
    ssize_t                     size() const
                                    { return _store->size(); }
    Event                       undo()
                                    { _prev_type = Token::NIL; return (_store->go_left() == true) ? _store->get_node() : Event(); }
protected:
    STATUS                      _add(Event* last, uint8_t flag, int pos, const char* str1, const char* str2 = "");
    STATUS                      _append_to_node(Event* last, uint8_t flag, int pos, const char* str);
    bool                        _is_cursor_at_end() const
                                    { return _store->is_cursor_at_end(); }
    void                        _push_node_to_buf(Event node);
    Event                       _custom1;
    FUndoModeFle              _fundoappend;
    Store*                      _store;
    Token                       _tokens;
    bool                        _group_lock;
    double                      _break_time;
    double                      _time;
    int                         _break;
    size_t                      _break_at;
    ssize_t                     _save_point;
    std::string                 _custom2;
    uint16_t                    _group;
    uint16_t                    _prev_type;
    uint8_t                     _append_len;
};
}
}
#include <FL/Fl_Text_Buffer.H>
namespace fle {
class Editor;
struct CursorPos;
class BufferController {
public:
                                BufferController() = delete;
                                BufferController(const BufferController&) = delete;
                                BufferController(BufferController&&) = delete;
    BufferController&           operator=(const BufferController&) = delete;
    BufferController&           operator=(BufferController&&) = delete;
                                BufferController(TextBuffer* buffer, int timeout, bool start_group_lock);
                                ~BufferController()
                                    { stop(); }
    void                        check_timeout();
    void                        stop();
    int                         time() const
                                    { return _time; }
private:
    TextBuffer*                 _buffer;
    bool                        _running;
    bool                        _stopped;
    flw::WaitCursor*            _wc;
    int64_t                     _time;
    int64_t                     _timeout;
};
class TextBuffer : public Fl_Text_Buffer {
    friend class BufferController;
public:
    static int                  TIMEOUT_LONG;
    static int                  TIMEOUT_SHORT;
    static int                  TIMEOUT_UNDO;
                                TextBuffer(const TextBuffer&) = delete;
                                TextBuffer(TextBuffer&&) = delete;
    TextBuffer&                 operator=(const TextBuffer&) = delete;
    TextBuffer&                 operator=(TextBuffer&&) = delete;
                                TextBuffer(Editor* editor, Config& config);
                                ~TextBuffer();
    unsigned char               operator[](unsigned pos) const
                                    { return peek(pos); }
    void                        break_undo_append();
    void                        callback_connect()
                                    { add_modify_callback(TextBuffer::CallbackUndo, this); }
    void                        callback_disconnect()
                                    { remove_modify_callback(TextBuffer::CallbackUndo, this); }
    CursorPos                   case_for_selection(FCase fcase);
    std::string                 checksum() const
                                    { return _checksum; }
    std::string                 checksum_calc(const char* text = nullptr) const;
    void                        checksum_clear()
                                    { _checksum = ""; }
    std::string                 checksum_set(const char* text = nullptr)
                                    { _checksum = checksum_calc(text); return _checksum; }
    void                        clear_key()
                                    { _fdelkey = FDelKey::NIL; }
    CursorPos                   comment_block(const std::string& block_start, const std::string& block_end);
    CursorPos                   comment_line(const std::string& line_comment);
    int                         count_changes()
                                    { return _count_changes; }
    void                        count_changes(int count)
                                    { _count_changes = count; }
    bool                        cut_or_copy_line(int pos, FCopy fcopy);
    void                        debug() const;
    int                         delete_indent(int pos, FTab ftab, unsigned tab_width);
    int                         delete_text_left(int pos, FDelText del);
    int                         delete_text_right(int pos, FDelText del);
    CursorPos                   duplicate_text();
    Editor*                     editor()
                                    { return _editor; }
    size_t                      find_lines(std::string filename, std::string find, gnu::pcre8::PCRE* re, FTrim ftrim, std::vector<std::string>& out);
    CursorPos                   find_replace(std::string find, const char* replace, FSearchDir fsearchdir, FCaseCompare fcasecompare, FWordCompare fwordcompare, FNlTab fnltab);
    CursorPos                   find_replace_all(std::string find, std::string replace, FSelection fselection, FCaseCompare fcase, FWordCompare fword, FNlTab fnltab);
    CursorPos                   find_replace_regex(const std::string& find, const char* replace, FNlTab fnltab);
    CursorPos                   find_replace_regex_all(gnu::pcre8::PCRE* regex, std::string replace, FSelection fselection, FNlTab fnltab);
    gnu::file::Buf              get(FLineEnding flineending, FTrim ftrim, FChecksum fchecksum);
    std::string                 get_first(int pos) const;
    std::string                 get_indent(int pos) const;
    std::string                 get_letters_to_left(int pos) const;
    std::string                 get_line(int pos) const
                                    { return gnu::str::grab(line_text(pos)); }
    void                        get_line_range(int pos, int& start, int& end) const;
    void                        get_line_range_with_nl(int pos, int& start, int& end) const;
    std::string                 get_range(int start, int end) const;
    bool                        get_selection(int& start, int& end, bool expand);
    std::string                 get_selection_text()
                                    { return gnu::str::grab(selection_text()); }
    int                         get_word_end(int pos) const;
    int                         get_word_start(int pos) const;
    bool                        has_callback() const
                                    { return mModifyProcs != nullptr; }
    bool                        has_multiline_selection();
    bool                        has_restyle() const
                                    { return _style_text; }
    bool                        has_selection()
                                    { return _has_selection == true || selected() != 0; }
    int                         home(int pos);
    CursorPos                   indent(FIndent findent);
    CursorPos                   insert_tab(CursorPos pos, FTab ftab, unsigned tab_width);
    CursorPos                   insert_tab_multiline(CursorPos pos, FMoveH fmoveh, FTab ftab, unsigned tab_width);
    bool                        is_dirty() const
                                    { return _dirty; }
    bool                        is_word(int start, int end, int word_type);
    void                        lock_undo_tmp()
                                    { _hack_undo = 2; }
    CursorPos                   move_line(FMoveV move);
    int                         peek_token(int pos) const;
    CursorPos                   redo(FUndoRange fundocount, CursorPos cursor);
    CursorPos                   sort(FSort order);
    CursorPos                   select_color();
    CursorPos                   select_line(bool exclude_newline);
    CursorPos                   select_pair(bool move_cursor, bool& found);
    CursorPos                   select_word();
    void                        set(const char* text, FChecksum fchecksum);
    void                        set_backspace_key()
                                    { _fdelkey = FDelKey::BACKSPACE; }
    void                        set_delete_key()
                                    { _fdelkey = FDelKey::DEL; }
    void                        set_dirty(bool value, bool force_send = false);
    void                        set_save_point()
                                    { if (_undo != nullptr) { _undo->set_save_point(); _undo->break_append(); } }
    undo::Undo*                 undo()
                                    { return _undo; }
    CursorPos                   undo(FUndoRange fundocount, CursorPos cursor);
    bool                        undo_check_save_point();
    void                        undo_cursor_move_to_statusbar_row(CursorPos& cursor, const undo::Event& node, bool undo);
    bool                        undo_is_at_save_point() const;
    bool                        undo_is_before_save_point();
    FUndoMode                       undo_mode() const
                                    { return _fundo; }
    void                        undo_set_mode_using_config();
    inline bool                 compare(unsigned start, const char* string, unsigned string_len) {
                                    auto end = start + string_len - 1;
                                    if (end >= (unsigned) mLength) {
                                        return false;
                                    }
                                    while (string_len-- > 0) {
                                        auto buf = mBuf + start;
                                        if (start >= (unsigned) mGapStart) {
                                            buf += mGapEnd;
                                            buf -= mGapStart;
                                        }
                                        if (*string != *buf) {
                                            return false;
                                        }
                                        start++;
                                        string++;
                                    }
                                    return true;
                                }
    inline bool                 compare_lowercase(unsigned start, const char* string, unsigned string_len) {
                                    auto end = start + string_len - 1;
                                    if (end >= (unsigned) mLength) {
                                        return false;
                                    }
                                    while (string_len-- > 0) {
                                        auto buf = mBuf + start;
                                        if (start >= (unsigned) mGapStart) {
                                            buf += mGapEnd;
                                            buf -= mGapStart;
                                        }
                                        auto c = tolower(*buf);
                                        if (*string != c) {
                                            return false;
                                        }
                                        start++;
                                        string++;
                                    }
                                    return true;
                                }
    inline unsigned char        peek(unsigned pos) const {
                                    if (pos < (unsigned) mGapStart) {
                                        return *(mBuf + pos);
                                    }
                                    else if (pos < (unsigned) mLength) {
                                        auto buf = static_cast<const char*>(mBuf + pos);
                                        buf += mGapEnd;
                                        buf -= mGapStart;
                                        return *buf;
                                    }
                                    return 0;
                                }
    inline void                 poke(unsigned pos, char c) {
                                    if (pos < (unsigned) mGapStart) {
                                        *(mBuf + pos) = c;
                                    }
                                    else if (pos < (unsigned) mLength) {
                                        auto buf = static_cast<char*>(mBuf + pos + mGapEnd - mGapStart);
                                        *buf = c;
                                    }
                                }
    inline void                 poke(unsigned start, unsigned end, char c) {
                                    auto len = end - start;
                                    if (end > (unsigned) mLength || start > end) {
                                    }
                                    else if (end < (unsigned) mGapStart) {
                                        memset(mBuf + start, c, len);
                                    }
                                    else if (start >= (unsigned) mGapStart) {
                                        memset(mBuf + start + mGapEnd - mGapStart, c, len);
                                    }
                                    else {
                                        auto len1 = mGapStart - start;
                                        auto len2 = len - len1;
                                        memset(mBuf + start, c, len1);
                                        memset(mBuf + mGapEnd, c, len2);
                                    }
                                }
    int                         token(unsigned char c) const
                                    { return _word.get(c); }
    static void                 CallbackUndo(const int pos, const int inserted_size, const int deleted_size, const int restyled_size, const char* deleted_text, void* v);
#ifdef DEBUG
    CursorPos                   _find_replace_regex_all(gnu::pcre8::PCRE* regex, const std::string replace, int from, int to, FRegexType fregextype, FSelection fselection, bool last = false);
#endif
private:
#ifndef DEBUG
    CursorPos                   _find_replace_regex_all(gnu::pcre8::PCRE* regex, const std::string replace, int from, int to, FRegexType fregextype, FSelection fselection, bool last = false);
#endif
    int                         _token(const std::string& string) const;
    Config&                     _config;
    Editor*                     _editor;
    FDelKey                     _fdelkey;
    FUndoMode                   _fundo;
    Token                       _word;
    undo::Undo*                 _undo;
    bool                        _dirty;
    bool                        _has_selection;
    bool                        _pause_undo;
    bool                        _style_text;
    char                        _buf[256];
    int                         _count_changes;
    int                         _hack_undo;
    std::string                 _checksum;
};
}
#include <FL/Fl_Check_Button.H>
#include <FL/Fl_Int_Input.H>
namespace fle {
class Editor;
class AutoComplete : public Fl_Group {
public:
    explicit                    AutoComplete(const std::string& event);
    std::string                 event() const
                                    { return _event; }
    int                         handle(int event) override;
    int                         populate(Fl_Fontsize fontsize, const std::set<std::string>& words, const std::string& word, int word_pos);
    void                        popup(int X, int Y, int W, int H);
    std::string                 selected() const;
    std::string                 word() const
                                    { return _word; }
    int                         word_pos() const
                                    { return _word_pos; }
private:
    Fl_Hold_Browser*            _browser;
    int                         _word_pos;
    std::string                 _event;
    std::string                 _word;
};
class FindDialog : public Fl_Double_Window {
public:
    static FRegex               REGEX;
    static FTrim                TRIM;
                                FindDialog(const std::string& label, const std::vector<std::string>& find_list);
    std::string                 run();
    bool                        test_pcre();
    static void                 Callback(Fl_Widget* w, void* o);
private:
    Fl_Button*                  _cancel;
    Fl_Button*                  _help;
    Fl_Button*                  _ok;
    Fl_Button*                  _test;
    Fl_Check_Button*            _regex;
    Fl_Check_Button*            _trim;
    bool                        _ret;
    bool                        _run;
    flw::GridGroup*             _grid;
    flw::InputMenu*             _find;
};
class FindReplace : public flw::GridGroup {
public:
    explicit                    FindReplace(Config& config);
    void                        add_find_word(std::string word);
    void                        add_replace_word(std::string word);
    void                        callback(Fl_Callback* cb, void* obj);
    void                        enable_buttons();
    FCaseCompare                fcasecompare() const
                                    { return (_case->value() != 0 && _case->active() != 0) ? FCaseCompare::YES : FCaseCompare::NO; }
    void                        fcasecompare(FCaseCompare value)
                                    { _case->value((value == FCaseCompare::NO) ? 0 : 1); }
    flw::InputMenu*             find_input() const
                                    { return _find_input; }
    std::string                 find_string() const
                                    { return _find_input->value(); }
    void                        find_string(std::string value)
                                    { _find_input->value(value.c_str()); }
    FNlTab                      fnltab() const;
    void                        fnltab(FNlTab fnltab);
    FRegex                      fregex() const
                                    { return (_regex->value() != 0) ? FRegex::YES : FRegex::NO; }
    void                        fregex(FRegex value)
                                    { _regex->value((value == FRegex::NO) ? 0 : 1); }
    FSelection                  fselection() const
                                    { return (_selection->value() != 0) ? FSelection::YES : FSelection::NO; }
    void                        fselection(FSelection value)
                                    { _selection->value((value == FSelection::NO) ? 0 : 1); }
    FWordCompare                fwordcompare() const
                                    { return (_word->value() != 0 && _word->active() != 0) ? FWordCompare::YES : FWordCompare::NO; }
    void                        fwordcompare(FWordCompare value)
                                    { _word->value((value == FWordCompare::NO) ? 0 : 1); }
    int                         handle(int event) override;
    Fl_Widget*                  next_button() const
                                    { return static_cast<Fl_Widget*>(_find_next); }
    Fl_Widget*                  prev_button() const
                                    { return static_cast<Fl_Widget*>(_find_prev); }
    void                        show() override;
    Fl_Widget*                  replace_all_button() const
                                    { return static_cast<Fl_Widget*>(_replace_all); }
    Fl_Widget*                  replace_button() const
                                    { return static_cast<Fl_Widget*>(_replace); }
    flw::InputMenu*             replace_input() const
                                    { return _replace_input; }
    std::string                 replace_string() const
                                    { return _replace_input->value(); }
    void                        replace_string(std::string value)
                                    { _replace_input->value(value.c_str()); }
    void                        resize(int X, int Y, int W, int H) override;
    void                        take_focus();
    void                        update_lists(bool find, bool replace, size_t set);
    void                        update_pref();
    static void                 CallbackCheckButton(Fl_Widget* w, void* o);
    static inline int           Height()
                                    { return flw::PREF_FONTSIZE * 5.5; }
private:
    Config&                     _config;
    Fl_Button*                  _find_next;
    Fl_Button*                  _find_prev;
    Fl_Button*                  _replace;
    Fl_Button*                  _replace_all;
    Fl_Check_Button*            _case;
    Fl_Check_Button*            _find_nl;
    Fl_Check_Button*            _regex;
    Fl_Check_Button*            _replace_nl;
    Fl_Check_Button*            _selection;
    Fl_Check_Button*            _word;
    flw::InputMenu*             _find_input;
    flw::InputMenu*             _replace_input;
};
class GotoLine : public Fl_Int_Input {
public:
                                GotoLine();
    int                         handle(int event) override;
    int                         line() const;
    void                        popup(int fs, int X, int Y, int W, int H);
private:
};
class ReplaceDialog : public Fl_Double_Window {
public:
    static FCaseCompare         CASECOMPARE;
    static FNlTab               NLTAB;
    static FRegex               REGEX;
    static FSelection           SELECTION;
    static FWordCompare         WORDCOMPARE;
                                ReplaceDialog(const std::string& label, std::string& find, std::string& replace, const std::vector<std::string>& find_list, const std::vector<std::string>& replace_list);
    void                        check_buttons();
    int                         handle(int event) override;
    bool                        run();
    bool                        test_pcre();
    static void                 Callback(Fl_Widget* w, void* o);
private:
    Fl_Button*                  _cancel;
    Fl_Button*                  _help;
    Fl_Button*                  _ok;
    Fl_Button*                  _test;
    Fl_Check_Button*            _case;
    Fl_Check_Button*            _find_nl;
    Fl_Check_Button*            _regex;
    Fl_Check_Button*            _replace_nl;
    Fl_Check_Button*            _selection;
    Fl_Check_Button*            _word;
    bool                        _ret;
    bool                        _run;
    flw::GridGroup*             _grid;
    flw::InputMenu*             _find_input;
    flw::InputMenu*             _replace_input;
    std::string&                _find;
    std::string&                _replace;
};
class StatusBar : public flw::GridGroup {
public:
    explicit                    StatusBar(Config& config);
    void                        callback_line();
    void                        callback_syntax();
    void                        callback_tab();
    void                        callback_tab_def();
    int                         height() const
                                    { return _h; }
    bool                        label_cursor(std::string val);
    bool                        label_cursor_mode(std::string val);
    std::string                 label_message() const
                                    { return _label_message->label(); }
    bool                        label_message(std::string val);
    void                        update_menus(Editor* editor);
    void                        update_pref();
private:
    Config&                     _config;
    Fl_Box*                     _label_cursor;
    Fl_Box*                     _label_cursor_mode;
    Fl_Box*                     _label_message;
    Fl_Menu_Button*             _line_menu;
    Fl_Menu_Button*             _style_menu;
    Fl_Menu_Button*             _tab_menu;
    int                         _h;
};
class FindBar : public Fl_Group {
public:
    explicit                    FindBar(Config& config);
    FindReplace&                findreplace()
                                    { return *_findreplace; }
    void                        focus()
                                    { _findreplace->find_input()->input()->take_focus(); }
    int                         height() const;
    void                        hide() override;
    void                        resize(int X, int Y, int W, int H) override;
    void                        show() override;
    StatusBar&                  statusbar()
                                    { return *_statusbar; }
    void                        update_pref();
    bool                        visible() const;
private:
    Config&                     _config;
    FindReplace*                _findreplace;
    StatusBar*                  _statusbar;
};
namespace dlg {
    void                        config(Config& config);
    bool                        edit(Config& config, const std::string& title, std::string& text, const std::string& style = style::TEXT, int W = 60, int H = 40);
    void                        edit_file(Config& config, const std::string& title, const std::string& file, const std::string& style = "", int W = 60, int H = 40);
    void                        keyboard(Config& config);
    void                        scheme(Config& config);
    void                        tweaks();
    void                        view(Config& config, const std::string& title, const std::string& text, const std::string& style = style::TEXT, int W = 60, int H = 40);
    void                        view_file(Config& config, const std::string& title, const std::string& file, const std::string& style = "", int W = 60, int H = 40);
}
}
#include <FL/Fl_Text_Editor.H>
namespace fle {
class View : public Fl_Text_Editor, public Message {
public:
    explicit                    View(Config& config, Editor* editor);
                                ~View();
    void                        callback_connect();
    void                        callback_disconnect();
    void                        display_insert()
                                    { Fl_Text_Editor::display_insert(); }
    int                         drag_pos() const
                                    { return dragPos; }
    void                        drag_set_pos(int pos = 0, int type = 0)
                                    { dragPos = pos; dragType = type; }
    int                         drag_type() const
                                    { return dragType; }
    virtual void                draw() override;
    int                         handle(int event) override;
    void                        init(View* view1);
    void                        jump(bool down);
    int                         pos_to_line_and_col(int pos, int& row, int& col)
                                    { return position_to_linecol(pos, &row, &col); }
    Message::CTRL               message(const std::string& message, const std::string& s1, const std::string& s2, void* p) override;
    int                         take_focus();
    int                         top_line() const
                                    { return get_absolute_top_line_number(); }
    void                        top_set_line(int line_num)
                                    { scroll(line_num, 1); }
    bool                        update_pref(bool wrap_for_view2);
    static void                 CallbackStyleBuffer(const int pos, const int inserted_size, const int deleted_size, const int restyled_size, const char* deleted_text, void* v);
private:
    bool                        _handle_dnd();
    int                         _handle_key();
    bool                        _handle_mousewheel();
    Editor*                     _editor;
    Config&                     _config;
};
}
#include <assert.h>
#include <FL/fl_ask.H>
namespace fle {
class Editor : public Fl_Group, Message {
public:
                                Editor(Config& config, FindBar* findbar, int X = 0, int Y = 0, int W = 0, int H = 0);
                                ~Editor();
    void                        activate();
    void                        autocomplete_callback();
    void                        autocomplete_remove();
    void                        autocomplete_show();
    Bookmarks&                  bookmarks()
                                    { return _bookmarks; }
    TextBuffer&                 buffer()
                                    { return *_buf1; }
    void                        build_menu();
    void                        callback_connect()
                                    { _view1->callback_connect(); _buf1->callback_connect(); }
    void                        callback_disconnect()
                                    { _view1->callback_disconnect(); _buf1->callback_disconnect(); }
    void                        callback_output(int add_line = 0);
    Config&                     config()
                                    { return _config; }
    int                         count_lines() const;
    CursorPos                   cursor(bool set_top_line);
    int                         cursor_insert_position() const
                                    { assert(_view); return _view->insert_position(); }
    void                        cursor_move(CursorPos cursor);
    void                        cursor_move_to_pos(int pos, bool force_unselect);
    void                        cursor_move_to_rowcol(int row, int column);
    void                        cursor_move_to_statusbar_row()
                                     { cursor_move_to_rowcol(_statusbar_info.row, 1); }
    int                         cursor_pos_to_line_and_col(int pos, int& row, int& col)
                                    { assert(_view); return _view->pos_to_line_and_col(pos, row, col); }
    void                        cursor_save()
                                    { _saved_cursor = cursor(true); }
    CursorPos                   cursor_saved() const
                                    { return _saved_cursor; }
    void                        custom_callback();
    void                        custom_remove();
    void                        custom_show(const std::set<std::string>& list, const std::string& event, const std::string& word = "");
    void                        deactivate();
    void                        debug(int what = 0);
    std::string                 debug_save_style(std::string filename = "", bool add_pos = true) const;
    void                        do_layout()
                                    { _main->do_layout(); Fl::redraw(); }
    void                        file_check_reload();
    void                        file_compare_buffer();
    bool                        file_has_backup() const
                                    { auto name = filename_backup(); return gnu::file::File(name).is_file(); }
    bool                        file_has_backup_today() const
                                    { auto name = filename_backup_today(); return gnu::file::File(name).is_file(); }
    bool                        file_is_empty() const
                                    { return text_is_dirty() == false && _file_info.fi.filename() == ""; }
    FLineEnding                 file_line_ending() const
                                    { return _file_info.flineending; }
    std::string                 file_load(const std::string& filename, bool force_hex = false);
    uint64_t                    file_mtime() const
                                    { return _file_info.fi.mtime(); }
    std::string                 file_save();
    std::string                 file_save_as(const std::string& filename);
    std::string                 filename_backup(const std::string& override_current = "") const
                                    { return _config.create_backup_filename(override_current == "" ? _file_info.fi.filename() : override_current); }
    std::string                 filename_backup_today() const
                                    { return _file_info.filename_backup_today; }
    std::string                 filename_long() const
                                    { return _file_info.fi.filename(); }
    std::string                 filename_path() const
                                    { return _file_info.fi.path(); }
    std::string                 filename_short() const
                                    { return _file_info.fi.name(); }
    std::string                 filename_short_changed() const
                                    { return (text_is_dirty() == true) ? "*" + _file_info.fi.name() + "*": _file_info.fi.name(); }
    void                        filename_set_new(const std::string& filename)
                                    { _file_info.fi = gnu::file::File(filename); text_set_dirty(true); }
    size_t                      find_lines(const std::string& find, FRegex fregex, FTrim ftrim);
    size_t                      find_lines(const std::string& find, FRegex fregex, FTrim ftrim, std::vector<std::string>& out);
    void                        find_quick();
    bool                        find_replace(FSearchDir fdir, bool replace_text = false);
    size_t                      find_replace_all(std::string find, std::string replace, FNlTab fnltab, FSelection fselection,  FCaseCompare fcase, FWordCompare fword, FRegex fregex, FSaveWord fsave, FHideFind fhide, bool disable_message = false);
    FSearchDir                  find_search_dir() const
                                    { return _editor_flags.fsearchdir; }
    FindBar&                    findbar()
                                    { return *_findbar; }
    FindReplace&                findreplace()
                                    { return _findbar->findreplace(); }
    void                        goto_callback();
    void                        goto_show();
    int                         handle(int event) override;
    void                        help() const;
    bool                        home();
    size_t                      memory_usage(size_t& buffer, size_t& style, size_t& undo) const;
    Message::CTRL               message(const std::string& message, const std::string& s1, const std::string& s2, void* p) override;
    int                         redo(FUndoRange fundocount = FUndoRange::ONE);
    void                        resize(int X, int Y, int W, int H) override
                                    { Fl_Group::resize(X, Y, W, H); _main->resize(X, Y, W, H); Fl::redraw(); }
    void                        select_color();
    void                        select_pair(bool move_cursor);
    void                        show_find()
                                    { _config.send_message(message::SHOW_FIND, "", "", &_findbar->findreplace()); }
    size_t                      show_find_lines_dialog_or_run_again(FFindLines find);
    void                        show_menu();
    void                        show_output(FOutput foutput);
    void                        show_print();
    std::string                 statusbar_message() const
                                    { return _findbar->statusbar().label_message(); }
    std::string                 statusbar_set_message(std::string label)
                                    { _findbar->statusbar().label_message(label); return label; }
    Style&                      style()
                                    { return *_style; }
    void                        style(Style* style);
    TextBuffer&                 style_buffer()
                                    { return *_buf2; }
    void                        style_from_filename()
                                    { style(Style::MakeFromFile(_file_info.fi)); }
    void                        style_from_language(std::string name)
                                    { style(Style::MakeFromName(name)); }
    void                        style_resize_buffer();
    int                         take_focus()
                                    { assert(_view); return _view->take_focus(); }
    std::string                 text_checksum() const
                                    { return _buf1->checksum(); }
    void                        text_comment_block();
    void                        text_comment_line();
    void                        text_convert_case(FCase transform);
    void                        text_copy_to_clipboard() const
                                    { auto text1 = _buf1->selection_text(); Fl::copy(text1, strlen(text1), 2); free(text1); }
    int                         text_count_selection_len(bool* bytes = nullptr) const;
    void                        text_cut_to_clipboard() const
                                    { auto text1 = _buf1->selection_text(); _buf1->remove_selection(); Fl::copy(text1, strlen(text1), 2); free(text1); }
    void                        text_duplicate_line_or_selection();
    gnu::file::Buf              text_get_buffer(FLineEnding flineending, FTrim ftrim, FChecksum fchecksum) const
                                    { return _buf1->get(flineending, ftrim, fchecksum); }
    char*                       text_get_selection() const
                                    { return _buf1->selection_text(); }
    std::string                 text_get_selection_string() const
                                    { auto s = _buf1->selection_text(); std::string res = s; free(s); return res; }
    bool                        text_has_dnd_event() const
                                    { return _editor_flags.dnd; }
    bool                        text_has_kommand() const
                                    { return _editor_flags.kommand; }
    bool                        text_has_selection()
                                    { return _statusbar_info.start != _statusbar_info.end || _buf1->has_selection(); }
    void                        text_insert_from_clipboard()
                                    { assert(_view); Fl::paste(*_view, 1); }
    void                        text_insert_tab_or_move_lines_left_right(FMoveH move);
    bool                        text_is_dirty() const
                                    { return _buf1->is_dirty(); }
    bool                        text_is_readonly() const
                                    { return _editor_flags.ro; }
    int                         text_length() const
                                    { return _buf1->length(); }
    void                        text_move_lines(FMoveV move);
    int                         text_remove_trailing();
    void                        text_select_line();
    void                        text_select_word();
    void                        text_set(const char* text, FLineEnding flineending, FChecksum fchecksum);
    void                        text_set_dirty(bool value, bool force_send = false)
                                    { _buf1->set_dirty(value, force_send); }
    void                        text_set_dnd_event(bool value)
                                    {  _editor_flags.dnd = value; }
    void                        text_set_kommand(bool value)
                                    { _editor_flags.kommand = value; }
    void                        text_set_readonly(bool value);
    void                        text_sort_lines(FSort order = FSort::ASCENDING);
    FTab                        text_tab_mode() const
                                    { return _editor_flags.tab_mode; }
    void                        text_tab_mode(FTab value)
                                    { _editor_flags.tab_mode = value; }
    void                        text_tab_width(unsigned value)
                                    { if (value >= 1 && value <= limits::TAB_WIDTH_MAX) _editor_flags.tab_width = value; }
    unsigned                    text_tab_width() const
                                    { return _editor_flags.tab_width; }
    void                        text_to_space();
    void                        text_to_tab();
    int                         undo(FUndoRange fundocount = FUndoRange::ONE);
    bool                        undo_is_at_save_point() const
                                    { return _buf1->undo_is_at_save_point(); }
    bool                        undo_is_before_save_point() const
                                    { return _buf1->undo_is_before_save_point(); }
    FUndoMode                       undo_mode() const
                                    { return _buf1->undo_mode(); }
    void                        update_after_focus();
    void                        update_autocomplete(const char* text = nullptr);
    void                        update_pref();
    void                        update_statusbar();
    void                        update_textinfo();
    View&                       view()
                                    { assert(_view); return *_view; }
    View*                       view1()
                                    { return _view1; }
    View*                       view2()
                                    { return _view2; }
    void                        view_activate(int num = 1)
                                    { _view = (num == 2 && _view2 != nullptr) ? _view2 : _view1; }
    View*                       view_not_active()
                                    { return (_view == _view1) ? _view2 : _view1; }
    void                        view_reset_split_size()
                                    { _editors->split_pos(-1); }
    void                        view_set(View* view)
                                    { assert(view); _view = view; }
    void                        view_set_split(FSplitView fsplit);
    FSplitView                  view_split() const
                                    { return (_view2 == nullptr) ? FSplitView::NO : (_editors->pos() == flw::SplitGroup::Pos::VERTICAL) ? FSplitView::VERTICAL : FSplitView::HORIZONTAL; }
    unsigned                    wrap_col() const
                                    { return _editor_flags.wrap_col; }
    FWrap                       wrap_mode() const
                                    { return _editor_flags.fwrap; }
    void                        wrap_set_col(unsigned value)
                                    { _editor_flags.wrap_col = value; }
    void                        wrap_set_mode(FWrap fwrap)
                                    { _editor_flags.fwrap = fwrap; _editor_flags.wrap_col = 0; update_pref();  }
    void                        wrap_toggle_mode();
    static inline void          ShowKeyboardSetup(Config& config)
                                    { dlg::keyboard(config); }
    static inline void          ShowScheme(Config& config)
                                    { dlg::scheme(config); }
    static inline void          ShowSetup(Config& config)
                                    { dlg::config(config); }
    static inline void          ShowTweaks()
                                    { dlg::tweaks(); }
private:
    int                         _tmp_fixed_fontsize() const
                                    { return (_config.pref_tmp_fontsize > 0) ? _config.pref_tmp_fontsize : flw::PREF_FIXED_FONTSIZE; }
    static void                 CallbackAutoComplete(Fl_Widget* sender, void* o);
    static void                 CallbackCustom(Fl_Widget* sender, void* o);
    static void                 CallbackFind(Fl_Widget* sender, void* o);
    static void                 CallbackGoto(Fl_Widget* sender, void* o);
    static void                 CallbackOutput(Fl_Widget* w, void* o);
    AutoComplete*               _autocomplete;
    AutoComplete*               _custom;
    Bookmarks                   _bookmarks;
    Config&                     _config;
    CursorPos                   _saved_cursor;
    EditorFlags                 _editor_flags;
    FileInfo                    _file_info;
    FindBar*                    _findbar;
    Fl_Menu_Button*             _menu;
    GotoLine*                   _goto;
    StatusBarInfo               _statusbar_info;
    fle::StringSet              _words;
    Style*                      _style;
    TextBuffer*                 _buf1;
    TextBuffer*                 _buf2;
    View*                       _view1;
    View*                       _view2;
    View*                       _view;
    flw::ScrollBrowser*         _output;
    flw::SplitGroup*            _editors;
    flw::SplitGroup*            _main;
    gnu::pcre8::PCRE*           _regex;
    std::string                 _scheme;
};
}
#ifdef GNU_USE_SQLITE3
#include "sqlite3.h"
#include <cstring>
#include <sys/timeb.h>
#include <time.h>
#ifdef __cplusplus
extern "C" {
#endif
    void rainbow(unsigned hashsize, const void* in, const size_t in_len, uint8_t out[32], const uint64_t seed);
#ifdef __cplusplus
}
#endif
namespace gnu {
namespace db2 {
static int64_t _db_secs_since_epoch() {
#ifdef _WIN32
    struct timeb timeVal;
    ftime(&timeVal);
    return timeVal.time;
#else
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return ts.tv_sec;
#endif
}
Row::Row(const std::string& key, char* value, const size_t size, const int64_t time) {
    _key   = key;
    _size  = size;
    _time  = time;
    _value = value;
}
Row::Row(const std::string& key, const char* value, const size_t size, const int64_t time) {
    _key   = key;
    _size  = size;
    _time  = time;
    _value = nullptr;
    if (value != nullptr) {
        _value = static_cast<char*>(calloc(_size + 1, 1));
        if (_value == nullptr) {
            throw std::string("error: memory allocation failed");
        }
        memcpy(_value, value, _size);
    }
}
Row::Row(const std::string& key, const std::string& value, const int64_t time) {
    _key   = key;
    _size  = value.length();
    _time  = time;
    _value = strdup(value.c_str());
    if (_value == nullptr) {
        throw std::string("error: memory allocation failed");
    }
}
Row::Row(const Row& r) {
    _key   = r._key;
    _size  = r._size;
    _time  = r._time;
    _value = nullptr;
    if (r._value == nullptr) {
        return;
    }
    _value = static_cast<char*>(calloc(r._size + 1, 1));
    if (_value == nullptr) {
        throw std::string("error: memory allocation failed");
    }
    memcpy(_value, r._value, r._size);
}
Row::Row(Row&& r) {
    _key     = r._key;
    _size    = r._size;
    _time    = r._time;
    _value   = r._value;
    r._value = nullptr;
}
Row& Row::operator=(const Row& r) {
    if (this == &r) {
        return *this;
    }
    free(_value);
    _key   = r._key;
    _size  = r._size;
    _time  = r._time;
    _value = nullptr;
    if (r._value == nullptr) {
        return *this;
    }
    _value = static_cast<char*>(calloc(r._size + 1, 1));
    if (_value == nullptr) {
        throw std::string("error: memory allocation failed");
    }
    memcpy(_value, r._value, r._size);
    return *this;
}
Row& Row::operator=(Row&& r) {
    free(_value);
    _key     = r._key;
    _size    = r._size;
    _time    = r._time;
    _value   = r._value;
    r._value = nullptr;
    return *this;
}
void Row::debug(bool print_value) const {
    printf("Row(%s): size(%u), time(%lld), value(%s)\n", _key.c_str(), (unsigned) _size, (long long int) _time, (print_value == true) ? (_value != nullptr) ? _value : "NULL" : "not shown");
    fflush(stdout);
}
void Row::Debug(const Rows& rows, bool print_value) {
    printf("\nRow[%d]:\n", (int) rows.size());
    for (const auto& k : rows) {
        k.debug(print_value);
    }
}
DB::DB() {
    _sql  = nullptr;
    _stmt = nullptr;
    err_msg  = db2::ERROR_CLOSED;
    err_code = SQLITE_ERROR;
}
DB::DB(const std::string& filename) {
    err_code = 0;
    _sql     = nullptr;
    _stmt    = nullptr;
    open(filename);
}
DB::DB(DB&& other) {
    close();
    err_code    = other.err_code;
    err_msg     = other.err_msg;
    _filename   = other._filename;
    _sql        = other._sql;
    _stmt       = other._stmt;
    other._sql  = nullptr;
    other._stmt = nullptr;
}
DB& DB::operator=(DB&& other) {
    close();
    err_code    = other.err_code;
    err_msg     = other.err_msg;
    _filename   = other._filename;
    _sql        = other._sql;
    _stmt       = other._stmt;
    other._sql  = nullptr;
    other._stmt = nullptr;
    return *this;
}
bool DB::_clear_error_and_free_stmt() {
    _clear_error_and_free_stmt_and_return_changes();
    return true;
}
int DB::_clear_error_and_free_stmt_and_return_changes() {
    sqlite3_finalize(_stmt);
    _stmt = nullptr;
    err_msg = "";
    err_code = 0;
    return (_sql != nullptr) ? sqlite3_changes(_sql) : 0;
}
bool DB::close() {
    _filename = "";
    if (_sql == nullptr) {
        return _error_invalid_arguments();
    }
    else if (sqlite3_close(_sql) != SQLITE_OK) {
        _sql = nullptr;
        return _set_error_and_free_stmt();
    }
    else {
        _sql = nullptr;
        return _clear_error_and_free_stmt();
    }
}
int64_t DB::_count(const std::string& ns, std::string what) {
    if (_sql == nullptr) {
        _error_invalid_arguments();
        return -1;
    }
    else if (ns != "" && what == "size") {
        _prepare("SELECT SUM(LENGTH(value)) FROM kv2 WHERE ns = ?");
        sqlite3_bind_text(_stmt, 1, ns.c_str(), ns.size(), SQLITE_STATIC);
    }
    else if (ns == "" && what == "size") {
        _prepare("SELECT SUM(LENGTH(value)) FROM kv2");
    }
    else if (ns != "" && what == "rows") {
        _prepare("SELECT COUNT(rowid) FROM kv2 WHERE ns = ?");
        sqlite3_bind_text(_stmt, 1, ns.c_str(), ns.size(), SQLITE_STATIC);
    }
    else if (ns == "" && what == "rows") {
        _prepare("SELECT COUNT(rowid) FROM kv2");
    }
    if (_stmt == nullptr) {
        return -1;
    }
    else if (sqlite3_step(_stmt) != SQLITE_ROW) {
        _set_error_and_free_stmt();
        return -1;
    }
    else {
        auto res = sqlite3_column_int64(_stmt, 0);
        _clear_error_and_free_stmt();
        return res;
    }
}
bool DB::Defrag(std::string& err, const std::string& filename) {
    auto db  = DB(filename);
    auto res = false;
    if (db.is_open() == true) {
        res = db.defrag();
    }
    err = db.err_msg;
    return res;
}
bool DB::_error_invalid_arguments() {
    err_msg  = (_sql == nullptr) ? db2::ERROR_CLOSED : db2::ERROR_ARGUMENTS;
    err_code = SQLITE_ERROR;
    return false;
}
bool DB::execute(const std::string& sql) {
    if (_sql == nullptr || sql == "") {
        return _error_invalid_arguments();
    }
    else if (sqlite3_exec(_sql, sql.c_str(), nullptr, nullptr, nullptr) != SQLITE_OK) {
        return _set_error_and_free_stmt();
    }
    else {
        return _clear_error_and_free_stmt();
    }
}
Row DB::get(const std::string& ns, const std::string& key) {
    if (_sql == nullptr || ns == "" || key == "") {
        _error_invalid_arguments();
        return Row();
    }
    else if (_prepare("SELECT time, checksum, value FROM kv2 WHERE ns = ? AND key = ?") == false) {
        return Row();
    }
    else if (sqlite3_bind_text(_stmt, 1, ns.c_str(), ns.size(), SQLITE_STATIC) != SQLITE_OK) {
        _set_error_and_free_stmt();
        return Row();
    }
    else if (sqlite3_bind_text(_stmt, 2, key.c_str(), key.size(), SQLITE_STATIC) != SQLITE_OK) {
        _set_error_and_free_stmt();
        return Row();
    }
    else if (sqlite3_step(_stmt) != SQLITE_ROW) {
        _set_error_and_free_stmt();
        return Row();
    }
    else {
        auto t = sqlite3_column_int64(_stmt, 0);
        auto S = sqlite3_column_bytes(_stmt, 1);
        auto V = static_cast<const char*>(sqlite3_column_blob(_stmt, 1));
        auto s = sqlite3_column_bytes(_stmt, 2);
        auto v = static_cast<const char*>(sqlite3_column_blob(_stmt, 2));
        uint8_t out[32];
        rainbow(64, v, s, out, 0);
        if (S != 8 || memcmp(out, V, S) != 0) {
            _set_error_and_free_stmt();
            err_code = SQLITE_ERROR;
            err_msg = db2::ERROR_CHECKSUM;
            return Row();
        }
        auto r = Row(key, v, s, t);
        _clear_error_and_free_stmt();
        return r;
    }
}
Rows DB::get_keys(const std::string& ns, const std::string& wildcard, const int64_t from_time, const int64_t to_time) {
    auto res  = Rows();
    auto time = (from_time >= 0 && to_time >= 0);
    if (_sql == nullptr || ns == "") {
        _error_invalid_arguments();
        return res;
    }
    else if (wildcard == "" && time == true && (
            _prepare("SELECT key, LENGTH(value), time FROM kv2 WHERE ns = ? AND time >= ? AND time <= ? ORDER BY key") == false ||
            sqlite3_bind_text(_stmt, 1, ns.c_str(), ns.size(), SQLITE_STATIC) != SQLITE_OK ||
            sqlite3_bind_int64(_stmt, 2, from_time) != SQLITE_OK ||
            sqlite3_bind_int64(_stmt, 3, to_time) != SQLITE_OK)
        ) {
        _set_error_and_free_stmt();
        return res;
    }
    else if (wildcard == "" && time == false && (
            _prepare("SELECT key, LENGTH(value), time FROM kv2 WHERE ns = ? ORDER BY key") == false ||
            sqlite3_bind_text(_stmt, 1, ns.c_str(), ns.size(), SQLITE_STATIC) != SQLITE_OK)
        ) {
        _set_error_and_free_stmt();
        return res;
    }
    else if (wildcard != "" && time == true && (
            _prepare("SELECT key, LENGTH(value), time FROM kv2 WHERE ns = ? AND key LIKE ? AND time >= ? AND time <= ? ORDER BY key") == false ||
            sqlite3_bind_text(_stmt, 1, ns.c_str(), ns.size(), SQLITE_STATIC) != SQLITE_OK ||
            sqlite3_bind_text(_stmt, 2, wildcard.c_str(), wildcard.size(), SQLITE_STATIC) != SQLITE_OK ||
            sqlite3_bind_int64(_stmt, 3, from_time) != SQLITE_OK ||
            sqlite3_bind_int64(_stmt, 4, to_time) != SQLITE_OK)
        ) {
        _set_error_and_free_stmt();
        return res;
    }
    else if (wildcard != "" && time == false && (
            _prepare("SELECT key, LENGTH(value), time FROM kv2 WHERE ns = ? AND key LIKE ? ORDER BY key") == false ||
            sqlite3_bind_text(_stmt, 1, ns.c_str(), ns.size(), SQLITE_STATIC) != SQLITE_OK ||
            sqlite3_bind_text(_stmt, 2, wildcard.c_str(), wildcard.size(), SQLITE_STATIC) != SQLITE_OK)
        ) {
        _set_error_and_free_stmt();
        return res;
    }
    else {
        while (sqlite3_step(_stmt) == SQLITE_ROW) {
            auto k = (std::string) reinterpret_cast<const char*>(sqlite3_column_text(_stmt, 0));
            auto s = sqlite3_column_int64(_stmt, 1);
            auto t = sqlite3_column_int64(_stmt, 2);
            res.push_back(Row(k, (const char*) nullptr, (size_t) s, t));
        }
        _clear_error_and_free_stmt();
        return res;
    }
}
Rows DB::get_rows(const std::string& ns, const std::string& wildcard, const int64_t from_time, const int64_t to_time) {
    auto res  = Rows();
    auto time = (from_time >= 0 && to_time >= 0);
    if (_sql == nullptr || ns == "") {
        _error_invalid_arguments();
        return res;
    }
    else if (wildcard == "" && time == true && (
            _prepare("SELECT key, time, checksum, value FROM kv2 WHERE ns = ? AND time >= ? AND time <= ? ORDER BY key") == false ||
            sqlite3_bind_text(_stmt, 1, ns.c_str(), ns.size(), SQLITE_STATIC) != SQLITE_OK ||
            sqlite3_bind_int64(_stmt, 2, from_time) != SQLITE_OK ||
            sqlite3_bind_int64(_stmt, 3, to_time) != SQLITE_OK)
        ) {
        _set_error_and_free_stmt();
        return res;
    }
    else if (wildcard == "" && time == false && (
            _prepare("SELECT key, time, checksum, value FROM kv2 WHERE ns = ? ORDER BY key") == false ||
            sqlite3_bind_text(_stmt, 1, ns.c_str(), ns.size(), SQLITE_STATIC) != SQLITE_OK)
    ) {
        return res;
    }
    else if (wildcard != "" && time == true && (
            _prepare("SELECT key, time, checksum, value FROM kv2 WHERE ns = ? AND key LIKE ? AND time >= ? AND time <= ? ORDER BY key") == false ||
            sqlite3_bind_text(_stmt, 1, ns.c_str(), ns.size(), SQLITE_STATIC) != SQLITE_OK ||
            sqlite3_bind_text(_stmt, 2, wildcard.c_str(), wildcard.size(), SQLITE_STATIC) != SQLITE_OK ||
            sqlite3_bind_int64(_stmt, 3, from_time) != SQLITE_OK ||
            sqlite3_bind_int64(_stmt, 4, to_time) != SQLITE_OK)
        ) {
        _set_error_and_free_stmt();
        return res;
    }
    else if (wildcard != "" && time == false && (
            _prepare("SELECT key, time, checksum, value FROM kv2 WHERE ns = ? AND key LIKE ? ORDER BY key") == false ||
            sqlite3_bind_text(_stmt, 1, ns.c_str(), ns.size(), SQLITE_STATIC) != SQLITE_OK ||
            sqlite3_bind_text(_stmt, 2, wildcard.c_str(), wildcard.size(), SQLITE_STATIC) != SQLITE_OK)
        ) {
        _set_error_and_free_stmt();
        return res;
    }
    else {
        while (sqlite3_step(_stmt) == SQLITE_ROW) {
            auto k = (std::string) reinterpret_cast<const char*>(sqlite3_column_text(_stmt, 0));
            auto t = sqlite3_column_int64(_stmt, 1);
            auto S = sqlite3_column_bytes(_stmt, 2);
            auto V = static_cast<const char*>(sqlite3_column_blob(_stmt, 2));
            auto s = sqlite3_column_bytes(_stmt, 3);
            auto v = static_cast<const char*>(sqlite3_column_blob(_stmt, 3));
            uint8_t out[32];
            rainbow(64, v, s, out, 0);
            if (S != 8 || memcmp(out, V, S) != 0) {
                _set_error_and_free_stmt();
                err_code = SQLITE_ERROR;
                err_msg = db2::ERROR_CHECKSUM;
                return Rows();
            }
            else {
                res.push_back(Row(k, v, s, t));
            }
        }
        if (res.size() == 0) {
            _set_error_and_free_stmt();
            return res;
        }
        else {
            _clear_error_and_free_stmt();
            return res;
        }
    }
}
bool DB::has_key(const std::string& ns, const std::string& key) {
    if (_sql == nullptr || ns == "" || key == "") {
        _error_invalid_arguments();
        return false;
    }
    else if (_prepare("SELECT time FROM kv2 WHERE ns = ? AND key = ?") == false) {
        return false;
    }
    else if (sqlite3_bind_text(_stmt, 1, ns.c_str(), ns.size(), SQLITE_STATIC) != SQLITE_OK ||
        sqlite3_bind_text(_stmt, 2, key.c_str(), key.size(), SQLITE_STATIC) != SQLITE_OK) {
        _set_error_and_free_stmt();
        return false;
    }
    else if (sqlite3_step(_stmt) != SQLITE_ROW) {
        _set_error_and_free_stmt();
        return false;
    }
    else {
        _clear_error_and_free_stmt();
        return true;
    }
}
Row DB::Load(std::string& err, const std::string& filename, const std::string& key, LOAD load) {
    auto res = Row();
    auto db  = DB(filename);
    if (db.is_open() == true) {
        if (load == LOAD::BACKUP) {
            res = db.get("backup", key);
        }
        else {
            res = db.get("files", key);
        }
    }
    err = db.err_msg;
    if (err == db2::ERROR_CHECKSUM && res.c_str() == nullptr && load == LOAD::BACKUP_ON_ERROR) {
        res = db.get("backup", key);
    }
    return res;
}
Rows DB::LoadRows(std::string& err, const std::string& filename, const std::string& wildcard) {
    auto res = Rows();
    auto db  = DB(filename);
    if (db.is_open() == true) {
        res = db.get_rows("files", wildcard);
    }
    err = db.err_msg;
    return res;
}
bool DB::open(const std::string& filename) {
    close();
    if (filename == "") {
        err_msg  = db2::ERROR_FILENAME;
        err_code = SQLITE_ERROR;
        return false;
    }
    if (sqlite3_open(filename.c_str(), &_sql) != SQLITE_OK) {
        return _set_error_and_close_db();
    }
    if (execute("CREATE TABLE IF NOT EXISTS kv2(ns TEXT, key TEXT, time INTEGER NOT NULL, checksum BLOB NOT NULL, value BLOB NOT NULL, PRIMARY KEY(ns, key))") == false) {
        return _set_error_and_close_db();
    }
    if (execute("CREATE INDEX IF NOT EXISTS kv2_time ON kv2(time)") == false) {
        return _set_error_and_close_db();
    }
    execute("PRAGMA synchronous = normal");
    execute("PRAGMA temp_store = memory");
    execute("PRAGMA case_sensitive_like = ON");
    _filename = filename;
    return _clear_error_and_free_stmt();
}
bool DB::_prepare(const char* sql) {
    if (sqlite3_prepare_v2(_sql, sql, -1, &_stmt, 0) != SQLITE_OK) {
        _set_error_and_free_stmt();
        return false;
    }
    return true;
}
bool DB::put(const std::string& ns, const std::string& key, const char* in, size_t in_size, int64_t time) {
    if (_sql == nullptr || ns == "" || key == "" || in == nullptr) {
        return _error_invalid_arguments();
    }
    uint8_t out[32];
    rainbow(64, in, in_size, out, 0);
    if (time < 0) {
        time = _db_secs_since_epoch();
    }
    if (_prepare("REPLACE INTO kv2(ns, key, time, checksum, value) VALUES(?, ?, ?, ?, ?)") == false) {
        return false;
    }
    else if (sqlite3_bind_text(_stmt, 1, ns.c_str(), ns.size(), SQLITE_STATIC) != SQLITE_OK) {
        return _set_error_and_free_stmt();
    }
    else if (sqlite3_bind_text(_stmt, 2, key.c_str(), key.size(), SQLITE_STATIC) != SQLITE_OK) {
        return _set_error_and_free_stmt();
    }
    else if (sqlite3_bind_int64(_stmt, 3, time) != SQLITE_OK) {
        return _set_error_and_free_stmt();
    }
    else if (sqlite3_bind_blob(_stmt, 4, out, 8, SQLITE_STATIC) != SQLITE_OK) {
        return _set_error_and_free_stmt();
    }
    else if (sqlite3_bind_blob(_stmt, 5, in, in_size, SQLITE_STATIC) != SQLITE_OK) {
        return _set_error_and_free_stmt();
    }
    else if (sqlite3_step(_stmt) != SQLITE_DONE) {
        return _set_error_and_free_stmt();
    }
    else {
        return _clear_error_and_free_stmt();
    }
}
int DB::remove(const std::string& ns, const std::string& key, bool wildcard) {
    if (_sql == nullptr || ns == "" || key == "") {
        return _error_invalid_arguments();
    }
    else if (wildcard == false && _prepare("DELETE FROM kv2 WHERE ns = ? AND key = ?") == false) {
        return 0;
    }
    else if (wildcard == true && _prepare("DELETE FROM kv2 WHERE ns = ? AND key LIKE ?") == false) {
        return 0;
    }
    else if (sqlite3_bind_text(_stmt, 1, ns.c_str(), ns.size(), SQLITE_STATIC) != SQLITE_OK) {
        return _set_error_and_free_stmt();
    }
    else if (sqlite3_bind_text(_stmt, 2, key.c_str(), key.size(), SQLITE_STATIC) != SQLITE_OK) {
        return _set_error_and_free_stmt();
    }
    else if (sqlite3_step(_stmt) != SQLITE_DONE) {
        return _set_error_and_free_stmt();
    }
    else {
        return _clear_error_and_free_stmt_and_return_changes();
    }
}
bool DB::rename(const std::string& ns, const std::string& key, const std::string& new_key) {
    if (_sql == nullptr || ns == "" || key == "" || new_key == "" || key == new_key) {
        return _error_invalid_arguments();
    }
    else if (_prepare("UPDATE kv2 SET key = ? WHERE ns = ? AND key = ?") == false) {
        return false;
    }
    else if (sqlite3_bind_text(_stmt, 1, new_key.c_str(), new_key.size(), SQLITE_STATIC) != SQLITE_OK) {
        return _set_error_and_free_stmt();
    }
    else if (sqlite3_bind_text(_stmt, 2, ns.c_str(), ns.size(), SQLITE_STATIC) != SQLITE_OK) {
        return _set_error_and_free_stmt();
    }
    else if (sqlite3_bind_text(_stmt, 3, key.c_str(), key.size(), SQLITE_STATIC) != SQLITE_OK) {
        return _set_error_and_free_stmt();
    }
    else if (sqlite3_step(_stmt) != SQLITE_DONE) {
        return _set_error_and_free_stmt();
    }
    else {
        return _clear_error_and_free_stmt_and_return_changes();
    }
}
bool DB::Save(std::string& err, const std::string& filename, const Row& row, bool backup) {
    return DB::Save(err, filename, row.key(), row.c_str(), row.size(), row.time(), backup);
}
bool DB::Save(std::string& err, const std::string& filename, const std::string& key, const char* value, const size_t size, const int64_t time, bool backup) {
    auto db  = DB(filename);
    auto res = false;
    if (db.is_open() == true) {
        if (backup == true) {
            auto old = db.get("files", key);
            if (old.c_str() != nullptr) {
                db.put("backup", old);
            }
        }
        res = db.put("files", key, value, size, time);
    }
    err = db.err_msg;
    return res;
}
bool DB::SaveRows(std::string& err, const std::string& filename, const Rows& rows, bool backup) {
    auto db    = DB(filename);
    auto count = (size_t) 0;
    err = "";
    if (db.is_open() == false) {
        err = db.err_msg;
        return false;
    }
    db.begin();
    for (auto& r : rows) {
        if (backup == true) {
            auto old = db.get("files", r.key());
            if (old.c_str() != nullptr) {
                db.put("backup", old);
            }
        }
        count += db.put("files", r);
        if (err != "") {
            err = db.err_msg;
        }
    }
    if (count != rows.size() || err != "") {
        db.rollback();
        return false;
    }
    else {
        auto res = db.commit();
        err = db.err_msg;
        return res;
    }
}
bool DB::_set_error_and_close_db() {
    if (_sql == nullptr) {
        err_msg  = db2::ERROR_OPEN;
        err_code = SQLITE_ERROR;
    }
    else {
        _set_error_and_free_stmt();
        sqlite3_close(_sql);
        _sql = nullptr;
    }
    return false;
}
bool DB::_set_error_and_free_stmt() {
    if (_sql != nullptr) {
        err_msg  = sqlite3_errmsg(_sql);
        err_code = sqlite3_errcode(_sql);
    }
    else {
        err_msg  = db2::ERROR_CLOSED;
        err_code = SQLITE_ERROR;
    }
    sqlite3_finalize(_stmt);
    _stmt = nullptr;
    return false;
}
std::string DB::Version() {
    return SQLITE_VERSION;
}
}
}
#endif
#include <cstring>
#include <assert.h>
namespace gnu {
namespace pile {
static const char               _KEY_SEP  = '#';
static const char               _DATA_SEP = '=';
static const char               _STRING   = '^';
static const char               _ESCAPED  = '!';
static bool                     _check_escape(const std::string& string);
static bool                     _check_key(const std::string& key);
static std::string              _escape(const std::string& str);
static Buf                      _from_hex(const char* value, size_t len);
static std::vector<std::string> _split(const char* string, char split);
static std::string              _to_hex(const char* value, size_t len, bool break_at_80);
static std::string              _unescape(const std::string& str);
static int8_t _FROM_HEX[256] = {
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1, -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 };
static const char _TO_HEX[513] =
    "000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f"
    "404142434445464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f606162636465666768696a6b6c6d6e6f707172737475767778797a7b7c7d7e7f"
    "808182838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9fa0a1a2a3a4a5a6a7a8a9aaabacadaeafb0b1b2b3b4b5b6b7b8b9babbbcbdbebf"
    "c0c1c2c3c4c5c6c7c8c9cacbcccdcecfd0d1d2d3d4d5d6d7d8d9dadbdcdddedfe0e1e2e3e4e5e6e7e8e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfeff";
}
static bool pile::_check_escape(const std::string& string) {
    if (string == "") {
        return false;
    }
    for (unsigned char c : string) {
        if (c >= 10 && c <= 13) return true;
    }
    return false;
}
static bool pile::_check_key(const std::string& key) {
    if (key == "") {
        return false;
    }
    for (unsigned char c : key) {
        if (c >= 'a' && c <= 'z') {
        }
        else if (c >= 'A' && c <= 'Z') {
        }
        else if (c >= '0' && c <= '9') {
        }
        else if (c == '_' || c == '-') {
        }
        else {
            return false;
        }
    }
    return true;
}
static std::string pile::_escape(const std::string& str) {
    std::string res;
    try {
        for (unsigned c : str) {
            if (c == 10) {
                res += "\\n";
            }
            else if (c == 11) {
                res += "\\v";
            }
            else if (c == 12) {
                res += "\\f";
            }
            else if (c == 13) {
                res += "\\r";
            }
            else {
                res += c;
            }
        }
    }
    catch (...) {
        res = "";
    }
    return res;
}
static pile::Buf pile::_from_hex(const char* value, size_t len) {
    if (value == nullptr || len == 0 || len % 2 != 0) {
        return Buf();
    }
    auto   buf = Buf(len / 2);
    size_t pos = 0;
    for (size_t f = 0; f < len; f += 2) {
        int8_t c1 = pile::_FROM_HEX[(uint8_t) value[f]];
        int8_t c2 = pile::_FROM_HEX[(uint8_t) value[f + 1]];
        if (c1 < 0 || c2 < 0) {
            return Buf();
        }
        buf.set(c1 * 16 + c2, pos++);
    }
    return buf;
}
static std::vector<std::string> pile::_split(const char* string, char split) {
    auto res = std::vector<std::string>();
    try {
        auto found = strchr(string, split);
        while (found != nullptr) {
            *((char*) found) = 0;
            res.push_back(string);
            *((char*) found) = split;
            string = found + 1;
            found = strchr(string, split);
        }
        res.push_back(string);
    }
    catch (...) {
        res.clear();
    }
    return res;
}
static std::string pile::_to_hex(const char* buffer, size_t buffer_len, bool break_at_80) {
    if (buffer == nullptr || buffer_len == 0) {
        return "";
    }
    std::string res;
    try {
        res.reserve(buffer_len * 3);
        for (size_t f = 0; f < buffer_len; f++) {
            uint8_t b = buffer[f];
            int     c = b * 2;
            res += pile::_TO_HEX[c++];
            res += pile::_TO_HEX[c];
            if (break_at_80 == true && f > 0 && f < buffer_len - 1 && f % 40 == 0) {
                res += "+\n";
            }
        }
    }
    catch (...) {
        res = "";
    }
    return res;
}
static std::string pile::_unescape(const std::string& str) {
    std::string res;
    try {
        for (size_t f = 1; f < str.length(); f++) {
            char c = str[f];
            char n = str[f + 1];
            char u = 0;
            if (c == '\\') {
                if (n == 'n') {
                    u = '\n';
                }
                else if (n == 'v') {
                    u = '\v';
                }
                else if (n == 'f') {
                    u = '\f';
                }
                else if (n == 'r') {
                    u = '\r';
                }
            }
            if (u != 0) {
                res += u;
                f++;
            }
            else {
                res += c;
            }
        }
    }
    catch (...) {
        res = "";
    }
    return res;
}
std::string pile::make_key(unsigned key, uint8_t width) {
    char b[50];
    snprintf(b, 50, "%0*u", width, key);
    return b;
}
pile::Buf::Buf(size_t s) {
    _p = (s < SIZE_MAX) ? static_cast<char*>(calloc(s + 1, 1)) : nullptr;
    if (_p == nullptr) {
        throw "error: memory allocation failed";
    }
    _s = s;
}
pile::Buf::Buf(const char* p, size_t s) {
    _p = nullptr;
    _s = 0;
    if (p == nullptr) {
        return;
    }
    _p = (s < SIZE_MAX) ? static_cast<char*>(calloc(s + 1, 1)) : nullptr;
    if (_p == nullptr) {
        throw "error: memory allocation failed";
    }
    memcpy(_p, p, s);
    _s = s;
}
pile::Buf::Buf(const Buf& b) {
    _p = nullptr;
    _s = 0;
    if (b._p == nullptr) {
        return;
    }
    _p = (b._s < SIZE_MAX) ? static_cast<char*>(calloc(b._s + 1, 1)) : nullptr;
    if (_p == nullptr) {
        throw "error: memory allocation failed";
    }
    memcpy(_p, b._p, b._s);
    _s = b._s;
}
pile::Buf& pile::Buf::operator=(const Buf& b) {
    if (this == &b) {
        return *this;
    }
    else if (b._p == nullptr) {
        free(_p);
        _p = nullptr;
        _s = 0;
        return *this;
    }
    free(_p);
    _p = (b._s < SIZE_MAX) ? static_cast<char*>(calloc(b._s + 1, 1)) : nullptr;
    _s = 0;
    if (_p == nullptr) {
        throw "error: memory allocation failed";
    }
    memcpy(_p, b._p, b._s);
    _s = b._s;
    return *this;
}
pile::Buf& pile::Buf::operator+=(const Buf& b) {
    if (b._p == nullptr) {
        return *this;
    }
    if (_p == nullptr) {
        *this = b;
        return *this;
    }
    auto t = (b._s < SIZE_MAX) ? static_cast<char*>(calloc(_s + b._s + 1, 1)) : nullptr;
    if (t == nullptr) {
        throw "error: memory allocation failed";
    }
    memcpy(t, _p, _s);
    memcpy(t + _s, b._p, b._s);
    free(_p);
    _p = t;
    _s += b._s;
    return *this;
}
bool pile::Buf::operator==(const Buf& b) const {
    return _p != nullptr && _s == b._s && memcmp(_p, b._p, _s) == 0;
}
void pile::Pile::debug() const {
    int c = 1;
    printf("gnu::pile::Pile() => %u rows\n", (unsigned) _values.size());
    for (auto& v : _values) {
        if (v.second.length() > 140) {
            printf("%5d: %-20s| %s ...\n", c++, v.first.c_str(), v.second.substr(0, 140).c_str());
        }
        else {
            printf("%5d: %-20s| %s\n", c++, v.first.c_str(), v.second.c_str());
        }
    }
    fflush(stdout);
}
std::string pile::Pile::export_data() const {
    size_t s = 0;
    for (auto& v : _values) {
        s += v.first.length() + v.second.length() + 2;
    }
    auto res = std::string();
    res.reserve(s + 5);
    for (const auto& m : _values) {
        res += m.first + pile::_DATA_SEP + m.second + "\n";
    }
    return res;
}
pile::Buf pile::Pile::get_buf(const std::string& section, const std::string& key) const {
    if (pile::_check_key(section) == false || pile::_check_key(key) == false) {
        return Buf();
    }
    auto v = _values.find(section + pile::_KEY_SEP + key);
    if (v == _values.end() || v->second.length() == 0 || v->second.front() == pile::_STRING || v->second.front() == pile::_ESCAPED) {
        return Buf();
    }
    return pile::_from_hex(v->second.c_str(), v->second.length());
}
double pile::Pile::get_double(const std::string& section, const std::string& key, double def) const {
    std::string n = get_string(section, key, "");
    try {
        return std::stod(n);
    }
    catch (...) {
        return def;
    }
}
int64_t pile::Pile::get_int(const std::string& section, const std::string& key, int64_t def) const {
    std::string n = get_string(section, key, "");
    try {
        return std::stoll(n);
    }
    catch (...) {
        return def;
    }
}
std::string pile::Pile::get_string(const std::string& section, const std::string& key, const std::string& def) const {
    if (pile::_check_key(section) == false || pile::_check_key(key) == false) {
        return def;
    }
    auto v = _values.find(section + pile::_KEY_SEP + key);
    if (v == _values.end() || v->second.length() == 0 || (v->second.front() != pile::_STRING && v->second.front() != pile::_ESCAPED)) {
        return def;
    }
    else if (v->second.front() == pile::_ESCAPED) {
        return pile::_unescape(v->second);
    }
    else {
        return v->second.substr(1);
    }
}
size_t pile::Pile::import_data(const char* values) {
    clear();
    if (values == nullptr || *values == 0) {
        return 0;
    }
    auto lines = pile::_split(values, '\n');
    for (auto& line : lines) {
        auto l  = const_cast<char*>(line.c_str());
        auto ik = static_cast<char*>(strchr(l, pile::_KEY_SEP));
        auto iv = static_cast<char*>(strchr(l, pile::_DATA_SEP));
        if (iv != nullptr && ik != nullptr) {
            auto section = l;
            auto key     = ik + 1;
            auto value   = iv + 1;
            *ik = 0;
            *iv = 0;
            if (pile::_check_key(section) == true && pile::_check_key(key) == true) {
                *ik        = pile::_KEY_SEP;
                _values[l] = value;
            }
        }
    }
    return _values.size();
}
std::vector<std::string> pile::Pile::keys(const std::string& section) const {
    auto res = std::vector<std::string>();
    if (section == "") {
        for (auto& m : _values) {
            res.push_back(m.first);
        }
    }
    else {
        auto name = std::string(section) + pile::_KEY_SEP;
        auto stop = false;
        for (auto& m : _values) {
            if (m.first.find(name) == 0) {
                res.push_back(m.first.substr(name.length()));
                stop = true;
            }
            else if (stop == true) {
                return res;
            }
        }
    }
    return res;
}
std::vector<std::string> pile::Pile::sections() const {
    std::vector<std::string> res;
    std::string              section;
    for (const auto& m : _values) {
        auto s = m.first;
        auto p = s.find(pile::_KEY_SEP);
        if (p != std::string::npos) {
            s = s.substr(0, p);
            if (s != section) {
                res.push_back(s);
            }
            section = s;
        }
    }
    return res;
}
bool pile::Pile::set(const std::string& section, const std::string& key, const char* buffer, size_t buffer_len) {
    if (pile::_check_key(section) == false || pile::_check_key(key) == false) {
        return false;
    }
    _values[section + pile::_KEY_SEP + key] = pile::_to_hex(buffer, buffer_len, false);
    return true;
}
bool pile::Pile::set_string(const std::string& section, const std::string& key, const std::string& string) {
    if (pile::_check_key(section) == false || pile::_check_key(key) == false) {
        return false;
    }
    if (pile::_check_escape(string) == true) {
        _values[section + pile::_KEY_SEP + key] = pile::_ESCAPED + pile::_escape(string);
    }
    else {
        _values[section + pile::_KEY_SEP + key] = pile::_STRING + string;
    }
    return true;
}
}
#ifdef GNU_USE_PCRE
#include "pcre8.h"
#include <cstdarg>
namespace gnu {
namespace pcre8 {
std::string escape(const std::string& string) {
    auto res = string;
    res = pcre8::replace_all(res, "\\", "\\\\");
    res = pcre8::replace_all(res, "$", "\\$");
    res = pcre8::replace_all(res, "(", "\\(");
    res = pcre8::replace_all(res, ")", "\\)");
    res = pcre8::replace_all(res, "*", "\\*");
    res = pcre8::replace_all(res, "+", "\\+");
    res = pcre8::replace_all(res, "-", "\\-");
    res = pcre8::replace_all(res, ".", "\\.");
    res = pcre8::replace_all(res, "?", "\\?");
    res = pcre8::replace_all(res, "[", "\\[");
    res = pcre8::replace_all(res, "]", "\\]");
    res = pcre8::replace_all(res, "^", "\\^");
    res = pcre8::replace_all(res, "{", "\\{");
    res = pcre8::replace_all(res, "|", "\\|");
    res = pcre8::replace_all(res, "}", "\\}");
    return string;
}
std::string format512(const char* format, ...) {
    char buf[512];
    va_list args;
    va_start(args, format);
    auto n = vsnprintf(buf, 512, format, args);
    va_end(args);
    return (n < 0 || n >= 512) ? "Error: to long error message...!" : buf;
}
std::string replace_all(const std::string& string, const std::string& find, const std::string& replace) {
    if (find == "") {
        return string;
    }
    try {
        auto res   = std::string();
        auto start = (size_t) 0;
        auto pos   = (size_t) 0;
        while ((pos = string.find(find, start)) != std::string::npos) {
            res   += string.substr(start, pos - start);
            res   += replace;
            pos   += find.length();
            start  = pos;
        }
        res += string.substr(start);
        return res;
    }
    catch(...) {
        return string;
    }
}
std::vector<std::string> split(const std::string& string, const std::string& separator) {
    auto res  = std::vector<std::string>();
    auto prev = (std::string::size_type) 0;
    auto pos  = (std::string::size_type) 0;
    while((pos = string.find(separator, pos)) != std::string::npos) {
        auto substring = string.substr(prev, pos - prev);
        res.push_back(substring);
        prev = ++pos;
    }
    res.push_back(string.substr(prev, pos - prev));
    return res;
}
std::string version() {
    return pcre8::format512("%d.%d", PCRE_MAJOR, PCRE_MINOR);
}
void Match::debug() const {
    printf("start=%d, count=%d, end=%d, name=<%s>, word=<%s>\n", _start, _count, end(), _name.c_str(), _word.c_str());
    fflush(stdout);
}
Match Match::Find(const MatchVector& matches, const std::string& name) {
    for (auto& match : matches) {
        if (match.name() == name) {
            return match;
        }
    }
    return Match();
}
void Match::print(int i) const {
    printf("%3d:  %5d  %5d  %5d  %10s = <%s>\n", i, _start, _count, end(), _name.c_str(), _word.c_str());
}
void Match::Print(const MatchVector& matches, bool header, int capture) {
    int c = 0;
    if (header == true) {
        puts("");
        printf("---------------------------------------\n");
        printf("%3s:  %s  %s  %s  %s %s\n", "NUM", "START", "COUNT", "  END", "      NAME =", "<WORD>");
        printf("--------------------------------------- %d\n", capture);
    }
    else {
        printf("--------------------------------------- %d\n", capture);
    }
    for (auto& match : matches) {
        match.print(c++);
    }
    fflush(stdout);
}
void Match::Print(const MatchCaptures& captures) {
    int c = 1;
    for (auto& capture : captures) {
        Match::Print(capture, c == 1, c);
        c++;
    }
}
bool Match::replace(std::string& subject) const {
    if (start() >= static_cast<int>(subject.length())) {
        return false;
    }
    try {
        subject.replace(start(), count(), word());
        return true;
    }
    catch(...) {
        return false;
    }
}
std::string Match::ReplaceDollar(const MatchVector& matches, const std::string& replace) {
    if (matches.size() == 0 || replace == "") {
        return "";
    }
    auto dollars  = pcre8::split(replace, "$");
    auto matches2 = matches;
    auto count    = (size_t) 0;
    auto prepend  = (dollars.size() > 0) ? dollars[0] : "";
    auto res      = std::string();
    for (auto& dollar : dollars) {
        if (dollar[0] < '1' || dollar[0] > '9') {
            continue;
        }
        count++;
        size_t index = dollar[0] - '0';
        if (index < matches2.size() && count < matches2.size()) {
            if (prepend != "") {
                res += prepend + matches[index].word() + (dollar.c_str() + 1);
                prepend = "";
            }
            else {
                res += matches[index].word() + (dollar.c_str() + 1);
            }
        }
    }
    return res;
}
std::string Match::ReplaceDollar(const MatchCaptures& captures, const std::string& replace) {
    auto res = std::string();
    for (auto& matches : captures) {
        res += Match::ReplaceDollar(matches, replace);
    }
    return res;
}
size_t Match::ReplaceSub(const MatchCaptures& captures, std::string& subject) {
    auto res  = (size_t) 0;
    auto caps = static_cast<int>(captures.size());
    if (caps == 0) {
        return 0;
    }
    for (int f = caps - 1; f >= 0; f--) {
        auto mats = static_cast<int>(captures[f].size());
        if (mats == 0) {
            continue;
        }
        auto end = (mats == 1) ? 0 : 1;
        for (int e = mats - 1; e >= end; e--) {
            res += captures[f][e].replace(subject);
        }
    }
    return res;
}
PCRE::PCRE() {
    _notbol   = false;
    _notempty = false;
    _noteol   = false;
    _pcre     = nullptr;
    pcre_config(PCRE_CONFIG_UTF8, &_utf);
}
PCRE::PCRE(const std::string& pattern, bool useutf) {
    _notbol   = false;
    _notempty = false;
    _noteol   = false;
    _pcre     = nullptr;
    pcre_config(PCRE_CONFIG_UTF8, &_utf);
    compile(pattern, useutf);
}
PCRE::PCRE(PCRE&& other) {
    _error    = other._error;
    _matches  = other._matches;
    _notbol   = other._notbol;
    _notempty = other._notempty;
    _noteol   = other._noteol;
    _pattern  = other._pattern;
    _pcre     = other._pcre;
    _subject  = other._subject;
    _utf      = other._utf;
    memcpy(_off, other._off, PCRE::SIZE_OFF * sizeof(int));
    other._pcre = nullptr;
}
PCRE::~PCRE() {
    pcre_free(_pcre);
}
PCRE& PCRE::operator=(PCRE&& other) {
    pcre_free(_pcre);
    _error    = other._error;
    _matches  = other._matches;
    _notbol   = other._notbol;
    _notempty = other._notempty;
    _noteol   = other._noteol;
    _pattern  = other._pattern;
    _pcre     = other._pcre;
    _subject  = other._subject;
    _utf      = other._utf;
    memcpy(_off, other._off, PCRE::SIZE_OFF * sizeof(int));
    other._pcre = nullptr;
    return *this;
}
MatchCaptures PCRE::capture_all(const std::string& subject, const std::vector<std::string>& names) {
    set_names(names);
    auto captures = MatchCaptures();
    auto matches  = exec(subject);
    while (matches.size() > 1) {
        auto list = MatchVector();
        for (auto it = matches.begin(); it != matches.end(); ++it) {
            list.push_back(*it);
        }
        captures.push_back(list);
        auto& first = matches.front();
        if (first.count() == 0) {
            first.inc_start();
        }
        matches = exec_next(first);
    }
    return captures;
}
MatchCaptures PCRE::Captures(const std::string& regex, const std::string& subject) {
    auto rx = PCRE(regex);
    return rx.capture_all(subject);
}
void PCRE::clear() {
    pcre_free(_pcre);
    _matches.clear();
    _names.clear();
    _error   = "";
    _pattern = "";
    _pcre    = nullptr;
    _subject = "";
}
std::string PCRE::compile(const std::string& pattern, bool useutf) {
    clear();
    if (_utf != 1 && useutf == true) {
        _error = "Error: utf is requested but has not been enabled in PCRE8!";
        return _error;
    }
    auto error_str = (const char*) nullptr;
    auto error_off = 0;
    auto flags     = (useutf == true && _utf == 1) ? (PCRE_UTF8 | PCRE_UCP) : 0;
    _pcre = static_cast<::pcre*>(pcre_compile(pattern.c_str(), flags, &error_str, &error_off, nullptr));
    if (_pcre == nullptr) {
        _error = pcre8::format512("Error: %s at char %d!", error_str, error_off);
        return _error;
    }
    _error = "";
    _pattern = pattern;
    return "";
}
void PCRE::debug(bool print_matches) {
    printf("PCRE(%d.%d):\n", PCRE_MAJOR, PCRE_MINOR);
    printf("    error:       %s\n", _error.c_str());
    printf("    compiled:    %s\n", (is_compiled() == true) ? "true" : "false");
    printf("    utf enabled: %s\n", _utf == 1 ? "true" : "false");
    printf("    notbol:      %s\n", _notbol ? "true" : "false");
    printf("    notempty:    %s\n", _notempty ? "true" : "false");
    printf("    noteol:      %s\n", _noteol ? "true" : "false");
    printf("    pattern:     \"%s\"\n", _pattern.c_str());
    printf("    subject:     \"%s\"\n", _subject.c_str());
    printf("    length:      %d\n", (int) _subject.length());
    printf("    matches:     %d\n", (int) _matches.size());
    printf("    names:       %d\n", (int) _names.size());
    if (print_matches) Match::Print(_matches);
    printf("\n");
    fflush(stdout);
}
MatchVector PCRE::exec(const char* subject, size_t length) {
    _matches.clear();
    _subject = "";
    if (_pcre == nullptr) {
        _error = "Error: pcre is null!";
        return _matches;
    }
    memset(_off, 0, sizeof(int) * SIZE_OFF);
    auto option = (_notbol == true ? PCRE_NOTBOL : 0) | (_noteol == true ? PCRE_NOTEOL : 0) | (_notempty == true ? PCRE_NOTEMPTY : 0);
    auto count  = pcre_exec(static_cast<::pcre*>(_pcre), nullptr, subject, length, 0, option, _off, SIZE_OFF);
    if (count == 0) {
        return _matches;
    }
    _subject = subject;
    return _set_matches(count);
}
MatchVector PCRE::exec_next(const Match& last) {
    _matches.clear();
    if (_pcre == nullptr) {
        _error = "Error: pcre is null!";
        return _matches;
    }
    else if (last.end() > static_cast<int>(_subject.length())) {
        return _matches;
    }
    memset(_off, 0, sizeof(int) * SIZE_OFF);
    auto option = (_notbol == true ? PCRE_NOTBOL : 0) | (_noteol == true ? PCRE_NOTEOL : 0) | (_notempty == true ? PCRE_NOTEMPTY : 0);
    auto count  = pcre_exec(static_cast<::pcre*>(_pcre), nullptr, _subject.c_str(), _subject.length(), last.end(), option, _off, SIZE_OFF);
    return _set_matches(count);
}
size_t PCRE::Find(const std::string& regex, const std::string& subject) {
    return PCRE::Matches(regex, subject).size();
}
Match PCRE::match(const std::string& name) const {
    for (auto& m : _matches) {
        if (m.name() == name) {
            return m;
        }
    }
    return Match();
}
MatchVector PCRE::Matches(const std::string& regex, const std::string& subject) {
    auto rx = PCRE(regex);
    return rx.exec(subject);
}
MatchVector PCRE::_set_matches(int count) {
    for (int match = 0; match < count; match++) {
        const char* cap;
        if (pcre_get_substring(_subject.c_str(), _off, count, match, &cap) < 0) {
            _error = pcre8::format512("Error: could not retrieve substring (%d)!", match);
            _matches.clear();
            return _matches;
        }
        auto start = _off[match * 2];
        auto end   = _off[match * 2 + 1];
        if (start >= 0 && end >= 0 && start <= end) {
            _matches.push_back(Match(cap, start, end - start));
        }
        pcre_free_substring(cap);
    }
    size_t i = 1;
    for (const auto& name : _names) {
        const char* cap;
        if (pcre_get_named_substring(static_cast<::pcre*>(_pcre), _subject.c_str(), _off, _matches.size(), name.c_str(), &cap) >= 0) {
            if (i < _matches.size()) {
                _matches[i].name(name);
            }
            i++;
            pcre_free_substring(cap);
        }
    }
    _error = "";
    return _matches;
}
std::string PCRE::to_string() const {
    return pcre8::format512("PCRE(%s): %s", _pattern.c_str(), _subject.c_str());
}
}
}
#endif
#include <assert.h>
#include <algorithm>
#include <cstring>
#include <cstdarg>
#include <cmath>
namespace gnu {
namespace str {
static char* _format1(const char* format, va_list args, int& len) {
    char buf[128];
    len = vsnprintf(buf, 128, format, args);
    va_end(args);
    if (len <= 0) {
        return strdup("");
    }
    else if (len < 128) {
        return strdup(buf);
    }
    return nullptr;
}
static char* _format2(const char* format, va_list args, int len) {
    char* buf  = nullptr;
    int   len2 = 0;
    len++;
    buf = static_cast<char*>(malloc(len));
    len2 = vsnprintf(buf, len, format, args);
    va_end(args);
    if (len <= 0 || len2 >= len) {
        free(buf);
        return strdup("");
    }
    return buf;
}
static char* _replace_short(const char* in, const size_t in_len, const char* find, const char* replace, const size_t replace_len, size_t max, size_t& replaced) {
    assert(replace_len <= 1);
    auto res      = static_cast<char*>(malloc(in_len + 1));
    auto cur_len  = (size_t) 0;
    auto iter     = in;
    auto iter_end = in + in_len;
    auto first    = *find;
    replaced = 0;
    if (res == nullptr) {
        return nullptr;
    }
    while (iter < iter_end) {
        if (*iter != first || max == 0) {
            res[cur_len] = *iter;
            cur_len++;
        }
        else {
            if (replace_len == 1) {
                res[cur_len] = *replace;
                cur_len++;
            }
            replaced++;
            max--;
        }
        iter++;
    }
    res[cur_len] = 0;
    auto shrink = static_cast<char*>(realloc(res, cur_len + 1));
    return (shrink != nullptr) ? shrink : res;
}
static char* _replace_long(const char* in, const size_t in_len, const char* find, const size_t find_len, const char* replace, const size_t replace_len, size_t max, size_t& replaced) {
    auto res      = static_cast<char*>(malloc(in_len + 1));
    auto buf_len  = in_len;
    auto cur_len  = (size_t) 0;
    auto iter     = in;
    auto iter_end = in + in_len;
    auto first    = *find;
    replaced = 0;
    if (res == nullptr) {
        return nullptr;
    }
    while (iter < iter_end) {
        if (max > 0 && *iter == first && strncmp(iter, find, find_len) == 0) {
            auto size = cur_len + replace_len;
            if (size >= buf_len) {
                while (size >= buf_len) {
                    buf_len *= 2;
                }
                auto res2 = static_cast<char*>(realloc(res, buf_len));
                if (res2 == nullptr) {
                    free(res);
                    return nullptr;
                }
                else {
                    res = res2;
                }
            }
            if (replace_len > 1) {
                memcpy(res + cur_len, replace, replace_len);
            }
            else {
                *(res + cur_len) = *replace;
            }
            replaced += 1;
            max      -= 1;
            cur_len  += replace_len;
            iter     += find_len;
        }
        else {
            if (cur_len + 1 >= buf_len) {
                buf_len *= 2;
                auto res2 = static_cast<char*>(realloc(res, buf_len));
                if (res2 == nullptr) {
                    free(res);
                    return nullptr;
                }
                else {
                    res = res2;
                }
            }
            res[cur_len] = *iter;
            cur_len++;
            iter++;
        }
    }
    res[cur_len] = 0;
    auto shrink = static_cast<char*>(realloc(res, cur_len + 1));
    return (shrink != nullptr) ? shrink : res;
}
size_t find_first_of(const std::string& string, const std::string& list, const size_t pos) {
    auto res = std::string::npos;
    if (list == "" || pos >= string.length()) {
        return res;
    }
    for (auto& c : str::utf_chars(list.c_str())) {
        size_t found = string.find(c.c_str(), pos);
        if (found < res) {
            res = found;
        }
    }
    return res;
}
size_t find_last_of(const std::string& string, const std::string& list, size_t pos) {
    auto res = std::string::npos;
    if (pos == std::string::npos) {
        pos = string.length() - 1;
    }
    if (list == "" || pos >= string.length()) {
        return res;
    }
    for (auto& c : str::utf_chars(list.c_str())) {
        size_t found = string.rfind(c.c_str(), pos);
        if (found != std::string::npos && (found > res || res == std::string::npos)) {
            res = found;
        }
    }
    return res;
}
std::string format(const char* format, ...) {
    int len = 0;
    va_list args;
    std::string res;
    va_start(args, format);
    auto buf = str::_format1(format, args, len);
    if (buf != nullptr) {
        res = buf;
        free(buf);
        return res;
    }
    va_start(args, format);
    buf = str::_format2(format, args, len);
    res = buf;
    free(buf);
    return res;
}
std::string format_int(const int64_t num, char del) {
    auto pos = 0;
    char tmp1[32];
    char tmp2[32];
    if (del < 32) {
        del = 32;
    }
    memset(tmp2, 0, 32);
    snprintf(tmp1, 32, "%lld", (long long int) num);
    auto len = strlen(tmp1);
    for (int f = len - 1, i = 0; f >= 0 && pos < 32; f--, i++) {
        char c = tmp1[f];
        if ((i % 3) == 0 && i > 0 && c != '-') {
            tmp2[pos++] = del;
        }
        tmp2[pos++] = c;
    }
    std::string r = tmp2;
    std::reverse(r.begin(), r.end());
    return r;
}
std::string format_double(const double num, size_t decimals, char del) {
    auto anum = std::fabs(num);
    if (anum > 9'007'199'254'740'992.0) {
        return "";
    }
    if (del < 32) {
        del = 32;
    }
    if (decimals == 0 || decimals > 9) {
        return str::format_int(static_cast<int64_t>(num), del);
    }
    char fr_str[100];
    auto int_num    = static_cast<int64_t>(anum);
    auto double_num = static_cast<double>(anum - int_num);
    auto res        = str::format_int(int_num, del);
    auto n          = snprintf(fr_str, 100, "%.*f", static_cast<int>(decimals), double_num);
    if (num < 0.0) {
        res = "-" + res;
    }
    if (n > 0 && n < 100) {
        res += fr_str + 1;
    }
    return res;
}
bool has_whitespace(const std::string& string) {
    for (auto c : string) {
        auto u = static_cast<unsigned>(c);
        if (u == '\f' || u == '\n' || u == '\r' || u == '\t' || u == '\v' || u == ' ') {
            return true;
        }
    }
    return false;
}
bool is_whitespace(const std::string& string) {
    if (string == "") {
        return false;
    }
    for (auto c : string) {
        auto u = static_cast<unsigned>(c);
        if (u != '\f' && u != '\n' && u != '\r' && u != '\t' && u != '\v' && u != ' ') {
            return false;
        }
    }
    return true;
}
size_t list_append(std::vector<std::string>& strings, const std::string& string, size_t max_size) {
    for (auto it = strings.begin(); it != strings.end(); ++it) {
        if (*it == string) {
            strings.erase(it);
            break;
        }
    }
    strings.push_back(string);
    while (strings.size() > max_size) {
        strings.erase(strings.begin());
    }
    return strings.size();
}
size_t list_insert(std::vector<std::string>& strings, const std::string& string, size_t max_size) {
    for (auto it = strings.begin(); it != strings.end(); ++it) {
        if (*it == string) {
            strings.erase(it);
            break;
        }
    }
    strings.insert(strings.begin(), string);
    while (strings.size() > max_size) {
        strings.pop_back();
    }
    return strings.size();
}
std::string& replace(std::string& string, const std::string& find, const std::string& replace, size_t max) {
    auto replaced = (size_t) 0;
    auto res      = (char*) nullptr;
    if (string == "" || find == "") {
        return string;
    }
    if (find.length() == 1 && replace.length() <= 1) {
        res = str::_replace_short(string.c_str(), string.length(), find.c_str(), replace.c_str(), replace.length(), max, replaced);
    }
    else {
        res = str::_replace_long(string.c_str(), string.length(), find.c_str(), find.length(), replace.c_str(), replace.length(), max, replaced);
    }
    string = res;
    free(res);
    return string;
}
std::string replace_const(const std::string& str, const std::string& find, const std::string& replace, size_t max) {
    auto res = str;
    return str::replace(res, find, replace, max);
}
std::string replace_std(const std::string& string, const std::string& find, const std::string& replace) {
    if (find == "") {
        return string;
    }
    try {
        auto res   = std::string();
        auto start = (size_t) 0;
        auto pos   = (size_t) 0;
        while ((pos = string.find(find, start)) != std::string::npos) {
            res   += string.substr(start, pos - start);
            res   += replace;
            pos   += find.length();
            start  = pos;
        }
        res += string.substr(start);
        return res;
    }
    catch(...) {
        return string;
    }
}
std::string reverse(const std::string& string) {
    auto res = std::string();
    auto vec = str::utf_chars(string.c_str());
    if (vec.size() == 0) {
        return res;
    }
    for (ssize_t f = vec.size() - 1; f >= 0; f--) {
        res += vec[f];
    }
    return res;
}
std::vector<std::string> split(const std::string& string, const std::string& split) {
    auto res = std::vector<std::string>();
    try {
        if (split == "") {
            res.push_back(string);
            return res;
        }
        auto pos1 = (std::string::size_type) 0;
        auto pos2 = string.find(split);
        while (pos2 != std::string::npos) {
            res.push_back(string.substr(pos1, pos2 - pos1));
            pos1 = pos2 + split.size();
            pos2 = string.find(split, pos1);
        }
        if (pos1 <= string.size()) {
            res.push_back(string.substr(pos1));
        }
    }
    catch(...) {
        res.clear();
    }
    return res;
}
std::vector<const char*> split_fast(char* string, char split) {
    auto res   = std::vector<const char*>();
    auto start = string;
    auto end   = string + strlen(string);
    auto found = strchr(start, split);
    if (split == 0) {
        res.push_back(string);
        return res;
    }
    while (found != nullptr) {
        *found = 0;
        res.push_back(start);
        start = found + 1;
        found = strchr(start, split);
    }
    if (start <= end) {
        res.push_back(start);
    }
    return res;
}
std::string substr(const std::string& string, std::string::size_type pos, std::string::size_type count) {
    try {
        return (pos > string.size()) ? "" : string.substr(pos, count);
    }
    catch(...) {
        return "";
    }
}
std::string substr_utf(const std::string& string, std::string::size_type pos, std::string::size_type count) {
    try {
        auto res = std::string();
        auto vec = str::utf_chars(string.c_str());
        if (count == std::string::npos) {
            count = string.length();
        }
        for (size_t f = pos; f < pos + count && f < vec.size(); f++) {
            res += vec[f];
        }
        return res;
    }
    catch(...) {
        return "";
    }
}
double to_double(const std::string& string, double def) {
    try {
        return std::stod(string, 0);
    }
    catch (...) {
        return def;
    }
}
long long int to_int(const std::string& string, long long int def) {
    try {
        return std::stoll(string, 0, 0);
    }
    catch (...) {
        return def;
    }
}
std::string& trim(std::string& string) {
    string.erase(string.begin(), std::find_if(string.begin(), string.end(), [](auto c) { return !std::isspace(c);} ));
    string.erase(std::find_if(string.rbegin(), string.rend(), [](int ch) { return !std::isspace(ch); }).base(), string.end());
    return string;
}
std::string trim_const(const std::string& str) {
    auto res = str;
    return str::trim(res);
}
std::string utf_char(const char* string) {
    auto f     = (size_t) 0;
    auto u     = reinterpret_cast<const unsigned char*>(string);
    auto c     = (unsigned) u[0];
    auto res   = std::string();
    if (c != 0) {
        res += c;
        if (c >= 128) {
            if (c >= 194 && c <= 223) {
                c = u[++f];
                if (c < 128 || c > 191) {
                    return "";
                }
                res += c;
            }
            else if (c >= 224 && c <= 239) {
                c = u[++f];
                if (c < 128 || c > 191) {
                    return "";
                }
                res += c;
                c = u[++f];
                if (c < 128 || c > 191) {
                    return "";
                }
                res += c;
            }
            else if (c >= 240 && c <= 244) {
                c = u[++f];
                if (c < 128 || c > 191) {
                    return "";
                }
                res += c;
                c = u[++f];
                if (c < 128 || c > 191) {
                    return "";
                }
                res += c;
                c = u[++f];
                if (c < 128 || c > 191) {
                    return "";
                }
                res += c;
            }
            else {
                return "";
            }
        }
    }
    return res;
}
std::vector<std::string> utf_chars(const char* string) {
    auto res = std::vector<std::string>();
    while (*string != 0) {
        auto l = str::utf_char(string);
        if (l == "") {
            return res;
        }
        res.push_back(l);
        string += l.length();
    }
    return res;
}
size_t utf_len(const char* string) {
    auto count = (size_t) 0;
    auto f     = (size_t) 0;
    auto u     = reinterpret_cast<const unsigned char*>(string);
    auto c     = (unsigned) u[0];
    while (c != 0) {
        if (c >= 128) {
            if (c >= 194 && c <= 223) {
                c = u[++f];
                if (c < 128 || c > 191) {
                    return 0;
                }
            }
            else if (c >= 224 && c <= 239) {
                c = u[++f];
                if (c < 128 || c > 191) {
                    return 0;
                }
                c = u[++f];
                if (c < 128 || c > 191) {
                    return 0;
                }
            }
            else if (c >= 240 && c <= 244) {
                c = u[++f];
                if (c < 128 || c > 191) {
                    return 0;
                }
                c = u[++f];
                if (c < 128 || c > 191) {
                    return 0;
                }
                c = u[++f];
                if (c < 128 || c > 191) {
                    return 0;
                }
            }
            else {
                return 0;
            }
        }
        count++;
        c = u[++f];
    }
    return count;
}
}
}
#include <ctime>
#ifdef _WIN32
    #include <windows.h>
#else
    #include <unistd.h>
#endif
namespace gnu {
std::string Time::FormatMilliToTime(int64_t milliseconds) {
    auto h = (int64_t) milliseconds / 3'600'000;
    auto m = (int64_t) 0;
    auto s = (int64_t) 0;
    char buffer[100];
    milliseconds = milliseconds % 3'600'000;
    m            = milliseconds / 60'000;
    milliseconds = milliseconds % 60'000;
    s            = milliseconds / 1'000;
    milliseconds = milliseconds % 1'000;
    if (h == 0) {
        snprintf(buffer, 100, "%02u:%02u.%03u", (unsigned) m, (unsigned) s, (unsigned) milliseconds);
    }
    else {
        snprintf(buffer, 100, "%02u:%02u:%02u", (unsigned) h, (unsigned) m, (unsigned) s);
    }
    return buffer;
}
double Time::Clock() {
#ifdef _WIN32
    struct timeb timeVal;
    ftime(&timeVal);
    return (double) timeVal.time + (double) (timeVal.millitm / 1'000.0);
#else
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (double) (ts.tv_sec) + (ts.tv_nsec / 1'000'000'000.0);
#endif
}
std::string Time::FormatUnixToISO(int64_t seconds, bool utc, bool date_only) {
    const time_t rawtime  = (time_t) seconds;
    const tm*    timeinfo = (utc == true) ? gmtime(&rawtime) : localtime(&rawtime);
    char         buffer[100];
    if (timeinfo == nullptr) {
        return "";
    }
    if (date_only == true) {
        snprintf(buffer, 100, "%04d-%02d-%02d", timeinfo->tm_year + 1900, timeinfo->tm_mon + 1, timeinfo->tm_mday);
    }
    else {
        snprintf(buffer, 100, "%04d-%02d-%02d %02d:%02d:%02d", timeinfo->tm_year + 1900, timeinfo->tm_mon + 1, timeinfo->tm_mday, timeinfo->tm_hour, timeinfo->tm_min, timeinfo->tm_sec);
    }
    return buffer;
}
int64_t Time::Micro() {
#if defined(_WIN32)
    LARGE_INTEGER starting_time;
    LARGE_INTEGER frequency;
    QueryPerformanceFrequency(&frequency);
    QueryPerformanceCounter(&starting_time);
    starting_time.QuadPart *= 1'000'000;
    starting_time.QuadPart /= frequency.QuadPart;
    return starting_time.QuadPart;
#else
    struct timespec t;
    clock_gettime(CLOCK_MONOTONIC, &t);
    return (t.tv_sec * 1'000'000) + (t.tv_nsec / 1'000);
#endif
}
void Time::SleepMilli(unsigned milliseconds) {
#ifdef _WIN32
    ::Sleep(milliseconds);
#else
    usleep(milliseconds * 1000);
#endif
}
}
#include <cstring>
#include <cassert>
#include <ctime>
namespace gnu {
static int          _DATE_DAYS_MONTH[]      = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
static int          _DATE_DAYS_MONTH_LEAP[] = {0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
static const char*  _DATE_WEEKDAYS[]        = {"", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday", ""};
static const char*  _DATE_WEEKDAYS_SHORT[]  = {"", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun", ""};
static const char*  _DATE_MONTHS[]          = {"", "January", "February", "Mars", "April", "May", "June", "July", "August", "September", "October", "November", "December", ""};
static const char*  _DATE_MONTHS_SHORT[]    = {"", "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", ""};
static int _date_days_in_month(int year, int month) {
    if (year < 1 || year > 9999 || month < 1 || month > 12) {
        return 0;
    }
    else if ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0) {
        return _DATE_DAYS_MONTH_LEAP[month];
    }
    return _DATE_DAYS_MONTH[month];
}
static void _date_from_time(int64_t seconds, Date::UTC utc, int& year, int& month, int& day, int& hour, int& min, int& sec) {
    year = month = day = 1;
    hour = min = sec = 0;
    if (seconds < 0) {
        return;
    }
    time_t    rawtime  = seconds;
    const tm* timeinfo = (utc == Date::UTC::ON) ? gmtime(&rawtime) : localtime(&rawtime);
    if (timeinfo == nullptr) {
        return;
    }
    year  = timeinfo->tm_year + 1900;
    month = timeinfo->tm_mon + 1;
    day   = timeinfo->tm_mday;
    hour  = timeinfo->tm_hour;
    min   = timeinfo->tm_min;
    sec   = timeinfo->tm_sec;
}
static Date::Day _date_weekday(int year, int month, int day) {
    if (year > 0 && year < 10000 && month > 0 && month < 13 && day > 0 && day <= _date_days_in_month(year, month)) {
        int start = 0;
        int y1    = year - 1;
        int pre   = ((year < 1582) || ((year == 1582) && (month <= 10)));
        if (pre) {
            start = 6 + y1 + (y1 / 4);
        }
        else {
            start = 1 + y1 + (y1 / 4) - (y1 / 100) + (y1 / 400);
        }
        for (int i = 1; i < month; i++) {
            int days = _date_days_in_month(year, i);
            if (days) {
                start += days;
            }
            else {
                return Date::Day::INVALID;
            }
        }
        start = start % 7;
        start = start == 0 ? 7 : start;
        for (int i = 2; i <= day; i++) {
            start++;
            if (start > 7) {
                start = 1;
            }
        }
        if (start < 1 || start > 7) {
            return Date::Day::INVALID;
        }
        else {
            return (Date::Day) start;
        }
    }
    return Date::Day::INVALID;
}
static bool _date_is_leapyear(int year) {
    if (year < 1 || year > 9999) {
        return false;
    }
    else if ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0) {
        return true;
    }
    else {
       return false;
    }
}
Date::Date(Date::UTC utc) {
    int y, m, d, ho, mi, se;
    _year = _month = _day = _hour = _min = _sec = 0;
    _date_from_time(::time(nullptr), utc, y, m, d, ho, mi, se);
    set(y, m, d, ho, mi, se);
}
Date::Date(int year, int month, int day, int hour, int min, int sec) {
    _year = _month = _day = _hour = _min = _sec = 0;
    set(year, month, day, hour, min, sec);
}
Date::Date(int64_t unix_time, Date::UTC utc) {
    int y, m, d, ho, mi, se;
    _date_from_time(unix_time, utc, y, m, d, ho, mi, se);
    set(y, m, d, ho, mi, se);
}
Date::Date(const std::string& date, Date::US us) {
    _year = _month = _day = _hour = _min = _sec = 0;
    set(date, us);
}
bool Date::add_days(const int days) {
    if (days == 0) {
        return 0;
    }
    int daym = _date_days_in_month(_year, _month);
    if (daym == 0) {
        return false;
    }
    int inc = days > 0 ? 1 : -1;
    int y   = _year;
    int m   = _month;
    int d   = _day;
    for (int f = 0; f < abs(days); f++) {
        d += inc;
        if (inc < 0 && d == 0) {
            m--;
            if (m == 0) {
                m = 12;
                y--;
                if (y < 1) {
                    return false;
                }
            }
            d = _date_days_in_month(y, m);
            if (d == 0) {
                return false;
            }
        }
        else if (inc > 0 && d > daym) {
            d = 1;
            m++;
            if (m == 13) {
                m = 1;
                y++;
                if (y > 9999) {
                    return false;
                }
            }
            daym = _date_days_in_month(y, m);
            if (daym == 0) {
                return false;
            }
        }
    }
    _year  = y;
    _month = m;
    _day   = d;
    return true;
}
bool Date::add_months(const int months) {
    if (months == 0) {
        return false;
    }
    int inc = months > 0 ? 1 : -1;
    int m   = _month;
    int y   = _year;
    for (int f = 0; f < abs(months); f++) {
        m += inc;
        if (m == 0) {
            m = 12;
            y--;
            if (y < 1) {
                return false;
            }
        }
        else if (m > 12) {
            m = 1;
            y++;
            if (y > 9999) {
                return false;
            }
        }
    }
    const int days = _date_days_in_month(y, m);
    if (days <= 0) {
        return false;
    }
    _year  = y;
    _month = m;
    if (_day > days) {
        _day = days;
    }
    return true;
}
bool Date::add_seconds(const int64_t seconds) {
    if (seconds == 0) {
        return false;
    }
    int inc = seconds > 0 ? 1 : -1;
    int h   = _hour;
    int m   = _min;
    int s   = _sec;
    for (int64_t f = 0; f < llabs(seconds); f++) {
        s += inc;
        if (inc < 0 && s == -1) {
            m--;
            if (m == -1) {
                m = 59;
                h--;
                if (h == -1) {
                    h = 23;
                    if (add_days(-1) == false) {
                        return false;
                    }
                }
            }
            s = 59;
        }
        else if (inc > 0 && s == 60) {
            m++;
            if (m == 60) {
                m = 0;
                h++;
                if (h == 24) {
                    h = 0;
                    if (add_days(1) == false) {
                        return false;
                    }
                }
            }
            s = 0;
        }
    }
    _hour = h;
    _min  = m;
    _sec  = s;
    return true;
}
int Date::compare(const Date& other, Compare flag) const {
    if (_year < other._year) {
        return -1;
    }
    else if (_year > other._year) {
        return 1;
    }
    if (_month < other._month) {
        return -1;
    }
    else if (_month > other._month) {
        return 1;
    }
    if (flag >= Compare::YYYYMMDD) {
        if (_day < other._day) {
            return -1;
        }
        else if (_day > other._day) {
            return 1;
        }
    }
    if (flag >= Compare::YYYYMMDDHH) {
        if (_hour < other._hour) {
            return -1;
        }
        else if (_hour > other._hour) {
            return 1;
        }
    }
    if (flag >= Compare::YYYYMMDDHHMM) {
        if (_min < other._min) {
            return -1;
        }
        else if (_min > other._min) {
            return 1;
        }
    }
    if (flag >= Compare::YYYYMMDDHHMMSS) {
        if (_sec < other._sec) {
            return -1;
        }
        else if (_sec > other._sec) {
            return 1;
        }
    }
    return 0;
}
int Date::days_in_month() const {
    return _date_days_in_month(_year, _month);
}
int Date::days_into_year() const {
    auto res  = 0;
    auto leap = _date_is_leapyear(_year);
    for (auto m = 1; m < _month && m < 13; m++) {
        if (leap) {
            res += _DATE_DAYS_MONTH_LEAP[m];
        }
        else {
            res += _DATE_DAYS_MONTH[m];
        }
    }
    return res + _day;
}
void Date::debug() const {
#ifdef DEBUG
    printf("Date| %s\n", format(Format::ISO_TIME_LONG).c_str());
    fflush(stdout);
#endif
}
int Date::diff_days(const Date& date) const {
    Date d(date);
    int  res = 0;
    if (compare(d, Compare::YYYYMMDD) < 0) {
        while (compare(d, Compare::YYYYMMDD) != 0) {
            d.add_days(-1);
            res++;
        }
    }
    else if (compare(d, Compare::YYYYMMDD) > 0) {
        while (compare(d, Compare::YYYYMMDD) != 0) {
            d.add_days(1);
            res--;
        }
    }
    return res;
}
int Date::diff_months(const Date& date) const {
    Date d(date);
    int  res = 0;
    if (compare(d, Compare::YYYYMM) < 0) {
        while (compare(d, Compare::YYYYMM)) {
            d.add_months(-1);
            res++;
        }
    }
    else if (compare(d, Compare::YYYYMM) > 0) {
        while (compare(d, Compare::YYYYMM)) {
            d.add_months(1);
            res--;
        }
    }
    return res;
}
int64_t Date::diff_seconds(const Date& date) const {
    int64_t unix1 = time();
    int64_t unix2 = date.time();
    if (unix1 >= 0 && unix2 >= 0) {
        return unix2 - unix1;
    }
    return 0;
}
std::string Date::format(Format format) const {
    char tmp[100];
    int  n = 0;
    if (format == Format::ISO) {
        n = snprintf(tmp, 100, "%04d%02d%02d", _year, _month, _day);
    }
    else if (format == Format::ISO_LONG) {
        n = snprintf(tmp, 100, "%04d-%02d-%02d", _year, _month, _day);
    }
    else if (format == Format::ISO_TIME) {
        n = snprintf(tmp, 100, "%04d%02d%02d %02d%02d%02d", _year, _month, _day, _hour, _min, _sec);
    }
    else if (format == Format::ISO_TIME_LONG) {
        n = snprintf(tmp, 100, "%04d-%02d-%02d %02d:%02d:%02d", _year, _month, _day, _hour, _min, _sec);
    }
    else if (format == Format::TIME) {
        n = snprintf(tmp, 100, "%02d%02d%02d", _hour, _min, _sec);
    }
    else if (format == Format::TIME_LONG) {
        n = snprintf(tmp, 100, "%02d:%02d:%02d", _hour, _min, _sec);
    }
    else if (format == Format::US) {
        n = snprintf(tmp, 100, "%d/%d/%04d", _month, _day, _year);
    }
    else if (format == Format::WORLD) {
        n = snprintf(tmp, 100, "%d/%d/%04d", _day, _month, _year);
    }
    else if (format == Format::DAY_MONTH_YEAR) {
        n = snprintf(tmp, 100, "%d %s %04d", _day, month_name(), _year);
    }
    else if (format == Format::DAY_MONTH_YEAR_SHORT) {
        n = snprintf(tmp, 100, "%d %s, %04d", _day, month_name_short(), _year);
    }
    else if (format == Format::WEEKDAY_MONTH_YEAR) {
        n = snprintf(tmp, 100, "%s %d %s %04d", weekday_name(), _day, month_name(), _year);
    }
    else if (format == Format::WEEKDAY_MONTH_YEAR_SHORT) {
        n = snprintf(tmp, 100, "%s, %d %s, %04d", weekday_name_short(), _day, month_name_short(), _year);
    }
    else if (format == Format::WEEKDAY) {
        n = snprintf(tmp, 100, "%s", weekday_name());
    }
    else if (format == Format::WEEKDAY_SHORT) {
        n = snprintf(tmp, 100, "%s", weekday_name_short());
    }
    else if (format == Format::MONTH) {
        n = snprintf(tmp, 100, "%s", month_name());
    }
    else if (format == Format::MONTH_SHORT) {
        n = snprintf(tmp, 100, "%s", month_name_short());
    }
    if (n < 0 || n >= 100) {
        *tmp = 0;
    }
    return tmp;
}
bool Date::is_leapyear() const {
    return _date_is_leapyear(_year);
}
const char* Date::month_name() const {
    return _DATE_MONTHS[(int) _month];
}
const char* Date::month_name_short() const {
    return _DATE_MONTHS_SHORT[(int) _month];
}
Date& Date::set(const Date& date) {
    _year  = date._year;
    _month = date._month;
    _day   = date._day;
    _hour  = date._hour;
    _min   = date._min;
    _sec   = date._sec;
    return *this;
}
Date& Date::set(const std::string& date, Date::US us) {
    auto str1 = date.c_str();
    auto len1 = static_cast<int>(date.length());
    auto str2 = strstr(str1, " ");
    while (str2 != nullptr && *str2 == ' ') {
        str2++;
        if (*str2 == 0) {
            str2 = nullptr;
        }
    }
    int      len2    = (str2 != nullptr) ? strlen(str2) : 0;
    int      year    = 0;
    int      month   = 0;
    int      day     = 0;
    int      hour    = 0;
    int      min     = 0;
    int      sec     = 0;
    int      Y       = 0;
    bool     time    = false;
    unsigned val[14] = { 0 };
    unsigned EMPTY   = -1;
    if (len1 >= 10 && str1[4] == '-' && str1[7] == '-' && str1[10] <= ' ') {
        us     = US::OFF;
        val[4] = str1[5] - '0';
        val[5] = str1[6] - '0';
        val[6] = str1[8] - '0';
        val[7] = str1[9] - '0';
    }
    else if (len1 >= 8 && str1[1] == '/' && str1[3] == '/' && str1[8] <= ' ') {
        Y      = 4;
        val[4] = str1[2] - '0';
        val[5] = EMPTY;
        val[6] = str1[0] - '0';
        val[7] = EMPTY;
    }
    else if (len1 >= 9 && str1[1] == '/' && str1[4] == '/' && str1[9] <= ' ') {
        Y      = 5;
        val[4] = str1[2] - '0';
        val[5] = str1[3] - '0';
        val[6] = str1[0] - '0';
        val[7] = EMPTY;
    }
    else if (len1 >= 9 && str1[2] == '/' && str1[4] && str1[9] <= ' ') {
        Y      = 5;
        val[4] = str1[3] - '0';
        val[5] = EMPTY;
        val[6] = str1[0] - '0';
        val[7] = str1[1] - '0';
    }
    else if (len1 >= 10 && str1[2] == '/' && str1[5] == '/' && str1[10] <= ' ') {
        Y      = 6;
        val[4] = str1[3] - '0';
        val[5] = str1[4] - '0';
        val[6] = str1[0] - '0';
        val[7] = str1[1] - '0';
    }
    else if (len1 >= 8 && str1[8] <= ' ') {
        us     = US::OFF;
        val[4] = str1[4] - '0';
        val[5] = str1[5] - '0';
        val[6] = str1[6] - '0';
        val[7] = str1[7] - '0';
    }
    else {
        return *this;
    }
    val[0] = str1[Y] - '0';
    val[1] = str1[Y + 1] - '0';
    val[2] = str1[Y + 2] - '0';
    val[3] = str1[Y + 3] - '0';
    if (str2 != nullptr && str2[0] >= '0' && str2[0] <= '9') {
        if (len2 >= 4 && str2[4] <= ' ') {
            time    = true;
            val[8]  = str2[0] - '0';
            val[9]  = str2[1] - '0';
            val[10] = str2[2] - '0';
            val[11] = str2[3] - '0';
        }
        else if (len2 >= 5 && str2[2] == ':' && str2[5] <= ' ') {
            time    = true;
            val[8]  = str2[0] - '0';
            val[9]  = str2[1] - '0';
            val[10] = str2[3] - '0';
            val[11] = str2[4] - '0';
        }
        else if (len2 >= 6 && str2[6] <= ' ') {
            time    = true;
            val[8]  = str2[0] - '0';
            val[9]  = str2[1] - '0';
            val[10] = str2[2] - '0';
            val[11] = str2[3] - '0';
            val[12] = str2[4] - '0';
            val[13] = str2[5] - '0';
        }
        else if (len2 >= 8 && str2[2] == ':' && str2[5] == ':' && str2[8] <= ' ') {
            time    = true;
            val[8]  = str2[0] - '0';
            val[9]  = str2[1] - '0';
            val[10] = str2[3] - '0';
            val[11] = str2[4] - '0';
            val[12] = str2[6] - '0';
            val[13] = str2[7] - '0';
        }
        for (int f = 8; f < 14 && time == true; f++) {
            if (val[f] > 9) {
                time = false;
            }
        }
        if (time == true) {
            hour = val[8] * 10 + val[9];
            min  = val[10] * 10 + val[11];
            sec  = val[12] * 10 + val[13];
            if (hour < 0 || hour > 23) {
                time = false;
            }
            else if (min < 0 || min > 59) {
                time = false;
            }
            else if (sec < 0 || sec > 59) {
                time = false;
            }
        }
    }
    for (int f = 0; f < 8; f++) {
        if (f == 5 && val[5] == EMPTY) {
        }
        else if (f == 7 && val[7] == EMPTY) {
        }
        else if (val[f] > 9) {
            return *this;
        }
    }
    year  = val[0] * 1000 + val[1] * 100 + val[2] * 10 + val[3];
    month = (val[5] == EMPTY) ? val[4] : val[4] * 10 + val[5];
    day   = (val[7] == EMPTY) ? val[6] : val[6] * 10 + val[7];
    if (us == US::ON) {
        int tmp = month;
        month   = day;
        day     = tmp;
    }
    if (time == true) {
        set(year, month, day, hour, min, sec);
    }
    else {
        set(year, month, day);
    }
    return *this;
}
Date& Date::set(int year, int month, int day, int hour, int min, int sec) {
    if (year < 1 || year > 9999 ||
        month < 1 || month > 12 ||
        day < 1 || day > _date_days_in_month(year, month) ||
        hour < 0 || hour > 23 ||
        min < 0 || min > 59 ||
        sec < 0 || sec > 59) {
        return *this;
    }
    else {
        _year  = year;
        _month = month;
        _day   = day;
        _hour  = hour;
        _min   = min;
        _sec   = sec;
        return *this;
    }
}
Date& Date::set_day(int day) {
    if (day > 0 && day <= _date_days_in_month(_year, _month)) {
        _day = day;
    }
    return *this;
}
Date& Date::set_hour(int hour) {
    if (hour >= 0 && hour <= 23) {
        _hour = hour;
    }
    return *this;
}
Date& Date::set_minute(int min) {
    if (min >= 0 && min <= 59) {
        _min = min;
    }
    return *this;
}
Date& Date::set_month(int month) {
    if (_day >= 1 &&
        _day <= _date_days_in_month(_year, month) &&
        month >= 1 && month <= 12) {
        _month = month;
    }
    return *this;
}
Date& Date::set_second(int sec) {
    if (sec >= 0 && sec <= 59) {
        _sec = sec;
    }
    return *this;
}
Date& Date::set_weekday(Date::Day day) {
    if (weekday() < day) {
        while (weekday() < day) {
            add_days(1);
        }
    }
    else if (weekday() > day) {
        while (weekday() > day) {
            add_days(-1);
        }
    }
    return *this;
}
Date& Date::set_year(int year) {
    if (year >= 1 && year <= 9999) {
        _year = year;
    }
    return *this;
}
int64_t Date::time() const {
    tm t;
    if (_year < 1970) {
        return -1;
    }
    memset(&t, '\0', sizeof(t));
    t.tm_year = _year - 1900;
    t.tm_mon  = _month - 1;
    t.tm_mday = _day;
    t.tm_hour = _hour;
    t.tm_min  = _min;
    t.tm_sec  = _sec;
    return mktime(&t);
}
int Date::week() const {
    Date::Day wday  = _date_weekday(_year, _month, _day);
    Date::Day wday1 = _date_weekday(_year, 1, 1);
    if (wday != Date::Day::INVALID && wday1 != Date::Day::INVALID) {
        auto w     = 0;
        auto y1    = _year - 1;
        auto leap  = _date_is_leapyear(_year);
        auto leap1 = _date_is_leapyear(y1);
        auto yday  = days_into_year();
        if (yday <= (8 - (int) wday1) && wday1 > Date::Day::THURSDAY) {
            if (wday1 == Date::Day::FRIDAY || (wday1 == Date::Day::SATURDAY && leap1)) {
                w = 53;
            }
            else {
                w = 52;
            }
        }
        else {
            auto days = leap ? 366 : 365;
            if ((days - yday) < (4 - (int) wday)) {
                w = 1;
            }
            else {
                days = yday + (7 - (int) wday) + ((int) wday1 - 1);
                days = days / 7;
                if (wday1 > Date::Day::THURSDAY) {
                    days--;
                }
                w = days;
            }
        }
        if (w > 0 && w < 54) {
            return w;
        }
    }
    return 0;
}
Date::Day Date::weekday() const {
    return _date_weekday(_year, _month, _day);
}
const char* Date::weekday_name() const {
    return _DATE_WEEKDAYS[(int) _date_weekday(_year, _month, _day)];
}
const char* Date::weekday_name_short() const {
    return _DATE_WEEKDAYS_SHORT[(int) _date_weekday(_year, _month, _day)];
}
}
#include <algorithm>
#include <filesystem>
#include <climits>
#include <ctime>
#include <assert.h>
#include <dirent.h>
#include <unistd.h>
#ifdef _WIN32
    #include <shlobj.h>
    #include <time.h>
#else
    #include <sys/stat.h>
    #include <utime.h>
#endif
#ifndef PATH_MAX
    #define PATH_MAX 1050
#endif
namespace gnu {
namespace file {
static std::string          _STDOUT_NAME = "";
static std::string          _STDERR_NAME = "";
#ifdef _WIN32
static char*                _from_wide(const wchar_t* wstring);
static int64_t              _time(FILETIME* ft);
static wchar_t*             _to_wide(const char* string);
#endif
static Buf                  _close_redirect(int type);
static bool                 _open_redirect(int type);
static unsigned             _rand();
static void                 _read(const std::string& path, Buf& buf);
static std::string&         _replace_all(std::string& string, const std::string& find, const std::string& replace);
static void                 _read_dir_rec(Files& res, Files& files);
static std::string&         _replace_all(std::string& string, const std::string& find, const std::string& replace);
static void                 _split_paths(const std::string& filename, std::string& path, std::string& name, std::string& ext);
static std::string          _substr(const std::string& in, std::string::size_type pos, std::string::size_type size = std::string::npos);
static std::string          _to_absolute_path(const std::string& filename, bool realpath);
static Buf _close_redirect(int type) {
    std::string fname;
    FILE* fhandle;
    if (type == 2) {
        if (_STDERR_NAME == "") return Buf();
        fname = _STDERR_NAME;
        fhandle = stderr;
        _STDERR_NAME = "";
    }
    else {
        if (_STDOUT_NAME == "") return Buf();
        fname = _STDOUT_NAME;
        fhandle = stdout;
        _STDOUT_NAME = "";
    }
#ifdef _WIN32
    fflush(fhandle);
    freopen("CON", "w", fhandle);
#else
    fflush(fhandle);
    auto r = freopen("/dev/tty", "w", fhandle);
    (void) r;
#endif
    auto res = file::read(fname);
    file::remove(fname);
    return res;
}
#ifdef _WIN32
static char* _from_wide(const wchar_t* wstring) {
    auto out_len = WideCharToMultiByte(CP_UTF8, 0, wstring, -1, nullptr, 0, nullptr, nullptr);
    auto out     = file::allocate(nullptr, out_len + 1);
    WideCharToMultiByte(CP_UTF8, 0, wstring, -1, (LPSTR) out, out_len, nullptr, nullptr);
    return (char*) out;
}
#endif
static bool _open_redirect(int type) {
    bool res = false;
    std::string fname;
    FILE* fhandle = nullptr;
    if (type == 2) {
        if (_STDERR_NAME != "") return res;
        fname = _STDERR_NAME = file::tmp_file("stderr_").filename();
        fhandle = stderr;
    }
    else {
        if (_STDOUT_NAME != "") return res;
        fname = _STDOUT_NAME = file::tmp_file("stdout_").filename();
        fhandle = stdout;
    }
#ifdef _WIN32
        auto wpath = file::_to_wide(fname.c_str());
        auto wmode = file::_to_wide("wb");
        res = _wfreopen(wpath, wmode, fhandle) != nullptr;
        free(wpath);
        free(wmode);
#else
        res = freopen(fname.c_str(), "wb", fhandle) != nullptr;
#endif
    if (res == false && type == 1) {
        _STDOUT_NAME = "";
    }
    else if (res == false && type == 2) {
        _STDERR_NAME = "";
    }
    return res;
}
static unsigned _rand() {
    static bool INIT = false;
    if (INIT == false) {
        srand(time(nullptr));
    }
    INIT = true;
    if (RAND_MAX < 50000) {
        return rand() * rand();
    }
    else {
        return rand();
    }
}
static void _read(const std::string& path, Buf& buf) {
    assert(buf.c_str() == nullptr && buf.size() == 0);
    File file(path);
    if (file.is_file() == false || static_cast<long long unsigned int>(file.size()) > SSIZE_MAX) {
        return;
    }
    auto out = file::allocate(nullptr, file.size() + 1);
    if (file.size() == 0) {
        buf.grab(out, 0);
        return;
    }
    auto handle = file::open(file.filename(), "rb");
    if (handle == nullptr) {
        free(out);
        return;
    }
    else if (fread(out, 1, static_cast<size_t>(file.size()), handle) != static_cast<size_t>(file.size())) {
        fclose(handle);
        free(out);
        return;
    }
    fclose(handle);
    buf.grab(out, file.size());
}
static void _read_dir_rec(Files& res, Files& files) {
    for (auto& file : files) {
        res.push_back(file);
        if (file.is_dir() == true && file.is_link() == false) {
            auto v = file::read_dir(file.filename());
            file::_read_dir_rec(res, v);
        }
    }
}
static std::string& _replace_all(std::string& string, const std::string& find, const std::string& replace) {
    if (find.empty() == true) {
        return string;
    }
    size_t start = 0;
    while ((start = string.find(find, start)) != std::string::npos) {
        string.replace(start, find.length(), replace);
        start += replace.length();
    }
    return string;
}
static void _split_paths(const std::string& filename, std::string& path, std::string& name, std::string& ext) {
    path = "";
    name = "";
    ext  = "";
    if (filename == "") {
        return;
    }
#ifdef _WIN32
    auto sep = '/';
    if (filename.find("\\\\") == 0) {
        sep = '\\';
        if (filename.back() == '\\') {
            return;
        }
    }
    auto pos1 = filename.find_last_of(sep);
    if (pos1 != std::string::npos) {
        if (filename.length() != 3) {
            path = file::_substr(filename, 0, pos1);
        }
        name = file::_substr(filename, pos1 + 1);
    }
    auto pos2 = name.find_last_of('.');
    if (pos2 != std::string::npos && pos2 != 0) {
        ext = file::_substr(name, pos2 + 1);
    }
    if (path.back() == ':') {
        path += sep;
        return;
    }
#else
    auto pos1 = filename.find_last_of('/');
    if (pos1 != std::string::npos) {
        if (pos1 > 0) {
            path = file::_substr(filename, 0, pos1);
        }
        else if (filename != "/") {
            path = "/";
        }
        if (filename != "/") {
            name = file::_substr(filename, pos1 + 1);
        }
    }
    auto pos2 = filename.find_last_of('.');
    if (pos2 != std::string::npos && pos2 > pos1 + 1) {
        ext = file::_substr(filename, pos2 + 1);
    }
#endif
}
static std::string _substr(const std::string& in, std::string::size_type pos, std::string::size_type count) {
    try { return in.substr(pos, count); }
    catch(...) { return ""; }
}
#ifdef _WIN32
static int64_t _time(FILETIME* ft) {
    int64_t res = static_cast<int64_t>(ft->dwHighDateTime) << 32 | static_cast<int64_t>(ft->dwLowDateTime);
    res = res / 10000000;
    res = res - 11644473600;
    return res;
}
#endif
static std::string _to_absolute_path(const std::string& filename, bool realpath) {
    std::string res;
    auto name = filename;
#ifdef _WIN32
    if (
        (name.find("\\\\.\\") == 0 || name.find("\\\\?\\") == 0) &&
        name.length() > 5 &&
        name[5] == ':' &&
        ((name[4] >= 'a' && name[4] <= 'z') ||
        (name[4] >= 'A' && name[4] <= 'Z'))
    ) {
        res = name.substr(4);
    }
    else if (name.find("\\\\") == 0) {
        return name;
    }
    else if (name.size() < 2 || name[1] != ':') {
        auto work = File(file::work_dir());
        res = work.filename();
        res += "\\";
        res += name;
    }
    else {
        res = name;
    }
    file::_replace_all(res, "\\", "/");
    auto len = res.length();
    file::_replace_all(res, "//", "/");
    while (len > res.length()) {
        len = res.length();
        file::_replace_all(res, "//", "/");
    }
    while (res.size() > 3 && res.back() == '/') {
        res.pop_back();
    }
#else
    if (name[0] != '/') {
        auto work = File(file::work_dir());
        res = work.filename();
        res += "/";
        res += name;
    }
    else {
        res = name;
    }
    auto len = res.length();
    file::_replace_all(res, "//", "/");
    while (len > res.length()) {
        len = res.length();
        file::_replace_all(res, "//", "/");
    }
    while (res.size() > 1 && res.back() == '/') {
        res.pop_back();
    }
#endif
    return (realpath == true) ? file::canonical(res).filename() : res;
}
#ifdef _WIN32
static wchar_t* _to_wide(const char* string) {
    auto out_len = MultiByteToWideChar(CP_UTF8, 0, string , -1, nullptr , 0);
    auto out     = reinterpret_cast<wchar_t*>(file::allocate(nullptr, out_len * sizeof(wchar_t) + sizeof(wchar_t)));
    MultiByteToWideChar(CP_UTF8, 0, string , -1, out, out_len);
    return out;
}
#endif
char* allocate(char* resize_or_null, size_t size) {
    void* res = nullptr;
    if (resize_or_null == nullptr) {
        res = calloc(size, 1);
    }
    else {
        res = realloc(resize_or_null, size);
    }
    if (res == nullptr) {
        throw std::string("error: gnu::file::allocate(): memory allocation failed");
    }
    return (char*) res;
}
File canonical(const std::string& path) {
#if defined(_WIN32)
    wchar_t wres[PATH_MAX];
    auto    wpath = file::_to_wide(path.c_str());
    auto    len   = GetFullPathNameW(wpath, PATH_MAX, wres, nullptr);
    if (len > 0 && len < PATH_MAX) {
        auto cpath = file::_from_wide(wres);
        auto res   = File(cpath);
        free(cpath);
        free(wpath);
        return res;
    }
    else {
        free(wpath);
        return File(path);
    }
#else
    auto tmp = realpath(path.c_str(), nullptr);
    auto res = (tmp != nullptr) ? std::string(tmp) : path;
    free(tmp);
    return File(res);
#endif
}
bool chdir(const std::string& path) {
#ifdef _WIN32
    auto wpath = file::_to_wide(path.c_str());
    auto res   = _wchdir(wpath);
    free(wpath);
    return res == 0;
#else
    return ::chdir(path.c_str()) == 0;
#endif
}
std::string check_filename(const std::string& name) {
    static const std::string ILLEGAL = "<>:\"/\\|?*\n\t\r";
    std::string res;
    for (auto& c : name) {
        if (ILLEGAL.find(c) == std::string::npos) {
            res += c;
        }
    }
    return res;
}
bool chmod(const std::string& path, int mode) {
    auto res = false;
    if (mode < 0) {
        return false;
    }
#ifdef _WIN32
    auto wpath = file::_to_wide(path.c_str());
    res = SetFileAttributesW(wpath, mode);
    free(wpath);
#else
    res = ::chmod(path.c_str(), mode) == 0;
#endif
    return res;
}
bool chtime(const std::string& path, int64_t time) {
    auto res = false;
#ifdef _WIN32
    auto wpath  = file::_to_wide(path.c_str());
    auto handle = CreateFileW(wpath, GENERIC_WRITE, FILE_SHARE_READ, nullptr, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, nullptr);
    if (handle != INVALID_HANDLE_VALUE) {
        FILETIME ftLastAccessTime;
        FILETIME ftLastWriteTime;
        auto     lm = (LONGLONG) 0;
        lm = Int32x32To64((time_t) time, 10000000) + 116444736000000000;
        ftLastAccessTime.dwLowDateTime  = (DWORD)lm;
        ftLastAccessTime.dwHighDateTime = lm >> 32;
        ftLastWriteTime.dwLowDateTime   = (DWORD)lm;
        ftLastWriteTime.dwHighDateTime  = lm >> 32;
        res = SetFileTime(handle, nullptr, &ftLastAccessTime, &ftLastWriteTime);
        CloseHandle(handle);
    }
    free(wpath);
#else
    utimbuf ut;
    ut.actime  = (time_t) time;
    ut.modtime = (time_t) time;
    res        = utime(path.c_str(), &ut) == 0;
#endif
    return res;
}
Buf close_stderr() {
    return file::_close_redirect(2);
}
Buf close_stdout() {
    return file::_close_redirect(1);
}
bool copy(const std::string& from, const std::string& to, CallbackCopy cb, void* data, bool flush) {
#ifdef DEBUG
    static const size_t BUF_SIZE = 1024;
#else
    static const size_t BUF_SIZE = 131072;
#endif
    auto file1 = File(from);
    auto file2 = File(to);
    if (file1 == file2) {
        return false;
    }
    auto buf   = file::allocate(nullptr, BUF_SIZE);
    auto read  = file::open(from, "rb");
    auto write = file::open(to, "wb");
    auto count = static_cast<int64_t>(0);
    auto size  = static_cast<size_t>(0);
    if (read == nullptr || write == nullptr) {
        if (read != nullptr) {
            fclose(read);
        }
        if (write != nullptr) {
            fclose(write);
        }
        free(buf);
        return false;
    }
    while ((size = fread(buf, 1, BUF_SIZE, read)) > 0) {
        if (fwrite(buf, 1, size, write) != size) {
            break;
        }
        count += size;
        if (cb != nullptr && cb(file1.size(), count, data) == false && count != file1.size()) {
            break;
        }
    }
    fclose(read);
    if (flush == true) {
        file::flush(write);
    }
    fclose(write);
    free(buf);
    if (count != file1.size()) {
        file::remove(to);
        return false;
    }
    file::chtime(to, file1.mtime());
    file::chmod(to, file1.mode());
    return true;
}
uint64_t fletcher64(const char* buffer, size_t buffer_size) {
    if (buffer == nullptr || buffer_size == 0) {
        return 0;
    }
    auto u8data = reinterpret_cast<const uint8_t*>(buffer);
    auto dwords = static_cast<uint64_t>(buffer_size / 4);
    auto sum1   = static_cast<uint64_t>(0);
    auto sum2   = static_cast<uint64_t>(0);
    auto data32 = reinterpret_cast<const uint32_t*>(u8data);
    auto left   = static_cast<uint64_t>(0);
    for (uint64_t f = 0; f < dwords; ++f) {
        sum1 = (sum1 + data32[f]) % UINT32_MAX;
        sum2 = (sum2 + sum1) % UINT32_MAX;
    }
    left = buffer_size - dwords * 4;
    if (left > 0) {
        auto tmp  = static_cast<uint32_t>(0);
        auto byte = reinterpret_cast<uint8_t*>(&tmp);
        for (auto f = static_cast<uint64_t>(0); f < left; ++f) {
            byte[f] = u8data[dwords * 4 + f];
        }
        sum1 = (sum1 + tmp) % UINT32_MAX;
        sum2 = (sum2 + sum1) % UINT32_MAX;
    }
    return (sum2 << 32) | sum1;
}
void flush(FILE* file) {
    if (file != nullptr) {
#ifdef _WIN32
        auto handle = (HANDLE) _get_osfhandle(_fileno(file));
        if (handle != INVALID_HANDLE_VALUE) {
            FlushFileBuffers(handle);
        }
#else
        fsync(fileno(file));
#endif
    }
}
File home_dir() {
#ifdef _WIN32
    wchar_t wpath[PATH_MAX];
    if (SHGetFolderPathW(nullptr, CSIDL_PROFILE, nullptr, 0, wpath) == S_OK) {
        auto path = file::_from_wide(wpath);
        auto res = File(path);
        free(path);
        return res;
    }
#else
    const char* path = getenv("HOME");
    if (path != nullptr) {
        return File(path);
    }
#endif
    return work_dir();
}
bool is_circular(const std::string& path) {
    auto file = File(path, false);
    if (file.type() != Type::DIR || file.is_link() == false) {
        return false;
    }
    auto l = file.linkname().filename() + "/";
    return file.filename().find(l) == 0;
}
File linkname(const std::string& path) {
#ifdef _WIN32
    auto wpath = file::_to_wide(path.c_str());
    auto hpath = CreateFileW(wpath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);
    if (hpath == INVALID_HANDLE_VALUE) {
        free(wpath);
        return File(path, false);
    }
    auto hlen  = GetFinalPathNameByHandleW(hpath, NULL, 0, FILE_NAME_OPENED);
    if (hlen == 0) {
        CloseHandle(hpath);
        free(wpath);
        return File(path, false);
    }
    auto rpath = static_cast<wchar_t*>(malloc(sizeof(wchar_t) * hlen + 10));
    GetFinalPathNameByHandleW(hpath, rpath, hlen, FILE_NAME_OPENED);
    auto upath = file::_from_wide(rpath);
    auto res   = File(upath, true);
    CloseHandle(hpath);
    free(wpath);
    free(rpath);
    free(upath);
    return res;
#else
    char tmp[PATH_MAX + 1];
    auto tmp_size = readlink(path.c_str(), tmp, PATH_MAX);
    if (tmp_size < 0 || tmp_size >= PATH_MAX) {
        return File(path, true);
    }
    tmp[tmp_size] = 0;
    if (*tmp == '/') {
        return File(tmp, true);
    }
    else {
        auto parent = File(path, false).path();
        return File(parent + "/" + tmp, true);
    }
#endif
}
bool mkdir(const std::string& path) {
    bool res = false;
#ifdef _WIN32
    auto wpath = file::_to_wide(path.c_str());
    res = _wmkdir(wpath) == 0;
    free(wpath);
#else
    res = ::mkdir(path.c_str(), file::DEFAULT_DIR_MODE) == 0;
#endif
    return res;
}
FILE* open(const std::string& path, const std::string& mode) {
    FILE* res = nullptr;
#ifdef _WIN32
    auto wpath = file::_to_wide(path.c_str());
    auto wmode = file::_to_wide(mode.c_str());
    res = _wfopen(wpath, wmode);
    free(wpath);
    free(wmode);
#else
    res = fopen(path.c_str(), mode.c_str());
#endif
    return res;
}
std::string os() {
#if defined(_WIN32)
    return "windows";
#elif defined(__APPLE__)
    return "macos";
#elif defined(__linux__)
    return "linux";
#elif defined(__unix__)
    return "unix";
#else
    return "unknown";
#endif
}
FILE* popen(const std::string& cmd, bool write) {
    FILE* file = nullptr;
#ifdef _WIN32
    auto wpath = file::_to_wide(cmd.c_str());
    auto wmode = file::_to_wide(write ? "wb" : "rb");
    file = _wpopen(wpath, wmode);
    free(wpath);
    free(wmode);
#else
    ::fflush(nullptr);
    file = ::popen(cmd.c_str(), (write == true) ? "w" : "r");
#endif
    return file;
}
Buf read(const std::string& path) {
    Buf buf;
    file::_read(path, buf);
    return buf;
}
Buf* read2(const std::string& path) {
    auto buf = new Buf();
    file::_read(path, *buf);
    return buf;
}
Files read_dir(const std::string& path) {
    auto file = File(path, false);
    auto res  = Files();
    if (file.type() != Type::DIR || file::is_circular(path) == true) {
        return res;
    }
#ifdef _WIN32
    auto wpath = file::_to_wide(file.filename().c_str());
    auto dirp  = _wopendir(wpath);
    auto sep   = '/';
    if (file.filename().find("\\\\") == 0) {
        sep = '\\';
    }
    if (dirp != nullptr) {
        auto entry = _wreaddir(dirp);
        while (entry != nullptr) {
            auto cpath = file::_from_wide(entry->d_name);
            if (strcmp(cpath, ".") != 0 && strcmp(cpath, "..") != 0) {
                auto name = (file.name() == ".") ? file.path() + sep + cpath : file.filename() + sep + cpath;
                res.push_back(File(name));
            }
            free(cpath);
            entry = _wreaddir(dirp);
        }
        _wclosedir(dirp);
    }
    free(wpath);
#else
    auto dirp = ::opendir(file.filename().c_str());
    if (dirp != nullptr) {
        auto entry = ::readdir(dirp);
        while (entry != nullptr) {
            if (strcmp(entry->d_name, ".") != 0 && strcmp(entry->d_name, "..") != 0) {
                auto name = (file.name() == ".") ? file.path() + "/" + entry->d_name : file.filename() + "/" + entry->d_name;
                res.push_back(File(name));
            }
            entry = ::readdir(dirp);
        }
        ::closedir(dirp);
    }
#endif
    std::sort(res.begin(), res.end());
    return res;
}
Files read_dir_rec(const std::string& path) {
    auto res   = Files();
    auto files = file::read_dir(path);
    file::_read_dir_rec(res, files);
    return res;
}
bool redirect_stderr() {
    return _open_redirect(2);
}
bool redirect_stdout() {
    return _open_redirect(1);
}
bool remove(const std::string& path) {
    auto f = File(path);
    if (f.type() == Type::MISSING && f.is_link() == false) {
        return false;
    }
    auto res = false;
#ifdef _WIN32
    auto wpath = file::_to_wide(path.c_str());
    if (f.type() == Type::DIR) {
        res = RemoveDirectoryW(wpath);
    }
    else {
        res = DeleteFileW(wpath);
    }
    if (res == false && f.type() == Type::MISSING && f.is_link() == true) {
        res = RemoveDirectoryW(wpath);
    }
    if (res == false) {
        if (f.type() == Type::DIR) {
            file::chmod(path, file::DEFAULT_DIR_MODE);
            res = RemoveDirectoryW(wpath);
        }
        else {
            file::chmod(path, file::DEFAULT_FILE_MODE);
            res = DeleteFileW(wpath);
        }
    }
    free(wpath);
#else
    if (f.type() == Type::DIR && f.is_link() == false) {
        res = ::rmdir(path.c_str()) == 0;
    }
    else {
        res = ::unlink(path.c_str()) == 0;
    }
#endif
    return res;
}
bool remove_rec(const std::string& path) {
    auto file = File(path, true);
    if (file == file::home_dir() || file.path() == "") {
        return false;
    }
    auto files = file::read_dir_rec(path);
    std::reverse(files.begin(), files.end());
    for (const auto& file : files) {
        file::remove(file.filename());
    }
    return file::remove(path);
}
bool rename(const std::string& from, const std::string& to) {
    auto res    = false;
    auto from_f = File(from);
    auto to_f   = File(to);
    if (from_f == to_f) {
        return false;
    }
#ifdef _WIN32
    auto wfrom = file::_to_wide(from_f.filename().c_str());
    auto wto   = file::_to_wide(to_f.filename().c_str());
    if (to_f.type() == Type::DIR) {
        file::remove_rec(to_f.filename());
        res = MoveFileExW(wfrom, wto, MOVEFILE_COPY_ALLOWED | MOVEFILE_WRITE_THROUGH);
    }
    else if (to_f.type() == Type::MISSING) {
        res = MoveFileExW(wfrom, wto, MOVEFILE_COPY_ALLOWED | MOVEFILE_WRITE_THROUGH);
    }
    else {
        res = ReplaceFileW(wto, wfrom, nullptr, REPLACEFILE_WRITE_THROUGH, 0, 0);
    }
    free(wfrom);
    free(wto);
#else
    if (to_f.type() == Type::DIR) {
        file::remove_rec(to_f.filename());
    }
    res = ::rename(from_f.filename().c_str(), to_f.filename().c_str()) == 0;
#endif
    return res;
}
int run(const std::string& cmd, bool background, bool hide_win32_window) {
#ifdef _WIN32
    wchar_t*            cmd_w = file::_to_wide(cmd.c_str());
    STARTUPINFOW        startup_info;
    PROCESS_INFORMATION process_info;
    ZeroMemory(&startup_info, sizeof(STARTUPINFOW));
    ZeroMemory(&process_info, sizeof(PROCESS_INFORMATION));
    startup_info.cb          = sizeof(STARTUPINFOW);
    startup_info.dwFlags     = STARTF_USESHOWWINDOW;
    startup_info.wShowWindow = (hide_win32_window == true) ? SW_HIDE : SW_SHOW;
    if (CreateProcessW(nullptr, cmd_w, nullptr, nullptr, false, 0, nullptr, nullptr, &startup_info, &process_info) == 0) {
        free(cmd_w);
        return -1;
    }
    else {
        ULONG rc = 0;
        if (background == false) {
            WaitForSingleObject(process_info.hProcess, INFINITE);
            GetExitCodeProcess(process_info.hProcess, &rc);
        }
        CloseHandle(process_info.hThread);
        CloseHandle(process_info.hProcess);
        free(cmd_w);
        return (int) rc;
    }
#else
    (void) hide_win32_window;
    auto cmd2 = cmd;
    if (background == true) {
        cmd2 += " 2>&1 > /dev/null &";
    }
    return system(cmd2.c_str());
#endif
}
File tmp_dir() {
    try {
#if defined(_WIN32)
        auto path = std::filesystem::temp_directory_path();
        auto utf  = file::_from_wide(path.c_str());
        auto res = File(utf);
        free(utf);
        return res;
#elif defined(__APPLE__)
        return File("/tmp");
#else
        auto path = std::filesystem::temp_directory_path();
        return File(path);
#endif
    }
    catch(...) {
    }
    return file::work_dir();
}
File tmp_file(const std::string& prepend) {
    char buf[100];
    snprintf(buf, 100, "%u", file::_rand());
    std::string res = prepend + buf;
    return File(tmp_dir().filename() + "/" + res);
}
File work_dir() {
#ifdef _WIN32
    auto wpath = _wgetcwd(nullptr, 0);
    if (wpath != nullptr) {
        auto path = file::_from_wide(wpath);
        auto res  = File(path);
        free(wpath);
        free(path);
        return res;
    }
#else
    auto path = getcwd(nullptr, 0);
    if (path != nullptr) {
        auto res = File(path);
        free(path);
        return res;
    }
#endif
    return File(".");
}
bool write(const std::string& path, const char* buffer, size_t size, bool flush) {
    if (File(path).type() == Type::DIR) {
        return false;
    }
    auto tmpfile = path + ".~tmp";
    auto file    = file::open(tmpfile, "wb");
    if (file == nullptr) {
        return false;
    }
    auto wrote = fwrite(buffer, 1, size, file);
    if (flush == true) {
        file::flush(file);
    }
    fclose(file);
    if (wrote != size) {
        file::remove(tmpfile);
        return false;
    }
    else if (file::rename(tmpfile, path) == false) {
        file::remove(tmpfile);
        return false;
    }
    return true;
}
bool write(const std::string& path, const Buf& buf, bool flush) {
    return write(path, buf.c_str(), buf.size(), flush);
}
Buf::Buf(size_t size) {
    if (size == (size_t) -1) {
        throw std::string("error: gnu::file::Buf(): size out of range");
    }
    _str = file::allocate(nullptr, size + 1);
    _size = size;
}
Buf::Buf(const char* buffer, size_t size) {
    if (size == (size_t) -1) {
        throw std::string("error: gnu::file::Buf(): size out of range");
    }
    if (buffer == nullptr) {
        _str  = nullptr;
        _size = 0;
    }
    else {
        _str  = file::allocate(nullptr, size + 1);
        _size = size;
        std::memcpy(_str, buffer, size);
    }
}
Buf::Buf(const Buf& b) {
    if (b._str == nullptr) {
        _str  = nullptr;
        _size = 0;
    }
    else {
        _str  = file::allocate(nullptr, b._size + 1);
        _size = b._size;
        std::memcpy(_str, b._str, b._size);
    }
}
bool Buf::operator==(const Buf& other) const {
    return _str != nullptr && _size == other._size && std::memcmp(_str, other._str, _size) == 0;
}
Buf& Buf::add(const char* buffer, size_t size) {
    if (size == (size_t) -1) {
        throw std::string("error: gnu::file::Buf:add(): size out of range");
    }
    if (_str == buffer || buffer == nullptr) {
    }
    else if (_str == nullptr) {
        _str = file::allocate(nullptr, size + 1);
        std::memcpy(_str, buffer, size);
        _size = size;
    }
    else if (size > 0) {
        auto t = file::allocate(nullptr, _size + size + 1);
        std::memcpy(t, _str, _size);
        std::memcpy(t + _size, buffer, size);
        free(_str);
        _str = t;
        _size += size;
    }
    return *this;
}
std::array<size_t, 257> Buf::Count(const char* buffer, size_t size) {
    size_t max_line     = 0;
    size_t current_line = 0;
    auto   count        = std::array<size_t, 257>{0};
    if (buffer == nullptr) {
        return count;
    }
    for (size_t f = 0; f < size; f++) {
        auto c = (unsigned char) buffer[f];
        count[c] += 1;
        if (current_line > max_line) {
            max_line = current_line;
        }
        if (c == 0 ||c == 10 || c == 13) {
            current_line = 0;
        }
        else {
            current_line++;
        }
    }
    count[256] = max_line;
    return count;
}
Buf Buf::InsertCR(const char* buffer, size_t size, bool dos, bool trailing) {
    if (size == (size_t) -1) {
        throw std::string("error: gnu::file::Buf::InsertCR(): size out of range");
    }
    else if (buffer == nullptr || size == 0 || (trailing == false && dos == false)) {
        return Buf();
    }
    auto res_size = size;
    if (dos == true) {
        for (size_t f = 0; f < size; f++) {
            res_size += (buffer[f] == '\n');
        }
    }
    auto res     = file::allocate(nullptr, res_size + 1);
    auto restart = std::string::npos;
    auto res_pos = (size_t) 0;
    auto p       = (unsigned char) 0;
    for (size_t f = 0; f < size; f++) {
        auto c = (unsigned char) buffer[f];
        if (trailing == true) {
            if (c == '\n') {
                if (restart != std::string::npos) {
                    res_pos = restart;
                }
                restart = std::string::npos;
            }
            else if (restart == std::string::npos && (c == ' ' || c == '\t')) {
                restart = res_pos;
            }
            else if (c != ' ' && c != '\t') {
                restart = std::string::npos;
            }
        }
        if (dos == true && c == '\n' && p != '\r') {
            res[res_pos++] = '\r';
        }
        res[res_pos++] = c;
        p = c;
    }
    res[res_pos] = 0;
    if (restart != std::string::npos) {
        res[restart] = 0;
        res_pos = restart;
    }
    return Buf::Grab(res, res_pos);
}
Buf Buf::RemoveCR(const char* buffer, size_t size) {
    auto res = Buf(size);
    for (size_t f = 0, e = 0; f < size; f++) {
        auto c = buffer[f];
        if (c != 13) {
            res._str[e++] = c;
        }
        else {
            res._size--;
        }
    }
    return res;
}
Buf& Buf::set(const char* buffer, size_t size) {
    if (size == (size_t) -1) {
        throw std::string("error: gnu::file::Buf:set(): size out of range");
    }
    if (_str == buffer) {
    }
    else if (buffer == nullptr) {
        free(_str);
        _str = nullptr;
        _size = 0;
    }
    else {
        free(_str);
        _str = file::allocate(nullptr, size + 1);
        _size = size;
        std::memcpy(_str, buffer, size);
    }
    return *this;
}
bool Buf::write(const std::string& path, bool flush) const {
    return file::write(path, _str, _size, flush);
}
File::File(const std::string& path, bool realpath) {
    _ctime = -1;
    _link  = false;
    _mode  = -1;
    _mtime = -1;
    _size  = -1;
    _type  = Type::MISSING;
    if (path != "") {
        _filename = file::_to_absolute_path(path, realpath);
        file::_split_paths(_filename, _path, _name, _ext);
    }
    else {
        return;
    }
#ifdef _WIN32
    auto wpath = file::_to_wide(_filename.c_str());
    WIN32_FILE_ATTRIBUTE_DATA attr;
    if (GetFileAttributesExW(wpath, GetFileExInfoStandard, &attr) != 0) {
        if (attr.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
            _type = Type::DIR;
            _size = 0;
        }
        else {
            _type = Type::FILE;
            _size = (attr.nFileSizeHigh * 4294967296) + attr.nFileSizeLow;
        }
        _mtime = file::_time(&attr.ftLastWriteTime);
        _ctime = file::_time(&attr.ftCreationTime);
        if (attr.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) {
            _link = true;
            HANDLE handle = CreateFileW(wpath, 0, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_BACKUP_SEMANTICS, NULL);
            if (handle != INVALID_HANDLE_VALUE) {
                _size = GetFileSize(handle, NULL);
                FILETIME ftCreationTime;
                FILETIME ftLastAccessTime;
                FILETIME ftLastWriteTime;
                if (GetFileTime(handle, &ftCreationTime, &ftLastAccessTime, &ftLastWriteTime) != 0) {
                    _mtime = file::_time(&ftLastWriteTime);
                    _ctime = file::_time(&ftCreationTime);
                }
                CloseHandle(handle);
                if (realpath == true) {
                    _filename = file::linkname(_filename).filename();
                    file::_split_paths(_filename, _path, _name, _ext);
                }
            }
            else {
                _size = -1;
                _type = Type::MISSING;
            }
        }
    }
    free(wpath);
#else
    struct stat st;
    char        tmp[PATH_MAX + 1];
    if (::stat(_filename.c_str(), &st) == 0) {
        _size  = st.st_size;
        _ctime = st.st_ctime;
        _mtime = st.st_mtime;
        if (S_ISDIR(st.st_mode)) {
            _type = Type::DIR;
        }
        else if (S_ISREG(st.st_mode)) {
            _type = Type::FILE;
        }
        else {
            _type = Type::OTHER;
        }
        snprintf(tmp, PATH_MAX, "%o", st.st_mode);
        auto l = strlen(tmp);
        if (l > 2) {
            _mode = strtol(tmp + (l - 3), nullptr, 8);
        }
        if (lstat(_filename.c_str(), &st) == 0 && S_ISLNK(st.st_mode)) {
            _link = true;
        }
    }
    else {
        auto tmp_size = readlink(_filename.c_str(), tmp, PATH_MAX);
        if (tmp_size > 0 && tmp_size < PATH_MAX) {
            _link = true;
        }
    }
#endif
    if (_type == Type::DIR) {
        _ext = "";
    }
}
std::string File::name_without_ext() const {
    try {
        if (_type != Type::DIR) {
            auto dot = _name.find_last_of(".");
            return (dot == std::string::npos) ? _name : _name.substr(0, dot);
        }
        else {
            return _name;
        }
    }
    catch(...) {
        return _name;
    }
}
std::string File::to_string(bool short_version) const {
    char tmp[PATH_MAX + 100];
    int n = 0;
    if (short_version == true) {
        n = snprintf(tmp, PATH_MAX + 100, "File(filename=%s, type=%s, %ssize=%lld, mtime=%lld)",
            _filename.c_str(),
            type_name().c_str(),
            _link ? "LINK, " : "",
            (long long int) _size,
            (long long int) _mtime);
    }
    else {
        n = snprintf(tmp, PATH_MAX + 100, "File(filename=%s, name=%s, ext=%s, path=%s, type=%s, link=%s, size=%lld, mtime=%lld, mode=%o)",
            _filename.c_str(),
            _name.c_str(),
            _ext.c_str(),
            _path.c_str(),
            type_name().c_str(),
            _link ? "YES" : "NO",
            (long long int) _size,
            (long long int) _mtime,
            _mode > 0 ? _mode : 0);
    }
    return (n > 0 && n < PATH_MAX + 100) ? tmp : "";
}
std::string File::type_name() const {
    static std::string NAMES[] = { "Missing", "Directory", "File", "Other", "", };
    return NAMES[static_cast<size_t>(_type)];
}
}
}
#include <algorithm>
#include <cstdint>
#include <assert.h>
#include <stdarg.h>
#include <time.h>
#include <FL/Fl_Window.H>
#include <FL/Fl_File_Chooser.H>
#include <FL/Fl_Hold_Browser.H>
#include <FL/Fl_Tooltip.H>
#include <FL/fl_ask.H>
#include <FL/fl_draw.H>
#include <FL/Fl_SVG_Image.H>
#ifdef _WIN32
    #include <FL/x.H>
    #include <windows.h>
#else
    #include <unistd.h>
#endif
#ifdef FLW_USE_PNG
    #include <FL/Fl_PNG_Image.H>
    #include <FL/fl_draw.H>
#endif
namespace flw {
std::vector<char*>          PREF_FONTNAMES;
int                         PREF_FIXED_FONT         = FL_COURIER;
std::string                 PREF_FIXED_FONTNAME     = "FL_COURIER";
int                         PREF_FIXED_FONTSIZE     = 14;
int                         PREF_FONT               = FL_HELVETICA;
int                         PREF_FONTSIZE           = 14;
std::string                 PREF_FONTNAME           = "FL_HELVETICA";
double                      PREF_SCALE_VAL          = 1.0;
bool                        PREF_SCALE_ON           = true;
std::string                 PREF_THEME              = "default";
const StringVector PREF_THEMES = {
    "default",
    "gleam",
    "blue gleam",
    "dark gleam",
    "tan gleam",
    "gtk",
    "blue gtk",
    "dark gtk",
    "tan gtk",
    "oxy",
    "tan oxy",
    "plastic",
    "tan plastic",
};
const StringVector PREF_THEMES2 = {
    "default",
    "gleam",
    "blue_gleam",
    "dark_gleam",
    "tan_gleam",
    "gtk",
    "blue_gtk",
    "dark_gtk",
    "tan_gtk",
    "oxy",
    "tan_oxy",
    "plastic",
    "tan_plastic",
};
namespace priv {
static unsigned char _OLD_R[256]  = { 0 };
static unsigned char _OLD_G[256]  = { 0 };
static unsigned char _OLD_B[256]  = { 0 };
static bool          _IS_DARK     = false;
static bool          _SAVED_COLOR = false;
static int           _SCROLLSIZE  = Fl::scrollbar_size();
static std::string _print(
    const std::string& ps_filename,
    Fl_Paged_Device::Page_Format format,
    Fl_Paged_Device::Page_Layout layout,
    PrintCallback cb,
    void* data,
    int from,
    int to) {
    bool                      cont = true;
    FILE*                     file = nullptr;
    Fl_PostScript_File_Device printer;
    int                       ph;
    int                       pw;
    std::string               res;
    if ((file = fl_fopen(ps_filename.c_str(), "wb")) == nullptr) {
        return "Error: could not open file!";
    }
    printer.begin_job(file, 0, format, layout);
    while (cont == true) {
        if (printer.begin_page() != 0) {
            res = "Error: couldn't create new page!";
            goto ERR;
        }
        if (printer.printable_rect(&pw, &ph) != 0) {
            res = "Error: couldn't retrieve page size!";
            goto ERR;
        }
        fl_push_clip(0, 0, pw, ph);
        cont = cb(data, pw, ph, from);
        fl_pop_clip();
        if (printer.end_page() != 0) {
            res = "Error: couldn't end page!";
            goto ERR;
        }
        if (from > 0) {
            from++;
            if (from > to) {
                cont = false;
            }
        }
    }
ERR:
    printer.end_job();
    fclose(file);
    return res;
}
static void _additional_colors(bool dark) {
    color::BEIGE            = fl_rgb_color(245, 245, 220);
    color::CHOCOLATE        = fl_rgb_color(210, 105,  30);
    color::CRIMSON          = fl_rgb_color(220,  20,  60);
    color::DARKOLIVEGREEN   = fl_rgb_color( 85, 107,  47);
    color::DODGERBLUE       = fl_rgb_color( 30, 144, 255);
    color::FORESTGREEN      = fl_rgb_color( 34, 139,  34);
    color::GOLD             = fl_rgb_color(255, 215,   0);
    color::GRAY             = fl_rgb_color(128, 128, 128);
    color::INDIGO           = fl_rgb_color( 75,   0, 130);
    color::OLIVE            = fl_rgb_color(128, 128,   0);
    color::PINK             = fl_rgb_color(255, 192, 203);
    color::ROYALBLUE        = fl_rgb_color( 65, 105, 225);
    color::SIENNA           = fl_rgb_color(160,  82,  45);
    color::SILVER           = fl_rgb_color(192, 192, 192);
    color::SLATEGRAY        = fl_rgb_color(112, 128, 144);
    color::TEAL             = fl_rgb_color(  0, 128, 128);
    color::TURQUOISE        = fl_rgb_color( 64, 224, 208);
    color::VIOLET           = fl_rgb_color(238, 130, 238);
    if (dark == true) {
        color::BEIGE            = fl_darker(color::BEIGE);
        color::CHOCOLATE        = fl_darker(color::CHOCOLATE);
        color::CRIMSON          = fl_darker(color::CRIMSON);
        color::DARKOLIVEGREEN   = fl_darker(color::DARKOLIVEGREEN);
        color::DODGERBLUE       = fl_darker(color::DODGERBLUE);
        color::FORESTGREEN      = fl_darker(color::FORESTGREEN);
        color::GOLD             = fl_darker(color::GOLD);
        color::GRAY             = fl_darker(color::GRAY);
        color::INDIGO           = fl_darker(color::INDIGO);
        color::OLIVE            = fl_darker(color::OLIVE);
        color::PINK             = fl_darker(color::PINK);
        color::ROYALBLUE        = fl_darker(color::ROYALBLUE);
        color::SIENNA           = fl_darker(color::SIENNA);
        color::SILVER           = fl_darker(color::SILVER);
        color::SLATEGRAY        = fl_darker(color::SLATEGRAY);
        color::TEAL             = fl_darker(color::TEAL);
        color::TURQUOISE        = fl_darker(color::TURQUOISE);
        color::VIOLET           = fl_darker(color::VIOLET);
    }
}
static void _blue_colors() {
    Fl::set_color(0,   228, 228, 228);
    Fl::set_color(7,    79,  86,  94);
    Fl::set_color(8,   108, 113, 125);
    Fl::set_color(15,  241, 196,  126);
    Fl::set_color(56,    0,   0,   0);
    Fl::background(48, 56, 65);
    unsigned char r = 0;
    unsigned char g = 0;
    unsigned char b = 0;
    for (int f = 32; f < 49; f++) {
        Fl::set_color(f, r, g, b);
        if (f == 32) {
            r = 0;
            g = 9;
            b = 18;
        }
        else {
            r += 2 + (f < 44);
            g += 2 + (f < 44);
            b += 2 + (f < 44);
        }
    }
}
static void _dark_colors() {
    Fl::set_color(0,   200, 200, 200);
    Fl::set_color(7,    64,  64,  64);
    Fl::set_color(8,   100, 100, 100);
    Fl::set_color(15,  177, 227, 177);
    Fl::set_color(56,    0,   0,   0);
    Fl::set_color(49, 43, 43, 43);
    Fl::background(43, 43, 43);
    unsigned char c = 0;
    for (int f = 32; f < 49; f++) {
        Fl::set_color(f, c, c, c);
        c += 2;
        if (f > 40) c++;
    }
}
static void _make_default_colors_darker() {
    Fl::set_color(FL_GREEN, fl_darker(Fl::get_color(FL_GREEN)));
    Fl::set_color(FL_DARK_GREEN, fl_darker(Fl::get_color(FL_DARK_GREEN)));
    Fl::set_color(FL_RED, fl_darker(Fl::get_color(FL_RED)));
    Fl::set_color(FL_DARK_RED, fl_darker(Fl::get_color(FL_DARK_RED)));
    Fl::set_color(FL_YELLOW, fl_darker(Fl::get_color(FL_YELLOW)));
    Fl::set_color(FL_DARK_YELLOW, fl_darker(Fl::get_color(FL_DARK_YELLOW)));
    Fl::set_color(FL_BLUE, fl_darker(Fl::get_color(FL_BLUE)));
    Fl::set_color(FL_DARK_BLUE, fl_darker(Fl::get_color(FL_DARK_BLUE)));
    Fl::set_color(FL_CYAN, fl_darker(Fl::get_color(FL_CYAN)));
    Fl::set_color(FL_DARK_CYAN, fl_darker(Fl::get_color(FL_DARK_CYAN)));
    Fl::set_color(FL_MAGENTA, fl_darker(Fl::get_color(FL_MAGENTA)));
    Fl::set_color(FL_DARK_MAGENTA, fl_darker(Fl::get_color(FL_DARK_MAGENTA)));
}
static void _restore_colors() {
    if (_SAVED_COLOR == true) {
        for (int f = 0; f < 256; f++) {
            Fl::set_color(f, priv::_OLD_R[f], priv::_OLD_G[f], priv::_OLD_B[f]);
        }
    }
}
static void _save_colors() {
    if (_SAVED_COLOR == false) {
        for (int f = 0; f < 256; f++) {
            unsigned char r1, g1, b1;
            Fl::get_color(f, r1, g1, b1);
            priv::_OLD_R[f] = r1;
            priv::_OLD_G[f] = g1;
            priv::_OLD_B[f] = b1;
        }
        _SAVED_COLOR = true;
    }
}
static void _tan_colors() {
    Fl::set_color(0,     0,   0,   0);
    Fl::set_color(7,   255, 255, 255);
    Fl::set_color(8,    85,  85,  85);
    Fl::set_color(15,  188, 114,  50);
    Fl::background(206, 202, 187);
}
void _load_default() {
    priv::_save_colors();
    priv::_restore_colors();
    priv::_additional_colors(false);
    Fl::scheme("none");
    Fl::redraw();
    flw::PREF_THEME = flw::PREF_THEMES[priv::THEME_DEFAULT];
    _IS_DARK = false;
}
void _load_gleam() {
    priv::_save_colors();
    priv::_restore_colors();
    priv::_additional_colors(false);
    Fl::scheme("gleam");
    Fl::redraw();
    flw::PREF_THEME = flw::PREF_THEMES[priv::THEME_GLEAM];
    _IS_DARK = false;
}
void _load_gleam_blue() {
    priv::_save_colors();
    priv::_restore_colors();
    priv::_make_default_colors_darker();
    priv::_blue_colors();
    priv::_additional_colors(true);
    Fl::set_color(255, 101, 117, 125);
    Fl::scheme("gleam");
    Fl::redraw();
    flw::PREF_THEME = flw::PREF_THEMES[priv::THEME_GLEAM_BLUE];
    _IS_DARK = true;
}
void _load_gleam_dark() {
    priv::_save_colors();
    priv::_restore_colors();
    priv::_make_default_colors_darker();
    priv::_dark_colors();
    priv::_additional_colors(true);
    Fl::set_color(255, 112, 112, 112);
    Fl::scheme("gleam");
    Fl::redraw();
    flw::PREF_THEME = flw::PREF_THEMES[priv::THEME_GLEAM_DARK];
    _IS_DARK = true;
}
void _load_gleam_tan() {
    priv::_save_colors();
    priv::_restore_colors();
    priv::_tan_colors();
    priv::_additional_colors(false);
    Fl::scheme("gleam");
    Fl::redraw();
    flw::PREF_THEME = flw::PREF_THEMES[priv::THEME_GLEAM_TAN];
    _IS_DARK = false;
}
void _load_gtk() {
    priv::_save_colors();
    priv::_restore_colors();
    priv::_additional_colors(false);
    Fl::scheme("gtk+");
    Fl::redraw();
    flw::PREF_THEME = flw::PREF_THEMES[priv::THEME_GTK];
    _IS_DARK = false;
}
void _load_gtk_blue() {
    priv::_save_colors();
    priv::_restore_colors();
    priv::_make_default_colors_darker();
    priv::_blue_colors();
    priv::_additional_colors(true);
    Fl::set_color(255, 101, 117, 125);
    Fl::scheme("gtk+");
    Fl::redraw();
    flw::PREF_THEME = flw::PREF_THEMES[priv::THEME_GTK_BLUE];
    _IS_DARK = true;
}
void _load_gtk_dark() {
    priv::_save_colors();
    priv::_restore_colors();
    priv::_make_default_colors_darker();
    priv::_dark_colors();
    priv::_additional_colors(true);
    Fl::set_color(255, 112, 112, 112);
    Fl::scheme("gtk+");
    Fl::redraw();
    flw::PREF_THEME = flw::PREF_THEMES[priv::THEME_GTK_DARK];
    _IS_DARK = true;
}
void _load_gtk_tan() {
    priv::_save_colors();
    priv::_restore_colors();
    priv::_tan_colors();
    priv::_additional_colors(false);
    Fl::scheme("gtk+");
    Fl::redraw();
    flw::PREF_THEME = flw::PREF_THEMES[priv::THEME_GTK_TAN];
    _IS_DARK = false;
}
void _load_oxy() {
    priv::_save_colors();
    priv::_restore_colors();
    priv::_additional_colors(false);
    Fl::scheme("oxy");
    Fl::redraw();
    flw::PREF_THEME = flw::PREF_THEMES[priv::THEME_OXY];
    _IS_DARK = false;
}
void _load_oxy_tan() {
    priv::_save_colors();
    priv::_restore_colors();
    priv::_tan_colors();
    priv::_additional_colors(false);
    Fl::scheme("oxy");
    Fl::redraw();
    flw::PREF_THEME = flw::PREF_THEMES[priv::THEME_OXY_TAN];
    _IS_DARK = false;
}
void _load_plastic() {
    priv::_save_colors();
    priv::_restore_colors();
    priv::_additional_colors(false);
    Fl::scheme("plastic");
    Fl::redraw();
    flw::PREF_THEME = flw::PREF_THEMES[priv::THEME_PLASTIC];
    _IS_DARK = false;
}
void _load_plastic_tan() {
    priv::_save_colors();
    priv::_restore_colors();
    priv::_tan_colors();
    priv::_additional_colors(false);
    Fl::scheme("plastic");
    Fl::redraw();
    flw::PREF_THEME = flw::PREF_THEMES[priv::THEME_PLASTIC_TAN];
    _IS_DARK = false;
}
void _scrollbar() {
    if (flw::PREF_FONTSIZE < 12 || flw::PREF_FONTSIZE > 16) {
        auto f = (double) flw::PREF_FONTSIZE / 14.0;
        auto s = (int) (f * priv::_SCROLLSIZE);
        Fl::scrollbar_size(s);
    }
    else if (priv::_SCROLLSIZE > 0) {
        Fl::scrollbar_size(priv::_SCROLLSIZE);
    }
}
}
Fl_Color color::BEIGE            = fl_rgb_color(245, 245, 220);
Fl_Color color::CHOCOLATE        = fl_rgb_color(210, 105,  30);
Fl_Color color::CRIMSON          = fl_rgb_color(220,  20,  60);
Fl_Color color::DARKOLIVEGREEN   = fl_rgb_color( 85, 107,  47);
Fl_Color color::DODGERBLUE       = fl_rgb_color( 30, 144, 255);
Fl_Color color::FORESTGREEN      = fl_rgb_color( 34, 139,  34);
Fl_Color color::GOLD             = fl_rgb_color(255, 215,   0);
Fl_Color color::GRAY             = fl_rgb_color(128, 128, 128);
Fl_Color color::INDIGO           = fl_rgb_color( 75,   0, 130);
Fl_Color color::OLIVE            = fl_rgb_color(128, 128,   0);
Fl_Color color::PINK             = fl_rgb_color(255, 192, 203);
Fl_Color color::ROYALBLUE        = fl_rgb_color( 65, 105, 225);
Fl_Color color::SIENNA           = fl_rgb_color(160,  82,  45);
Fl_Color color::SILVER           = fl_rgb_color(192, 192, 192);
Fl_Color color::SLATEGRAY        = fl_rgb_color(112, 128, 144);
Fl_Color color::TEAL             = fl_rgb_color(  0, 128, 128);
Fl_Color color::TURQUOISE        = fl_rgb_color( 64, 224, 208);
Fl_Color color::VIOLET           = fl_rgb_color(238, 130, 238);
void debug::print(const Fl_Widget* widget, bool recursive) {
    std::string indent;
    debug::print(widget, indent, recursive);
}
void debug::print(const Fl_Widget* widget, std::string& indent, bool recursive) {
    if (widget == nullptr) {
        puts("flw::debug::print() => null widget");
    }
    else {
        printf("%sx=%4d, y=%4d, w=%4d, h=%4d, X=%4d, Y=%4d, %c, \"%s\"\n",
            indent.c_str(),
            widget->x(),
            widget->y(),
            widget->w(),
            widget->h(),
            widget->x() + widget->w(),
            widget->y() + widget->h(),
            widget->visible() ? 'V' : 'H',
            widget->label() ? widget->label() : "NULL"
        );
        auto group = widget->as_group();
        if (group != nullptr && recursive == true) {
            indent += "\t";
            for (int f = 0; f < group->children(); f++) {
                debug::print(group->child(f), indent);
            }
            indent.pop_back();
        }
    }
    fflush(stdout);
}
bool debug::test(bool val, int line, const char* func) {
    if (val == false) {
        fprintf(stderr, "Error: test failed at line %d in %s\n", line, func);
        fflush(stderr);
        return false;
    }
    return true;
}
bool debug::test(const char* ref, const char* val, int line, const char* func) {
    if (ref == nullptr && val == nullptr) {
        return true;
    }
    else if (ref == nullptr || val == nullptr || strcmp(ref, val) != 0) {
        fprintf(stderr, "Error: test failed '%s' != '%s' at line %d in %s\n", ref ? ref : "NULL", val ? val : "NULL", line, func);
        fflush(stderr);
        return false;
    }
    return true;
}
bool debug::test(int64_t ref, int64_t val, int line, const char* func) {
    if (ref != val) {
        fprintf(stderr, "Error: test failed '%lld' != '%lld' at line %d in %s\n", (long long int) ref, (long long int) val, line, func);
        fflush(stderr);
        return false;
    }
    return true;
}
bool debug::test(double ref, double val, double diff, int line, const char* func) {
    if (fabs(ref - val) > diff) {
        fprintf(stderr, "Error: test failed '%f' != '%f' at line %d in %s\n", ref, val, line, func);
        fflush(stderr);
        return false;
    }
    return true;
}
std::string label::BROWSE   = "&Browse";
std::string label::CANCEL   = "&Cancel";
std::string label::CLOSE    = "Cl&ose";
std::string label::DEL      = "&Delete";
std::string label::DISCARD  = "&Discard";
std::string label::MONO     = "&Mono Font";
std::string label::NEXT     = "&Next";
std::string label::NO       = "&No";
std::string label::OK       = "&Ok";
std::string label::PREV     = "&Previous";
std::string label::PRINT    = "&Print";
std::string label::REGULAR  = "&Regular Font";
std::string label::SAVE     = "&Save";
std::string label::SAVE_DOT = "&Save...";
std::string label::SELECT   = "&Select";
std::string label::UPDATE   = "&Update";
std::string label::YES      = "&Yes";
namespace menu {
static Fl_Menu_Item* _item(Fl_Menu_* menu, const char* text, void* v = nullptr) {
    const Fl_Menu_Item* item;
    if (v == nullptr) {
        assert(menu && text);
        item = menu->find_item(text);
    }
    else {
        item = menu->find_item_with_user_data(v);
    }
#ifdef DEBUG
    if (item == nullptr) fprintf(stderr, "error: cant find menu item <%s>\n", text);
#endif
    return const_cast<Fl_Menu_Item*>(item);
}
}
void menu::enable_item(Fl_Menu_* menu, const char* text, bool value) {
    auto item = _item(menu, text);
    if (item == nullptr) {
        return;
    }
    if (value == true) {
        item->activate();
    }
    else {
        item->deactivate();
    }
}
Fl_Menu_Item* menu::get_item(Fl_Menu_* menu, const char* text) {
    return _item(menu, text);
}
Fl_Menu_Item* menu::get_item(Fl_Menu_* menu, void* v) {
    return _item(menu, nullptr, v);
}
bool menu::item_value(Fl_Menu_* menu, const char* text) {
    auto item = _item(menu, text);
    if (item == nullptr) {
        return false;
    }
    return item->value();
}
void menu::set_item(Fl_Menu_* menu, const char* text, bool value) {
    auto item = _item(menu, text);
    if (item == nullptr) {
        return;
    }
    if (value == true) {
        item->set();
    }
    else {
        item->clear();
    }
}
void menu::setonly_item(Fl_Menu_* menu, const char* text) {
    auto item = _item(menu, text);
    if (item == nullptr) {
        return;
    }
    menu->setonly(item);
}
void util::center_window(Fl_Window* window, Fl_Window* parent) {
    if (parent != nullptr) {
        int x = parent->x() + parent->w() / 2;
        int y = parent->y() + parent->h() / 2;
        window->resize(x - window->w() / 2, y - window->h() / 2, window->w(), window->h());
    }
    else {
        window->resize((Fl::w() / 2) - (window->w() / 2), (Fl::h() / 2) - (window->h() / 2), window->w(), window->h());
    }
}
double util::clock() {
#ifdef _WIN32
    struct timeb timeVal;
    ftime(&timeVal);
    return (double) timeVal.time + (double) (timeVal.millitm / 1000.0);
#else
    struct timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    return (double) (ts.tv_sec) + (ts.tv_nsec / 1000000000.0);
#endif
}
int util::count_decimals(double num) {
    num = fabs(num);
    if (num > 999'999'999'999'999) {
        return 0;
    }
    int    res     = 0;
    char*  end     = 0;
    double inum = static_cast<int64_t>(num);
    double fnum = num - inum;
    char   buffer[400];
    if (num > 9'999'999'999'999) {
        snprintf(buffer, 400, "%.1f", fnum);
    }
    else if (num > 999'999'999'999) {
        snprintf(buffer, 400, "%.2f", fnum);
    }
    else if (num > 99'999'999'999) {
        snprintf(buffer, 400, "%.3f", fnum);
    }
    else if (num > 9'999'999'999) {
        snprintf(buffer, 400, "%.4f", fnum);
    }
    else if (num > 999'999'999) {
        snprintf(buffer, 400, "%.5f", fnum);
    }
    else if (num > 99'999'999) {
        snprintf(buffer, 400, "%.6f", fnum);
    }
    else if (num > 9'999'999) {
        snprintf(buffer, 400, "%.7f", fnum);
    }
    else {
        snprintf(buffer, 400, "%.8f", fnum);
    }
    size_t len = strlen(buffer);
    end = buffer + len - 1;
    while (*end == '0') {
        *end = 0;
        end--;
    }
    res = strlen(buffer) - 2;
    return res;
}
Fl_Widget* util::find_widget(Fl_Group* group, const std::string& label) {
    for (int f = 0; f < group->children(); f++) {
        auto w = group->child(f);
        if (w->label() != nullptr && label == w->label()) {
            return w;
        }
    }
    for (int f = 0; f < group->children(); f++) {
        auto w = group->child(f);
        auto g = w->as_group();
        if (g != nullptr) {
            w = util::find_widget(g, label);
            if (w != nullptr) {
                return w;
            }
        }
    }
    return nullptr;
}
std::string util::fix_menu_string(const std::string& label) {
    std::string res = label;
    util::replace_string(res, "\\", "\\\\");
    util::replace_string(res, "_", "\\_");
    util::replace_string(res, "/", "\\/");
    util::replace_string(res, "&", "&&");
    return res;
}
std::string util::format(const std::string& format, ...) {
    if (format == "") {
        return "";
    }
    int         l   = 128;
    int         n   = 0;
    char*       buf = static_cast<char*>(calloc(l, 1));
    std::string res;
    va_list     args;
    va_start(args, format);
    n = vsnprintf(buf, l, format.c_str(), args);
    va_end(args);
    if (n < 0) {
        free(buf);
        return res;
    }
    if (n < l) {
        res = buf;
        free(buf);
        return res;
    }
    free(buf);
    l = n + 1;
    buf = static_cast<char*>(calloc(l, 1));
    if (buf == nullptr) return res;
    va_start(args, format);
    vsnprintf(buf, l, format.c_str(), args);
    va_end(args);
    res = buf;
    free(buf);
    return res;
}
std::string util::format_double(double num, int decimals, char del) {
    char fr_str[100];
    if (num > 9'007'199'254'740'992.0) {
        return "";
    }
    if (decimals < 0) {
        decimals = util::count_decimals(num);
    }
    if (del < 32) {
        del = 32;
    }
    if (decimals == 0 || decimals > 9) {
        return util::format_int(static_cast<int64_t>(num), del);
    }
    auto fabs_num   = fabs(num + 0.00000001);
    auto int_num    = static_cast<int64_t>(fabs_num);
    auto double_num = static_cast<double>(fabs_num - int_num);
    if (double_num < 0.0000001) {
        double_num = 0.0;
    }
    auto res = util::format_int(int_num, del);
    auto n   = snprintf(fr_str, 100, "%.*f", decimals, double_num);
    if (num < 0.0) {
        res = "-" + res;
    }
    if (n > 0 && n < 100) {
        res += fr_str + 1;
    }
    return res;
}
std::string util::format_int(int64_t num, char del) {
    auto pos = 0;
    char tmp1[32];
    char tmp2[32];
    if (del < 32) {
        del = 32;
    }
    memset(tmp2, 0, 32);
    snprintf(tmp1, 32, "%lld", (long long int) num);
    auto len = strlen(tmp1);
    for (int f = len - 1, i = 0; f >= 0 && pos < 32; f--, i++) {
        char c = tmp1[f];
        if ((i % 3) == 0 && i > 0 && c != '-') {
            tmp2[pos++] = del;
        }
        tmp2[pos++] = c;
    }
    std::string r = tmp2;
    std::reverse(r.begin(), r.end());
    return r;
}
bool util::icon(Fl_Widget* widget, const std::string& svg_image, unsigned max_size) {
    auto svg = (svg_image.length() > 40) ? new Fl_SVG_Image(nullptr, svg_image.c_str()) : nullptr;
    if (svg == nullptr) {
        return false;
    }
    else if (max_size < 16 || max_size > 4096) {
        delete svg;
        return false;
    }
    auto image   = svg->copy();
    auto deimage = image->copy();
    image->scale(max_size, max_size);
    deimage->inactive();
    deimage->scale(max_size, max_size);
    widget->bind_image(image);
    widget->bind_deimage(deimage);
    widget->bind_image(1);
    widget->bind_deimage(1);
    delete svg;
    return true;
}
bool util::is_empty(const std::string& string) {
    bool ctrl   = false;
    bool space  = false;
    bool letter = false;
    for (auto c : string) {
        if (c > 0 && c < 32) {
            ctrl = true;
        }
        else if (c == 32) {
            space = true;
        }
        else {
            letter = true;
        }
    }
    if (ctrl == true) {
        return true;
    }
    else if (space == true && letter == false) {
        return true;
    }
    else if (letter == true) {
        return false;
    }
    else {
        return true;
    }
}
void util::labelfont(Fl_Widget* widget, Fl_Font font, int size) {
    widget->labelfont(font);
    widget->labelsize(size);
    auto group = widget->as_group();
    if (group != nullptr) {
        for (auto f = 0; f < group->children(); f++) {
            util::labelfont(group->child(f), font, size);
        }
    }
}
int64_t util::microseconds() {
#if defined(_WIN32)
    LARGE_INTEGER StartingTime;
    LARGE_INTEGER Frequency;
    QueryPerformanceFrequency(&Frequency);
    QueryPerformanceCounter(&StartingTime);
    StartingTime.QuadPart *= 1000000;
    StartingTime.QuadPart /= Frequency.QuadPart;
    return StartingTime.QuadPart;
#else
    timespec t;
    clock_gettime(CLOCK_MONOTONIC, &t);
    return (t.tv_sec * 1000000 + t.tv_nsec / 1000);
#endif
}
int32_t util::milliseconds() {
#if defined(_WIN32)
    LARGE_INTEGER StartingTime;
    LARGE_INTEGER Frequency;
    QueryPerformanceFrequency(&Frequency);
    QueryPerformanceCounter(&StartingTime);
    StartingTime.QuadPart *= 1000000;
    StartingTime.QuadPart /= Frequency.QuadPart;
    return StartingTime.QuadPart / 1000;
#else
    timespec t;
    clock_gettime(CLOCK_MONOTONIC, &t);
    return (t.tv_sec * 1000000 + t.tv_nsec / 1000) / 1000;
#endif
}
bool util::png_save(Fl_Window* window, const std::string& opt_name, int X, int Y, int W, int H) {
    auto res = false;
#ifdef FLW_USE_PNG
    auto filename = (opt_name == "") ? fl_file_chooser("Save To PNG File", "All Files (*)\tPNG Files (*.png)", "") : opt_name.c_str();
    if (filename != nullptr) {
        window->make_current();
        if (X == 0 && Y == 0 && W == 0 && H == 0) {
            X = window->x();
            Y = window->y();
            W = window->w();
            H = window->h();
        }
        auto image = fl_read_image(nullptr, X, Y, W, H);
        if (image != nullptr) {
            auto ret = fl_write_png(filename, image, W, H);
            if (ret == 0) {
                res = true;
            }
            else if (ret == -1) {
                fl_alert("%s", "Error: missing libraries!");
            }
            else if (ret == -2) {
                fl_alert("Error: failed to save image to %s!", filename);
            }
            delete []image;
        }
        else {
            fl_alert("%s", "Error: failed to grab image!");
        }
    }
#else
    (void) opt_name;
    (void) window;
    (void) X;
    (void) Y;
    (void) W;
    (void) H;
    fl_alert("Error: flw has not been compiled with FLW_USE_PNG flag!");
#endif
    return res;
}
std::string util::print(const std::string& ps_filename, Fl_Paged_Device::Page_Format format, Fl_Paged_Device::Page_Layout layout, PrintCallback cb, void* data) {
    return priv::_print(ps_filename, format, layout, cb, data, 0, 0);
}
std::string util::print(const std::string& ps_filename, Fl_Paged_Device::Page_Format format, Fl_Paged_Device::Page_Layout layout, PrintCallback cb, void* data, int from, int to) {
    if (from < 1 || from > to) {
        return "Error: invalid from/to range!";
    }
    return priv::_print(ps_filename, format, layout, cb, data, from, to);
}
std::string util::remove_browser_format(const std::string& text) {
    auto res = text;
    auto f   = res.find_last_of("@");
    if (f != std::string::npos) {
        try {
            auto tmp = res.substr(f + 1);
            if (tmp[0] == '.' || tmp[0] == 'l' || tmp[0] == 'm' || tmp[0] == 's' || tmp[0] == 'b' || tmp[0] == 'i' || tmp[0] == 'f' || tmp[0] == 'c' || tmp[0] == 'r' || tmp[0] == 'u' || tmp[0] == '-') {
                res = tmp.substr(1);
            }
            else if (tmp[0] == 'B' || tmp[0] == 'C' || tmp[0] == 'F' || tmp[0] == 'S') {
                auto s = std::string();
                auto e = false;
                tmp = tmp.substr(f + 1);
                for (auto c : tmp) {
                    if (e == false && c >= '0' && c <= '9') {
                    }
                    else {
                        e = true;
                        s += c;
                    }
                }
                res = s;
            }
            else {
                res = res.substr(f);
            }
        }
        catch (...) {
            res = "";
        }
    }
    return res;
}
std::string& util::replace_string(std::string& string, const std::string& find, const std::string& replace) {
    if (find == "") {
        return string;
    }
    try {
        auto res   = std::string();
        auto start = static_cast<size_t>(0);
        auto pos   = static_cast<size_t>(0);
        res.reserve(string.length() + (replace.length() > find.length() ? string.length() * 0.1 : 0));
        while ((pos = string.find(find, start)) != std::string::npos) {
            res   += string.substr(start, pos - start);
            res   += replace;
            pos   += find.length();
            start  = pos;
        }
        res += string.substr(start);
        string.swap(res);
    }
    catch(...) {
        string = "";
    }
    return string;
}
void util::sleep(unsigned milli) {
#ifdef _WIN32
    Sleep(milli);
#else
    usleep(milli * 1000);
#endif
}
flw::StringVector util::split_string(const std::string& string, const std::string& split) {
    auto res = StringVector();
    try {
        if (split != "") {
            auto pos1 = (std::string::size_type) 0;
            auto pos2 = string.find(split);
            while (pos2 != std::string::npos) {
                res.push_back(string.substr(pos1, pos2 - pos1));
                pos1 = pos2 + split.size();
                pos2 = string.find(split, pos1);
            }
            if (pos1 <= string.size()) {
                res.push_back(string.substr(pos1));
            }
        }
    }
    catch(...) {
        res.clear();
    }
    return res;
}
std::string util::substr(const std::string& string, std::string::size_type pos, std::string::size_type size) {
    try {
        return string.substr(pos, size);
    }
    catch(...) {
        return "";
    }
}
std::string util::trim(const std::string& string) {
    auto res = string;
    try {
        res.erase(res.begin(), std::find_if(res.begin(), res.end(), [](auto c) { return !std::isspace(c);} ));
        res.erase(std::find_if(res.rbegin(), res.rend(), [](int ch) { return !std::isspace(ch); }).base(), res.end());
        return res;
    }
    catch(...) {
        return string;
    }
}
void util::swap_rect(Fl_Widget* w1, Fl_Widget* w2) {
    auto r1 = Fl_Rect(w1);
    auto r2 = Fl_Rect(w2);
    w1->resize(r2.x(), r2.y(), r2.w(), r2.h());
    w2->resize(r1.x(), r1.y(), r1.w(), r1.h());
}
double util::to_double(const std::string& string) {
    try {
        return std::stod(string);
    }
    catch(...) {
        return INFINITY;
    }
}
size_t util::to_doubles(const std::string& string, double numbers[], size_t size) {
    auto end = (char*) nullptr;
    auto in  = string.c_str();
    auto f   = (size_t) 0;
    errno = 0;
    for (; f < size; f++) {
        numbers[f] = strtod(in, &end);
        if (errno != 0 || in == end) {
            return f;
        }
        in = end;
    }
    return f;
}
int64_t util::to_int(const std::string& string, int64_t def) {
    try {
        return static_cast<int64_t>(std::stoll(string));
    }
    catch(...) {
        return def;
    }
}
long long util::to_long(const std::string& string, long long def) {
    try {
        return std::stoll(string);
    }
    catch(...) {
        return def;
    }
}
void* util::zero_memory(char* mem, size_t size) {
    if (mem == nullptr || size == 0) return mem;
#ifdef _WIN32
    RtlSecureZeroMemory(mem, size);
#else
    auto p = reinterpret_cast<volatile unsigned char*>(mem);
    while (size--) {
        *p = 0;
        p++;
    }
#endif
    return mem;
}
util::PrintText::PrintText(const std::string& filename,
    Fl_Paged_Device::Page_Format page_format,
    Fl_Paged_Device::Page_Layout page_layout,
    Fl_Font font,
    Fl_Fontsize fontsize,
    Fl_Align align,
    bool wrap,
    bool border,
    int line_num) {
    _align       = FL_ALIGN_INSIDE | FL_ALIGN_TOP;
    _align      |= (align == FL_ALIGN_CENTER || align == FL_ALIGN_RIGHT) ? align : FL_ALIGN_LEFT;
    _border      = border;
    _file        = nullptr;
    _filename    = filename;
    _font        = font;
    _fontsize    = fontsize;
    _line_num    = (align == FL_ALIGN_LEFT && line_num > 0 && line_num < 9) ? line_num : 0;
    _page_format = page_format;
    _page_layout = page_layout;
    _printer     = nullptr;
    _wrap        = wrap;
}
util::PrintText::~PrintText() {
    _stop();
}
void util::PrintText::_check_for_new_page() {
    if (_py + _lh > _ph || _page_count == 0) {
        if (_page_count > 0) {
            fl_pop_clip();
            if (_printer->end_page() != 0) {
                throw "Error: couldn't end current page!";
            }
        }
        if (_printer->begin_page() != 0) {
            throw "Error: couldn't create new page!";
        }
        if (_printer->printable_rect(&_pw, &_ph) != 0) {
            throw "Error: couldn't retrieve page size!";
        }
        fl_font(_font, _fontsize);
        fl_color(FL_BLACK);
        fl_line_style(FL_SOLID, 1);
        fl_push_clip(0, 0, _pw, _ph);
        if (_border == false) {
            _px = 0;
            _py = 0;
        }
        else {
            fl_rect(0, 0, _pw, _ph);
            _measure_lw_lh("M");
            _px  = _lw;
            _py  = _lh;
            _pw -= _lw * 2;
            _ph -= _lh * 2;
        }
        _page_count++;
    }
}
void util::PrintText::_measure_lw_lh(const std::string& text) {
    _lw = _lh = 0;
    fl_measure(text.c_str(), _lw, _lh, 0);
}
std::string util::PrintText::print(const char* text, unsigned replace_tab_with_space) {
    return print(util::split_string(text, "\n"), replace_tab_with_space);
}
std::string util::PrintText::print(const std::string& text, unsigned replace_tab_with_space) {
    return print(util::split_string(text.c_str(), "\n"), replace_tab_with_space);
}
std::string util::PrintText::print(const StringVector& lines, unsigned replace_tab_with_space) {
    std::string res;
    std::string tab;
    while (replace_tab_with_space > 0 && replace_tab_with_space <= 16) {
        tab += " ";
        replace_tab_with_space--;
    }
    try {
        auto wc = WaitCursor();
        res = _start();
        if (res == "") {
            for (auto& line : lines) {
                if (tab != "") {
                    auto l = line;
                    util::replace_string(l, "\t", "    ");
                    _print_line(l == "" ? " " : l);
                }
                else {
                    _print_line(line == "" ? " " : line);
                }
            }
            res = _stop();
        }
    }
    catch (const char* ex) {
        res = ex;
    }
    catch (...) {
        res = "Error: unknown exception!";
    }
    return res;
}
void util::PrintText::_print_line(const std::string& line) {
    _line_count++;
    _check_for_new_page();
    if (_line_num > 0) {
        auto num = util::format("%*d: ", _line_num, _line_count);
        _measure_lw_lh(num);
        fl_draw(num.c_str(), _px, _py, _pw, _lh, _align, nullptr, 0);
        _nw = _lw;
    }
    _measure_lw_lh(line);
    if (_wrap == true && _lw > _pw - _nw) {
        _print_wrapped_line(line);
    }
    else {
        fl_draw(line.c_str(), _px + _nw, _py, _pw - _nw, _lh, _align, nullptr, 0);
        _py += _lh;
    }
}
void util::PrintText::_print_wrapped_line(const std::string& line) {
    auto p1 = line.c_str();
    auto s1 = std::string();
    auto s2 = std::string();
    while (*p1 != 0) {
        auto cl = fl_wcwidth(p1);
        if (cl > 1) {
            for (auto f = 0; f < cl && *p1 != 0; f++) {
                s1 += *p1;
                p1++;
            }
        }
        else {
            s1 += *p1;
            p1++;
        }
        auto c = s1.back();
        if (c == ' ' || c == '\t' || c == ',' || c == ';' || c == '.') {
            s2 = s1;
        }
        _measure_lw_lh(s1);
        if (_lw >= _pw - _nw) {
            _check_for_new_page();
            if (s2 != "") {
                fl_draw(s2.c_str(), _px + _nw, _py, _pw - _nw, _lh, _align, nullptr, 0);
                s1 = (s2.length() < s1.length()) ? s1.substr(s2.length()) : "";
                s2 = "";
            }
            else {
                std::string s;
                if (s1.length() > 1) {
                    s  = s1.substr(s1.length() - 1);
                    s1 = s1.substr(0, s1.length() - 1);
                }
                fl_draw(s1.c_str(), _px + _nw, _py, _pw - _nw, _lh, _align, nullptr, 0);
                s1 = s;
            }
            _py += _lh;
        }
    }
    if (s1 != "") {
        _check_for_new_page();
        fl_draw(s1.c_str(), _px + _nw, _py, _pw - _nw, _lh, _align, nullptr, 0);
        _py += _lh;
    }
}
std::string util::PrintText::_start() {
    if ((_file = fl_fopen(_filename.c_str(), "wb")) == nullptr) {
        return "Error: could not open file!";
    }
    _lh         = 0;
    _line_count = 0;
    _lw         = 0;
    _nw         = 0;
    _page_count = 0;
    _ph         = 0;
    _pw         = 0;
    _px         = 0;
    _py         = 0;
    _printer    = new Fl_PostScript_File_Device();
    _printer->begin_job(_file, 0, _page_format, _page_layout);
    return "";
}
std::string util::PrintText::_stop() {
    std::string res = "";
    if (_printer != nullptr) {
        if (_page_count > 0) {
            fl_pop_clip();
            if (_printer->end_page() != 0) {
                res = "Error: could not end page!";
            }
        }
        _printer->end_job();
        delete _printer;
        fclose(_file);
        _file    = nullptr;
        _printer = nullptr;
    }
    return res;
}
namespace theme {
bool is_dark() {
    if (flw::PREF_THEME == flw::PREF_THEMES[priv::THEME_GLEAM_BLUE] ||
        flw::PREF_THEME == flw::PREF_THEMES[priv::THEME_GLEAM_DARK] ||
        flw::PREF_THEME == flw::PREF_THEMES[priv::THEME_GTK_BLUE] ||
        flw::PREF_THEME == flw::PREF_THEMES[priv::THEME_GTK_DARK]) {
        return true;
    }
    else {
        return false;
    }
}
bool load(const std::string& name) {
    if (priv::_SCROLLSIZE == 0) {
        priv::_SCROLLSIZE = Fl::scrollbar_size();
    }
    if (name == flw::PREF_THEMES[priv::THEME_DEFAULT] || name == flw::PREF_THEMES2[priv::THEME_DEFAULT]) {
        priv::_load_default();
    }
    else if (name == flw::PREF_THEMES[priv::THEME_GLEAM] || name == flw::PREF_THEMES2[priv::THEME_GLEAM]) {
        priv::_load_gleam();
    }
    else if (name == flw::PREF_THEMES[priv::THEME_GLEAM_BLUE] || name == flw::PREF_THEMES2[priv::THEME_GLEAM_BLUE]) {
        priv::_load_gleam_blue();
    }
    else if (name == flw::PREF_THEMES[priv::THEME_GLEAM_DARK] || name == flw::PREF_THEMES2[priv::THEME_GLEAM_DARK]) {
        priv::_load_gleam_dark();
    }
    else if (name == flw::PREF_THEMES[priv::THEME_GLEAM_TAN] || name == flw::PREF_THEMES2[priv::THEME_GLEAM_TAN]) {
        priv::_load_gleam_tan();
    }
    else if (name == flw::PREF_THEMES[priv::THEME_GTK] || name == flw::PREF_THEMES2[priv::THEME_GTK]) {
        priv::_load_gtk();
    }
    else if (name == flw::PREF_THEMES[priv::THEME_GTK_BLUE] || name == flw::PREF_THEMES2[priv::THEME_GTK_BLUE]) {
        priv::_load_gtk_blue();
    }
    else if (name == flw::PREF_THEMES[priv::THEME_GTK_DARK] || name == flw::PREF_THEMES2[priv::THEME_GTK_DARK]) {
        priv::_load_gtk_dark();
    }
    else if (name == flw::PREF_THEMES[priv::THEME_GTK_TAN] || name == flw::PREF_THEMES2[priv::THEME_GTK_TAN]) {
        priv::_load_gtk_tan();
    }
    else if (name == flw::PREF_THEMES[priv::THEME_OXY] || name == flw::PREF_THEMES2[priv::THEME_OXY]) {
        priv::_load_oxy();
    }
    else if (name == flw::PREF_THEMES[priv::THEME_OXY_TAN] || name == flw::PREF_THEMES2[priv::THEME_OXY_TAN]) {
        priv::_load_oxy_tan();
    }
    else if (name == flw::PREF_THEMES[priv::THEME_PLASTIC] || name == flw::PREF_THEMES2[priv::THEME_PLASTIC]) {
        priv::_load_plastic();
    }
    else if (name == flw::PREF_THEMES[priv::THEME_PLASTIC_TAN] || name == flw::PREF_THEMES2[priv::THEME_PLASTIC_TAN]) {
        priv::_load_plastic_tan();
    }
    else {
        return false;
    }
    priv::_scrollbar();
    return true;
}
Fl_Font load_font(const std::string& requested_font) {
    load_fonts();
    auto count = 0;
    for (auto font : flw::PREF_FONTNAMES) {
        auto font2 = util::remove_browser_format(font);
        if (requested_font == font2) {
            return count;
        }
        count++;
    }
    return -1;
}
void load_fonts(bool iso8859_only) {
    if (flw::PREF_FONTNAMES.size() == 0) {
        auto fonts = Fl::set_fonts((iso8859_only == true) ? nullptr : "-*");
        for (int f = 0; f < fonts; f++) {
            auto attr  = 0;
            auto name1 = Fl::get_font_name(static_cast<Fl_Font>(f), &attr);
            auto name2 = std::string();
            if (attr & FL_BOLD) {
                name2 = std::string("@b");
            }
            if (attr & FL_ITALIC) {
                name2 += std::string("@i");
            }
            name2 += std::string("@.");
            name2 += name1;
            flw::PREF_FONTNAMES.push_back(strdup(name2.c_str()));
        }
    }
}
void load_icon(Fl_Window* win, int win_resource, const char** xpm_resource, const char* name) {
    assert(win);
    if (win->shown() != 0) {
        fl_alert("%s", "Warning: load icon before showing window!");
    }
#if defined(_WIN32)
    win->icon(reinterpret_cast<char*>(LoadIcon(fl_display, MAKEINTRESOURCE(win_resource))));
    (void) name;
    (void) xpm_resource;
    (void) name;
#elif defined(__linux__)
    assert(xpm_resource);
    Fl_Pixmap    pix(xpm_resource);
    Fl_RGB_Image rgb(&pix, Fl_Color(0));
    win->icon(&rgb);
    win->xclass((name != nullptr) ? name : "FLTK");
    (void) win_resource;
#else
    (void) win;
    (void) win_resource;
    (void) xpm_resource;
    (void) name;
#endif
}
Fl_Rect load_rect_from_pref(Fl_Preferences& pref, const std::string& basename) {
    int  x, y, w, h;
    pref.get((basename + "x").c_str(), x, 0);
    pref.get((basename + "y").c_str(), y, 0);
    pref.get((basename + "w").c_str(), w, 0);
    pref.get((basename + "h").c_str(), h, 0);
    if (x < 0 || x > Fl::w()) {
        x = 0;
    }
    if (y < 0 || y > Fl::h()) {
        y = 0;
    }
    if (w > Fl::w()) {
        x = 0;
        w = Fl::w();
    }
    if (h > Fl::h()) {
        y = 0;
        h = Fl::h();
    }
    return Fl_Rect(x, y, w, h);
}
double load_theme_from_pref(Fl_Preferences& pref, unsigned screen_num) {
    auto val = 0;
    char buffer[4000];
    pref.get("regular_name", buffer, "", 4000);
    std::string name = buffer;
    if (name != "" && name != "FL_HELVETICA") {
        auto font = load_font(name);
        if (font != -1) {
            flw::PREF_FONT     = font;
            flw::PREF_FONTNAME = name;
        }
    }
    pref.get("regular_size", val, flw::PREF_FONTSIZE);
    if (val >= 6 && val <= 72) {
        flw::PREF_FONTSIZE = val;
    }
    pref.get("mono_name", buffer, "", 1000);
    name = buffer;
    if (name != "" && name != "FL_COURIER") {
        auto font = load_font(name);
        if (font != -1) {
            flw::PREF_FIXED_FONT     = font;
            flw::PREF_FIXED_FONTNAME = name;
        }
    }
    pref.get("mono_size", val, flw::PREF_FIXED_FONTSIZE);
    if (val >= 6 && val <= 72) {
        flw::PREF_FIXED_FONTSIZE = val;
    }
    pref.get("theme", buffer, "oxy", 4000);
    load(buffer);
    Fl_Tooltip::font(flw::PREF_FONT);
    Fl_Tooltip::size(flw::PREF_FONTSIZE);
    priv::_scrollbar();
    auto so = 0;
    auto sv = 0.0;
    auto def_scaling = Fl::screen_scale(screen_num);
    pref.get("scaling_on", so, 1);
    pref.get("scaling_value", sv, def_scaling);
    if (sv < 0.5 || sv > 2.0) {
        sv = def_scaling;
    }
    flw::PREF_SCALE_ON  = so;
    flw::PREF_SCALE_VAL = sv;
    if (flw::PREF_SCALE_ON == false) {
        Fl::screen_scale(screen_num, 1.0);
    }
    else {
        Fl::screen_scale(screen_num, sv);
    }
    return flw::PREF_SCALE_VAL;
}
void load_win_from_pref(Fl_Preferences& pref, const std::string& basename, Fl_Window* window, bool show, int defw, int defh) {
    int x = 0;
    int y = 0;
    int w = 0;
    int h = 0;
    pref.get((basename + "x").c_str(), x, 80);
    pref.get((basename + "y").c_str(), y, 60);
    pref.get((basename + "w").c_str(), w, defw);
    pref.get((basename + "h").c_str(), h, defh);
    if (x < 0 || x > Fl::w()) {
        x = 0;
    }
    if (y < 0 || y > Fl::h()) {
        y = 0;
    }
#ifdef _WIN32
    if (show == true && window->shown() == 0) {
        window->show();
    }
    window->resize(x, y, w, h);
#else
    window->resize(x, y, w, h);
    if (show == true && window->shown() == 0) {
        window->show();
    }
#endif
}
bool parse(int argc, const char** argv) {
    auto res = false;
    for (auto f = 1; f < argc; f++) {
        if (res == false) {
            res = load(argv[f]);
        }
        auto fontsize = atoi(argv[f]);
        if (fontsize >= 6 && fontsize <= 72) {
            flw::PREF_FONTSIZE = fontsize;
        }
        if (std::string("scaleoff") == argv[f] && flw::PREF_SCALE_VAL < 0.1) {
            flw::PREF_SCALE_ON = false;
            if (Fl::first_window() != nullptr) {
                flw::PREF_SCALE_VAL = Fl::screen_scale(Fl::first_window()->screen_num());
                Fl::screen_scale(Fl::first_window()->screen_num(), 1.0);
            }
            else {
                flw::PREF_SCALE_VAL = Fl::screen_scale(0);
                Fl::screen_scale(0, 1.0);
            }
        }
    }
    flw::PREF_FIXED_FONTSIZE = flw::PREF_FONTSIZE;
    Fl_Tooltip::font(flw::PREF_FONT);
    Fl_Tooltip::size(flw::PREF_FONTSIZE);
    return res;
}
void save_rect_to_pref(Fl_Preferences& pref, const std::string& basename, const Fl_Rect& rect) {
    pref.set((basename + "x").c_str(), rect.x());
    pref.set((basename + "y").c_str(), rect.y());
    pref.set((basename + "w").c_str(), rect.w());
    pref.set((basename + "h").c_str(), rect.h());
}
void save_theme_to_pref(Fl_Preferences& pref) {
    pref.set("theme", flw::PREF_THEME.c_str());
    pref.set("regular_name", flw::PREF_FONTNAME.c_str());
    pref.set("regular_size", flw::PREF_FONTSIZE);
    pref.set("mono_name", flw::PREF_FIXED_FONTNAME.c_str());
    pref.set("mono_size", flw::PREF_FIXED_FONTSIZE);
    pref.set("scaling_on", flw::PREF_SCALE_ON);
    pref.set("scaling_value", flw::PREF_SCALE_VAL);
}
void save_win_to_pref(Fl_Preferences& pref, const std::string& basename, Fl_Window* window) {
    pref.set((basename + "x").c_str(), window->x());
    pref.set((basename + "y").c_str(), window->y());
    pref.set((basename + "w").c_str(), window->w());
    pref.set((basename + "h").c_str(), window->h());
}
}
}
#ifdef _WIN32
    #include <windows.h>
#else
#endif
#include <math.h>
#include <FL/Fl_File_Chooser.H>
#include <FL/Fl_Float_Input.H>
#include <FL/Fl_Help_View.H>
#include <FL/Fl_Hor_Slider.H>
#include <FL/Fl_Hor_Value_Slider.H>
#include <FL/Fl_Int_Input.H>
#include <FL/Fl_Multiline_Input.H>
#include <FL/Fl_Output.H>
#include <FL/Fl_Return_Button.H>
#include <FL/Fl_Scroll.H>
#include <FL/Fl_Secret_Input.H>
#include <FL/Fl_Text_Editor.H>
#include <FL/Fl_Tooltip.H>
namespace flw {
namespace priv {
static Fl_Window*   PARENT            = nullptr;
static Fl_Window*   PARENT2           = nullptr;
static bool         MSG_ICON_BORDER   = true;
static bool         MSG_ICON_BORDER2  = true;
static bool         MSG_LABEL_BORDER  = false;
static bool         MSG_LABEL_BORDER2 = false;
static bool         MSG_ACTIVE_COLOR  = false;
static bool         MSG_ACTIVE_COLOR2 = false;
 void _load_default();
 void _load_gleam();
 void _load_gleam_blue();
 void _load_gleam_dark();
 void _load_gleam_tan();
 void _load_gtk();
 void _load_gtk_blue();
 void _load_gtk_dark();
 void _load_gtk_tan();
 void _load_oxy();
 void _load_oxy_blue();
 void _load_oxy_tan();
 void _load_plastic();
 void _load_plastic_tan();
 void _scrollbar();
static void _init_printer_formats(Fl_Choice* format, Fl_Choice* layout) {
    format->add("A0 Format");
    format->add("A1 Format");
    format->add("A2 Format");
    format->add("A3 Format");
    format->add("A4 Format");
    format->add("A5 Format");
    format->add("A6 Format");
    format->add("A7 Format");
    format->add("A8 Format");
    format->add("A9 Format");
    format->add("B0 Format");
    format->add("B1 Format");
    format->add("B2 Format");
    format->add("B3 Format");
    format->add("B4 Format");
    format->add("B5 Format");
    format->add("B6 Format");
    format->add("B7 Format");
    format->add("B8 Format");
    format->add("B9 Format");
    format->add("Executive Format");
    format->add("Folio Format");
    format->add("Ledger Format");
    format->add("Legal Format");
    format->add("Letter Format");
    format->add("Tabloid Format");
    format->tooltip("Select paper format.");
    format->value(4);
    layout->add("Portrait");
    layout->add("Landscape");
    layout->tooltip("Select paper layout.");
    layout->value(0);
}
class _Button : public Fl_Button {
    Fl_Color                    _color;
    bool                        _return;
    std::string                 _icon;
    std::string                 _label;
public:
    _Button(int X, int Y, int W, int H, const std::string& l, const std::string& icon, bool ret) : Fl_Button(X, Y, W, H) {
        _return = ret;
        _color  = -1;
        set_icon(l, icon);
    }
    void draw() override {
        if (Fl::focus() == this && priv::MSG_ACTIVE_COLOR == true) {
            if (_color == static_cast<Fl_Color>(-1)) {
                color(fl_darker(FL_BACKGROUND_COLOR));
            }
            else {
                color(_color);
            }
        }
        else {
            color(FL_BACKGROUND_COLOR);
        }
        Fl_Button::draw();
    }
    int handle(int event) override {
        if (_return == false) {
        }
        else if (event == FL_SHORTCUT && (Fl::event_key() == FL_Enter || Fl::event_key() == FL_KP_Enter)) {
            simulate_key_action();
            do_callback(FL_REASON_SELECTED);
            return 1;
        }
        return Fl_Button::handle(event);
    }
    std::string icon() {
        return _icon;
    }
    bool is_return() {
        return _return;
    }
    std::string label2() {
        return _label;
    }
    void set_color(Fl_Color color) {
        _color = color;
    }
    void set_icon(const std::string& l, const std::string& icon) {
        _icon = icon;
        if (icon != "") {
            copy_label((l + "  ").c_str());
            util::icon(this, icon, flw::PREF_FIXED_FONTSIZE * 1.5);
            align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE | FL_ALIGN_CLIP | FL_ALIGN_TEXT_NEXT_TO_IMAGE);
        }
        else {
            copy_label(l.c_str());
            align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE | FL_ALIGN_CLIP);
        }
    }
    void set_return(bool ret) {
        _return = ret;
    }
};
}
Fl_Button* dlg::button(int X, int Y, int W, int H, const std::string& l) {
    auto t  = util::trim(l);
    auto l2 = t.c_str();
    if (*l2 == 0) {
        return new Fl_Button(X, Y, W, H);
    }
    const char* l3 = l2 + 1;
    if (*l2 == '!') {
        return new priv::_Button(X, Y, W, H, l3, icons::BACK, true);
    }
    else if (*l2 == '#') {
        return new priv::_Button(X, Y, W, H, l3, icons::CANCEL, false);
    }
    else if (*l2 == '%') {
        return new priv::_Button(X, Y, W, H, l3, icons::DEL, false);
    }
    else if (*l2 == '@') {
        return new priv::_Button(X, Y, W, H, l3, icons::CONFIRM, false);
    }
    else {
        return new priv::_Button(X, Y, W, H, l, "", false);
    }
}
Fl_Button* dlg::button(int X, int Y, int W, int H, const std::string& l, const std::string& icon, bool ret) {
    return new priv::_Button(X, Y, W, H, l, icon, ret);
}
void dlg::center_fl_message_dialog() {
    int X, Y, W, H;
    Fl::screen_xywh(X, Y, W, H);
    fl_message_position(W / 2, H / 2, 1);
}
void dlg::options(Fl_Window* parent, bool msg_icon_border, bool msg_label_border, bool msg_active_color) {
    priv::PARENT           = parent;
    priv::MSG_ICON_BORDER  = msg_icon_border;
    priv::MSG_LABEL_BORDER = msg_label_border;
    priv::MSG_ACTIVE_COLOR = msg_active_color;
}
void dlg::options_pop() {
    priv::PARENT           = priv::PARENT2;
    priv::MSG_ICON_BORDER  = priv::MSG_ICON_BORDER2;
    priv::MSG_LABEL_BORDER = priv::MSG_LABEL_BORDER2;
    priv::MSG_ACTIVE_COLOR = priv::MSG_ACTIVE_COLOR2;
}
void dlg::options_push() {
    priv::PARENT2           = priv::PARENT;
    priv::MSG_ICON_BORDER2  = priv::MSG_ICON_BORDER;
    priv::MSG_LABEL_BORDER2 = priv::MSG_LABEL_BORDER;
    priv::MSG_ACTIVE_COLOR2 = priv::MSG_ACTIVE_COLOR;
}
void dlg::panic(const std::string& message) {
    dlg::msg_error("Application Error", util::format("PANIC! I have to quit\n%s", message.c_str()));
    exit(1);
}
namespace priv {
class _DateChooserDlg : public Fl_Double_Window {
    gnu::Date&                  _value;
    DateChooser*                _date_chooser;
    Fl_Button*                  _cancel;
    Fl_Button*                  _ok;
    GridGroup*                  _grid;
    bool                        _res;
    bool                        _run;
public:
    _DateChooserDlg(const std::string& title, gnu::Date& date, int W, int H) :
    Fl_Double_Window(0, 0, flw::PREF_FONTSIZE * W, flw::PREF_FONTSIZE * H),
    _value(date) {
        end();
        _cancel       = new Fl_Button(0, 0, 0, 0, label::CANCEL.c_str());
        _date_chooser = new DateChooser(0, 0, 0, 0);
        _grid         = new GridGroup(0, 0, w(), h());
        _ok           = new Fl_Return_Button(0, 0, 0, 0, label::OK.c_str());
        _res          = false;
        _run          = false;
        _grid->add(_date_chooser,   0,   0,   0,  -6);
        _grid->add(_cancel,       -34,  -5,  16,   4);
        _grid->add(_ok,           -17,  -5,  16,   4);
        add(_grid);
        _cancel->callback(Callback, this);
        _date_chooser->focus();
        _date_chooser->set(_value);
        _grid->do_layout();
        _ok->callback(Callback, this);
        util::labelfont(this);
        callback(Callback, this);
        copy_label(title.c_str());
        resizable(_grid);
        set_modal();
    }
    static void Callback(Fl_Widget* w, void* o) {
        auto self = static_cast<_DateChooserDlg*>(o);
        if (w == self || w == self->_cancel) {
            self->_run = false;
            self->hide();
        }
        else if (w == self->_ok) {
            self->_res = true;
            self->_run = false;
            self->hide();
        }
    }
    bool run() {
        _run = true;
        util::center_window(this, priv::PARENT);
        show();
        while (_run == true) {
            Fl::wait();
            Fl::flush();
        }
        if (_res == true) {
            _value = _date_chooser->get();
        }
        return _res;
    }
};
}
bool dlg::date(const std::string& title, gnu::Date& date, int W, int H) {
    priv::_DateChooserDlg dlg(title, date, W, H);
    return dlg.run();
}
namespace priv {
class _DlgHtml : public Fl_Double_Window {
    Fl_Help_View*               _html;
    Fl_Return_Button*           _close;
    GridGroup*                  _grid;
    bool                        _run;
public:
    _DlgHtml(const std::string& title, const std::string& text, int W, int H) :
    Fl_Double_Window(0, 0, flw::PREF_FONTSIZE * W,flw::PREF_FONTSIZE * H) {
        end();
        _close = new Fl_Return_Button(0, 0, 0, 0, label::CLOSE.c_str());
        _grid  = new GridGroup(0, 0, w(), h());
        _html  = new Fl_Help_View(0, 0, 0, 0);
        _run   = false;
        _grid->add(_html,    1,  1, -1, -6);
        _grid->add(_close, -17, -5, 16,  4);
        add(_grid);
        _close->callback(_DlgHtml::Callback, this);
        _close->labelfont(flw::PREF_FONT);
        _close->labelsize(flw::PREF_FONTSIZE);
        _html->textfont(flw::PREF_FONT);
        _html->textsize(flw::PREF_FONTSIZE);
        _html->value(text.c_str());
        callback(_DlgHtml::Callback, this);
        copy_label(title.c_str());
        set_modal();
        resizable(_grid);
        util::center_window(this, priv::PARENT);
        _grid->do_layout();
    }
    static void Callback(Fl_Widget* w, void* o) {
        auto self = static_cast<_DlgHtml*>(o);
        if (w == self || w == self->_close) {
            self->_run = false;
            self->hide();
        }
    }
    void run() {
        _run = true;
        show();
        while (_run == true) {
            Fl::wait();
            Fl::flush();
        }
    }
};
}
void dlg::html(const std::string& title, const std::string& text, int W, int H) {
    priv::_DlgHtml dlg(title, text, W, H);
    dlg.run();
}
namespace priv {
class _DlgList : public Fl_Double_Window {
    Fl_Return_Button*           _close;
    GridGroup*                  _grid;
    ScrollBrowser*              _list;
    bool                        _run;
public:
    _DlgList(const std::string& title, const StringVector& list, const std::string& file, bool fixed_font = false, int W = 50, int H = 20) :
    Fl_Double_Window(0, 0, (fixed_font ? flw::PREF_FIXED_FONTSIZE : flw::PREF_FONTSIZE) * W, (fixed_font ? flw::PREF_FIXED_FONTSIZE : flw::PREF_FONTSIZE) * H) {
        end();
        _close = new Fl_Return_Button(0, 0, 0, 0, label::CLOSE.c_str());
        _grid  = new GridGroup(0, 0, w(), h());
        _list  = new ScrollBrowser();
        _run   = false;
        _grid->add(_list,     1,   1,  -1,  -6);
        _grid->add(_close,  -17,  -5,  16,   4);
        add(_grid);
        _close->callback(_DlgList::Callback, this);
        _close->labelfont(flw::PREF_FONT);
        _close->labelsize(flw::PREF_FONTSIZE);
        _list->take_focus();
        if (fixed_font == true) {
            _list->textfont(flw::PREF_FIXED_FONT);
            _list->textsize(flw::PREF_FIXED_FONTSIZE);
        }
        else {
            _list->textfont(flw::PREF_FONT);
            _list->textsize(flw::PREF_FONTSIZE);
        }
        callback(_DlgList::Callback, this);
        copy_label(title.c_str());
        set_modal();
        resizable(_grid);
        util::center_window(this, priv::PARENT);
        _grid->do_layout();
        if (list.size() > 0) {
            for (const auto& s : list) {
                _list->add(s.c_str());
            }
        }
        else if (file != "") {
            _list->load(file.c_str());
        }
    }
    static void Callback(Fl_Widget* w, void* o) {
        auto self = static_cast<_DlgList*>(o);
        if (w == self || w == self->_close) {
            self->_run = false;
            self->hide();
        }
    }
    void run() {
        _run = true;
        show();
        while (_run == true) {
            Fl::wait();
            Fl::flush();
        }
    }
};
}
void dlg::list(const std::string& title, const StringVector& list, bool fixed_font, int W, int H) {
    priv::_DlgList dlg(title, list, "", fixed_font, W, H);
    dlg.run();
}
void dlg::list(const std::string& title, const std::string& list, bool fixed_font, int W, int H) {
    auto list2 = util::split_string( list, "\n");
    priv::_DlgList dlg(title, list2, "", fixed_font, W, H);
    dlg.run();
}
void dlg::list_file(const std::string& title, const std::string& file, bool fixed_font, int W, int H) {
    priv::_DlgList dlg(title, flw::StringVector(), file, fixed_font, W, H);
    dlg.run();
}
namespace priv {
class _DlgMsg : public Fl_Double_Window {
    Fl_Box*                     _label;
    priv::_Button*              _b1;
    priv::_Button*              _b2;
    priv::_Button*              _b3;
    priv::_Button*              _b4;
    priv::_Button*              _b5;
    Fl_Button*                  _icon;
    Fl_Input*                   _input;
    GridGroup*                  _grid;
    bool                        _run;
    int                         _escape;
    std::string                 _res;
public:
    _DlgMsg(
        const std::string& type,
        const std::string& title,
        const std::string& message,
        const std::string& b1,
        const std::string& b2,
        const std::string& b3,
        const std::string& b4,
        const std::string& b5,
        int W,
        int H,
        const char* value = nullptr,
        const std::string& input = ""
    ) : Fl_Double_Window(0, 0, flw::PREF_FONTSIZE * W,flw::PREF_FONTSIZE * H) {
        end();
        _b1     = static_cast<priv::_Button*>(dlg::button(0, 0, 0, 0, b1));
        _b2     = static_cast<priv::_Button*>(dlg::button(0, 0, 0, 0, b2));
        _b3     = static_cast<priv::_Button*>(dlg::button(0, 0, 0, 0, b3));
        _b4     = static_cast<priv::_Button*>(dlg::button(0, 0, 0, 0, b4));
        _b5     = static_cast<priv::_Button*>(dlg::button(0, 0, 0, 0, b5));
        _grid   = new GridGroup(0, 0, w(), h());
        _icon   = new Fl_Button(0, 0, 0, 0);
        _label  = new Fl_Box(0, 0, 0, 0);
        _run    = false;
        _escape = 0;
        auto multi = false;
        auto xpos  = 0;
        auto count = 0;
        if (input == "Fl_Int_Input") {
            _input = new Fl_Int_Input(0, 0, 0, 0);
        }
        else if (input == "Fl_Float_Input") {
            _input = new Fl_Float_Input(0, 0, 0, 0);
        }
        else if (input == "Fl_Multiline_Input") {
            _input = new Fl_Multiline_Input(0, 0, 0, 0);
            multi  = true;
        }
        else if (input == "Fl_Secret_Input") {
            _input = new Fl_Secret_Input(0, 0, 0, 0);
        }
        else {
            _input = new Fl_Input(0, 0, 0, 0);
        }
        util::icon(_icon, type, flw::PREF_FONTSIZE * 4);
        count = count + (b1 != "");
        count = count + (b2 != "");
        count = count + (b3 != "");
        count = count + (b4 != "");
        count = count + (b5 != "");
        xpos  = -count * 21;
        if (value != nullptr) {
            if (multi == true) {
                _grid->add(_input, 12, 11, -1, -6);
            }
            else {
                _grid->add(_input, 12, -10, -1, 4);
            }
            _input->value(value);
            _input->box(FL_BORDER_BOX);
        }
        else {
            _input->hide();
        }
        if (b5 != "") {
            _grid->add(_b5, xpos, -5, 20, 4);
            xpos += 21;
        }
        else {
            _b5->hide();
        }
        if (b4 != "") {
            _grid->add(_b4, xpos, -5, 20, 4);
            xpos += 21;
        }
        else {
            _b4->hide();
        }
        if (b3 != "") {
            _grid->add(_b3, xpos, -5, 20, 4);
            xpos += 21;
        }
        else {
            _b3->hide();
        }
        if (b2 != "") {
            _grid->add(_b2, xpos, -5, 20, 4);
            xpos += 21;
        }
        else {
            _b2->hide();
        }
        if (b1 != "") {
            _grid->add(_b1, xpos, -5, 20, 4);
            xpos += 21;
        }
        else {
            _b1->hide();
        }
        _escape += _b1->visible();
        _escape += _b2->visible();
        _escape += _b3->visible();
        _escape += _b4->visible();
        _escape += _b5->visible();
        if (_input->visible() == 0) {
            _grid->add(_label, 12,  1, -1, -6);
        }
        else if (multi == true) {
            _grid->add(_label, 12,  1, -1, 12);
        }
        else {
            _grid->add(_label, 12,  1, -1, -11);
        }
        _grid->add(_icon, 1, 1, 10, 10);
        add(_grid);
        _b1->callback(_DlgMsg::Callback, this);
        _b2->callback(_DlgMsg::Callback, this);
        _b3->callback(_DlgMsg::Callback, this);
        _b4->callback(_DlgMsg::Callback, this);
        _b5->callback(_DlgMsg::Callback, this);
        _icon->box(priv::MSG_ICON_BORDER == true ? FL_BORDER_BOX : FL_NO_BOX);
        _label->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE | FL_ALIGN_TOP | FL_ALIGN_CLIP);
        _label->box(priv::MSG_LABEL_BORDER == true ? FL_BORDER_BOX : FL_NO_BOX);
        _label->copy_label(message.c_str());
        if (_b1->is_return() == true) {
            _b1->take_focus();
        }
        else if (_b2->is_return() == true) {
            _b2->take_focus();
        }
        else if (_b3->is_return() == true) {
            _b3->take_focus();
        }
        else if (_b4->is_return() == true) {
            _b4->take_focus();
        }
        else if (_b5->is_return() == true) {
            _b5->take_focus();
        }
        else {
            _icon->take_focus();
        }
        if (_escape == 1) {
            _b1->set_color(FL_BACKGROUND_COLOR);
            _b2->set_color(FL_BACKGROUND_COLOR);
            _b3->set_color(FL_BACKGROUND_COLOR);
            _b4->set_color(FL_BACKGROUND_COLOR);
            _b5->set_color(FL_BACKGROUND_COLOR);
            if (_b1->visible() != 0 && _b1->icon() == "") {
                _b1->set_icon(_b1->label(), icons::BACK);
                _b1->set_return(true);
            }
            else if (_b2->visible() != 0 && _b2->icon() == "") {
                _b2->set_icon(_b2->label(), icons::BACK);
                _b2->set_return(true);
            }
            else if (_b3->visible() != 0 && _b3->icon() == "") {
                _b3->set_icon(_b3->label(), icons::BACK);
                _b3->set_return(true);
            }
            else if (_b4->visible() != 0 && _b4->icon() == "") {
                _b4->set_icon(_b4->label(), icons::BACK);
                _b4->set_return(true);
            }
            else if (_b5->visible() != 0 && _b5->icon() == "") {
                _b5->set_icon(_b5->label(), icons::BACK);
                _b5->set_return(true);
            }
        }
        if (_input->visible() != 0) {
            _input->take_focus();
        }
        callback(_DlgMsg::Callback, this);
        copy_label(title.c_str());
        set_modal();
        resizable(_grid);
        util::labelfont(this);
        util::center_window(this, priv::PARENT);
        _grid->do_layout();
    }
    static void Callback(Fl_Widget* w, void* o) {
        auto self = static_cast<_DlgMsg*>(o);
        if (w == self && self->_escape == 1) {
            self->_run = false;
            self->hide();
        }
        else if (w == self->_b1 || w == self->_b2 || w == self->_b3 || w == self->_b4 || w == self->_b5) {
            self->_run = false;
            self->hide();
            self->_res = util::trim(w->label());
        }
    }
    std::string input() {
        return _input->value();
    }
    std::string run() {
        if (_b1->visible() == 0 && _b2->visible() == 0 && _b3->visible() == 0 && _b4->visible() == 0 && _b5->visible() == 0) {
            return "";
        }
        _run = true;
        show();
        while (_run == true) {
            Fl::wait();
            Fl::flush();
        }
        return _res;
    }
};
}
std::string dlg::input(const std::string& title, const std::string& message, std::string& value, int W, int H) {
    priv::_DlgMsg dlg(icons::EDIT, title, message, label::OK, label::CANCEL, "", "", "", W, H, value.c_str(), "Fl_Input");
    auto res = dlg.run();
    if (res == label::OK) {
        value = dlg.input();
    }
    return res;
}
std::string dlg::input_double(const std::string& title, const std::string& message, double& value, int W, int H) {
    char num[500];
    snprintf(num, 500, "%g", value);
    priv::_DlgMsg dlg(icons::EDIT, title, message, label::OK, label::CANCEL, "", "", "", W, H, num, "Fl_Float_Input");
    auto res = dlg.run();
    if (res == label::OK) {
        auto tmp = value;
        tmp = util::to_double(dlg.input());
        if (std::isinf(tmp) == false) {
            value = tmp;
        }
    }
    return res;
}
std::string dlg::input_int(const std::string& title, const std::string& message, int64_t& value, int W, int H) {
    char num[100];
    snprintf(num, 100, "%lld", static_cast<long long int>(value));
    priv::_DlgMsg dlg(icons::EDIT, title, message, label::OK, label::CANCEL, "", "", "", W, H, num, "Fl_Int_Input");
    auto res = dlg.run();
    if (res == label::OK) {
        value = util::to_int(dlg.input(), value);
    }
    return res;
}
std::string dlg::input_multi(const std::string& title, const std::string& message, std::string& value, int W, int H) {
    priv::_DlgMsg dlg(icons::EDIT, title, message, label::OK, label::CANCEL, "", "", "", W, H, value.c_str(), "Fl_Multiline_Input");
    auto res = dlg.run();
    if (res == label::OK) {
        value = dlg.input();
    }
    return res;
}
std::string dlg::input_secret(const std::string& title, const std::string& message, std::string& value, int W, int H) {
    priv::_DlgMsg dlg(icons::PASSWORD, title, message, label::OK, label::CANCEL, "", "", "", W, H, value.c_str(), "Fl_Secret_Input");
    auto res = dlg.run();
    if (res == label::OK) {
        value = dlg.input();
    }
    return res;
}
void dlg::msg(const std::string& title, const std::string& message, int W, int H) {
    priv::_DlgMsg dlg(icons::INFO, title, message, label::CLOSE, "", "", "", "", W, H);
    dlg.run();
}
void dlg::msg_alert(const std::string& title, const std::string& message, int W, int H) {
    priv::_DlgMsg dlg(icons::ALERT, title, message, label::CLOSE, "", "", "", "", W, H);
    dlg.run();
}
std::string dlg::msg_ask(const std::string& title, const std::string& message, const std::string& b1, const std::string& b2, const std::string& b3, const std::string& b4, const std::string& b5, int W, int H) {
    priv::_DlgMsg dlg(icons::QUESTION, title, message, b1, b2, b3, b4, b5, W, H);
    return dlg.run();
}
void dlg::msg_error(const std::string& title, const std::string& message, int W, int H) {
    priv::_DlgMsg dlg(icons::ERR, title, message, label::CLOSE, "", "", "", "", W, H);
    dlg.run();
}
std::string dlg::msg_warning(const std::string& title, const std::string& message, const std::string& b1, const std::string& b2, int W, int H) {
    priv::_DlgMsg dlg(icons::WARNING, title, message, b1, b2, "", "", "", W, H);
    return dlg.run();
}
namespace priv {
class _DlgPassword : public Fl_Double_Window {
public:
    enum class Mode {
                                PASSWORD,
                                PASSWORD_CONFIRM,
                                PASSWORD_CONFIRM_WITH_FILE,
                                PASSWORD_WITH_FILE,
    };
private:
    Fl_Button*                  _browse;
    Fl_Button*                  _cancel;
    Fl_Button*                  _close;
    Fl_Input*                   _file;
    Fl_Input*                   _password1;
    Fl_Input*                   _password2;
    GridGroup*                  _grid;
    Mode                        _mode;
    bool                        _ret;
    bool                        _run;
public:
    _DlgPassword(const std::string& title, Mode mode) :
    Fl_Double_Window(0, 0, 10, 10) {
        end();
        _browse    = new Fl_Button(0, 0, 0, 0, label::BROWSE.c_str());
        _cancel    = new Fl_Button(0, 0, 0, 0);
        _close     = new Fl_Return_Button(0, 0, 0, 0);
        _file      = new Fl_Output(0, 0, 0, 0, "Key file");
        _grid      = new GridGroup(0, 0, w(), h());
        _password1 = new Fl_Secret_Input(0, 0, 0, 0, "Password");
        _password2 = new Fl_Secret_Input(0, 0, 0, 0, "Enter password again");
        _mode      = mode;
        _ret       = false;
        _run       = false;
        _grid->add(_password1,  1,   3,  -1,  4);
        _grid->add(_password2,  1,  10,  -1,  4);
        _grid->add(_file,       1,  17,  -1,  4);
        _grid->add(_browse,   -51,  -5,  16,  4);
        _grid->add(_cancel,   -34,  -5,  16,  4);
        _grid->add(_close,    -17,  -5,  16,  4);
        add(_grid);
        _browse->callback(_DlgPassword::Callback, this);
        _cancel->callback(_DlgPassword::Callback, this);
        _cancel->copy_label(label::CANCEL.c_str());
        _close->callback(_DlgPassword::Callback, this);
        _close->copy_label(label::OK.c_str());
        _close->deactivate();
        _file->align(FL_ALIGN_TOP | FL_ALIGN_LEFT);
        _file->textfont(flw::PREF_FIXED_FONT);
        _file->textsize(flw::PREF_FONTSIZE);
        _file->tooltip("Select optional key file.");
        _password1->align(FL_ALIGN_TOP | FL_ALIGN_LEFT);
        _password1->callback(_DlgPassword::Callback, this);
        _password1->textfont(flw::PREF_FIXED_FONT);
        _password1->textsize(flw::PREF_FONTSIZE);
        _password1->when(FL_WHEN_CHANGED);
        _password2->align(FL_ALIGN_TOP | FL_ALIGN_LEFT);
        _password2->callback(_DlgPassword::Callback, this);
        _password2->textfont(flw::PREF_FIXED_FONT);
        _password2->textsize(flw::PREF_FONTSIZE);
        _password2->when(FL_WHEN_CHANGED);
        auto W = flw::PREF_FONTSIZE * 40;
        auto H = flw::PREF_FONTSIZE * 13.5;
        if (_mode == Mode::PASSWORD) {
            _password2->hide();
            _browse->hide();
            _file->hide();
            H = flw::PREF_FONTSIZE * 6.5;
        }
        else if (_mode == Mode::PASSWORD_CONFIRM) {
            _browse->hide();
            _file->hide();
            H = flw::PREF_FONTSIZE * 10;
        }
        else if (_mode == Mode::PASSWORD_WITH_FILE) {
            _password2->hide();
            _grid->resize(_file, 1, 10, -1, 4);
            H = flw::PREF_FONTSIZE * 10;
        }
        resizable(_grid);
        util::labelfont(this);
        callback(_DlgPassword::Callback, this);
        copy_label(title.c_str());
        size(W, H);
        set_modal();
        util::center_window(this, priv::PARENT);
        _grid->do_layout();
    }
    static void Callback(Fl_Widget* w, void* o) {
        auto self = static_cast<_DlgPassword*>(o);
        if (w == self || w == self->_cancel) {
            self->_ret = false;
            self->_run = false;
            self->hide();
        }
        else if (w == self->_password1) {
            self->check();
        }
        else if (w == self->_password2) {
            self->check();
        }
        else if (w == self->_browse) {
            auto filename = fl_file_chooser("Select Key File", nullptr, nullptr, 0);
            if (filename) {
                self->_file->value(filename);
            }
            else {
                self->_file->value("");
            }
            self->check();
        }
        else if (w == self->_close) {
            self->_ret = true;
            self->_run = false;
            self->hide();
        }
    }
    void check() {
        auto p1 = _password1->value();
        auto p2 = _password2->value();
        auto f  = _file->value();
        if (_mode == Mode::PASSWORD) {
            if (strlen(p1) > 0) {
                _close->activate();
            }
            else {
                _close->deactivate();
            }
        }
        else if (_mode == Mode::PASSWORD_CONFIRM) {
            if (strlen(p1) > 0 && strcmp(p1, p2) == 0) {
                _close->activate();
            }
            else {
                _close->deactivate();
            }
        }
        else if (_mode == Mode::PASSWORD_CONFIRM_WITH_FILE) {
            if (strlen(p1) > 0 && strcmp(p1, p2) == 0) {
                _close->activate();
            }
            else if (strlen(p1) == 0 && strlen(p2) == 0 && strlen(f) > 0) {
                _close->activate();
            }
            else {
                _close->deactivate();
            }
        }
        else if (_mode == Mode::PASSWORD_WITH_FILE) {
            if (strlen(p1) > 0) {
                _close->activate();
            }
            else if (strlen(f) > 0) {
                _close->activate();
            }
            else {
                _close->deactivate();
            }
        }
    }
    bool run(std::string& password, std::string& file) {
        _run = true;
        show();
        while (_run == true) {
            Fl::wait();
            Fl::flush();
        }
        if (_ret == true) {
            file = _file->value();
            password = _password1->value();
        }
        util::zero_memory(const_cast<char*>(_password1->value()), strlen(_password1->value()));
        util::zero_memory(const_cast<char*>(_password2->value()), strlen(_password2->value()));
        util::zero_memory(const_cast<char*>(_file->value()), strlen(_file->value()));
        return _ret;
    }
};
}
bool dlg::password(const std::string& title, std::string& password) {
    std::string file;
    priv::_DlgPassword dlg(title.c_str(), priv::_DlgPassword::Mode::PASSWORD);
    return dlg.run(password, file);
}
bool dlg::password_confirm(const std::string& title, std::string& password) {
    std::string file;
    priv::_DlgPassword dlg(title.c_str(), priv::_DlgPassword::Mode::PASSWORD_CONFIRM);
    return dlg.run(password, file);
}
bool dlg::password_confirm_and_file(const std::string& title, std::string& password, std::string& file) {
    priv::_DlgPassword dlg(title.c_str(), priv::_DlgPassword::Mode::PASSWORD_CONFIRM_WITH_FILE);
    return dlg.run(password, file);
}
bool dlg::password_and_file(const std::string& title, std::string& password, std::string& file) {
    priv::_DlgPassword dlg(title.c_str(), priv::_DlgPassword::Mode::PASSWORD_WITH_FILE);
    return dlg.run(password, file);
}
namespace priv {
class _DlgPrint : public Fl_Double_Window {
    Fl_Button*                  _close;
    Fl_Button*                  _file;
    Fl_Button*                  _print;
    Fl_Choice*                  _format;
    Fl_Choice*                  _layout;
    Fl_Hor_Slider*              _from;
    Fl_Hor_Slider*              _to;
    GridGroup*                  _grid;
    PrintCallback               _cb;
    bool                        _run;
    void*                       _data;
public:
    _DlgPrint(const std::string& title, PrintCallback cb, void* data, int from, int to) :
    Fl_Double_Window(0, 0, flw::PREF_FONTSIZE * 34, flw::PREF_FONTSIZE * 18) {
        end();
        _close  = new Fl_Button(0, 0, 0, 0, label::CLOSE.c_str());
        _file   = new Fl_Button(0, 0, 0, 0, "output.ps");
        _format = new Fl_Choice(0, 0, 0, 0);
        _from   = new Fl_Hor_Slider(0, 0, 0, 0);
        _grid   = new GridGroup(0, 0, w(), h());
        _layout = new Fl_Choice(0, 0, 0, 0);
        _print  = new Fl_Button(0, 0, 0, 0, label::PRINT.c_str());
        _to     = new Fl_Hor_Slider(0, 0, 0, 0);
        _cb     = cb;
        _data   = data;
        _run    = false;
        _grid->add(_from,     1,   3,  -1,   4);
        _grid->add(_to,       1,  10,  -1,   4);
        _grid->add(_format,   1,  15,  -1,   4);
        _grid->add(_layout,   1,  20,  -1,   4);
        _grid->add(_file,     1,  25,  -1,   4);
        _grid->add(_print,  -34,  -5,  16,   4);
        _grid->add(_close,  -17,  -5,  16,   4);
        add(_grid);
        util::labelfont(this);
        _close->callback(_DlgPrint::Callback, this);
        _file->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
        _file->callback(_DlgPrint::Callback, this);
        _file->tooltip("Select output PostScript file.");
        _format->textfont(flw::PREF_FONT);
        _format->textsize(flw::PREF_FONTSIZE);
        _from->align(FL_ALIGN_TOP | FL_ALIGN_LEFT);
        _from->callback(_DlgPrint::Callback, this);
        _from->color(FL_BACKGROUND2_COLOR);
        _from->range(from, to);
        _from->precision(0);
        _from->value(from);
        _from->tooltip("Start page number.");
        _layout->textfont(flw::PREF_FONT);
        _layout->textsize(flw::PREF_FONTSIZE);
        _print->callback(_DlgPrint::Callback, this);
        _to->align(FL_ALIGN_TOP | FL_ALIGN_LEFT);
        _to->callback(_DlgPrint::Callback, this);
        _to->color(FL_BACKGROUND2_COLOR);
        _to->range(from, to);
        _to->precision(0);
        _to->value(to);
        _to->tooltip("End page number.");
        if (from < 1 || from > to) {
            _from->deactivate();
            _from->range(0, 1);
            _from->value(0);
            _to->deactivate();
            _to->range(0, 1);
            _to->value(0);
        }
        else if (from == to) {
            _from->deactivate();
            _to->deactivate();
        }
        priv::_init_printer_formats(_format, _layout);
        _DlgPrint::Callback(_from, this);
        _DlgPrint::Callback(_to, this);
        callback(_DlgPrint::Callback, this);
        copy_label(title.c_str());
        set_modal();
        resizable(_grid);
        util::center_window(this, priv::PARENT);
        _grid->do_layout();
    }
    static void Callback(Fl_Widget* w, void* o) {
        auto self = static_cast<_DlgPrint*>(o);
        if (w == self || w == self->_close) {
            self->_run = false;
            self->hide();
        }
        else if (w == self->_file) {
            auto filename = fl_file_chooser("Save To PostScript File", "PostScript Files (*.ps)\tAll Files (*)", self->_file->label());
            if (filename != nullptr) {
                self->_file->copy_label(filename);
            }
        }
        else if (w == self->_from || w == self->_to) {
            auto l = util::format("%s page: %d", (w == self->_from) ? "From" : "To", (int) static_cast<Fl_Hor_Slider*>(w)->value());
            w->copy_label(l.c_str());
            self->redraw();
        }
        else if (w == self->_print) {
            self->print();
        }
    }
    void print() {
        auto from   = static_cast<int>(_from->value());
        auto to     = static_cast<int>(_to->value());
        auto format = static_cast<Fl_Paged_Device::Page_Format>(_format->value());
        auto layout = (_layout->value() == 0) ? Fl_Paged_Device::Page_Layout::PORTRAIT : Fl_Paged_Device::Page_Layout::LANDSCAPE;
        auto file   = _file->label();
        auto err    = (from == 0) ? util::print(file, format, layout, _cb, _data) : util::print(file, format, layout, _cb, _data, from, to);
        if (err != "") {
            dlg::msg_alert("Printing Error", util::format("Printing failed!\n%s", err.c_str()));
            return;
        }
        _run = false;
        hide();
    }
    void run() {
        _run = true;
        show();
        while (_run == true) {
            Fl::wait();
            Fl::flush();
        }
    }
};
}
void dlg::print(const std::string& title, PrintCallback cb, void* data, int from, int to) {
    priv::_DlgPrint dlg(title, cb, data, from, to);
    dlg.run();
}
namespace priv {
class _DlgPrintText : public Fl_Double_Window {
    Fl_Box*                     _label;
    Fl_Button*                  _close;
    Fl_Button*                  _file;
    Fl_Button*                  _fonts;
    Fl_Button*                  _print;
    Fl_Check_Button*            _border;
    Fl_Check_Button*            _wrap;
    Fl_Choice*                  _align;
    Fl_Choice*                  _format;
    Fl_Choice*                  _layout;
    Fl_Font                     _font;
    Fl_Fontsize                 _fontsize;
    Fl_Hor_Slider*              _line;
    Fl_Hor_Slider*              _tab;
    GridGroup*                  _grid;
    bool                        _ret;
    bool                        _run;
    const StringVector&         _text;
    std::string                 _label2;
public:
    _DlgPrintText(const std::string& title, const StringVector& text) :
    Fl_Double_Window(0, 0, flw::PREF_FONTSIZE * 34, flw::PREF_FONTSIZE * 35),
    _text(text) {
        end();
        _align    = new Fl_Choice(0, 0, 0, 0);
        _border   = new Fl_Check_Button(0, 0, 0, 0, "Print border");
        _close    = new Fl_Button(0, 0, 0, 0, label::CLOSE.c_str());
        _file     = new Fl_Button(0, 0, 0, 0, "output.ps");
        _fonts    = new Fl_Button(0, 0, 0, 0, "Courier - 14");
        _format   = new Fl_Choice(0, 0, 0, 0);
        _grid     = new GridGroup(0, 0, w(), h());
        _label    = new Fl_Box(0, 0, 0, 0);
        _layout   = new Fl_Choice(0, 0, 0, 0);
        _line     = new Fl_Hor_Slider(0, 0, 0, 0);
        _print    = new Fl_Button(0, 0, 0, 0, label::PRINT.c_str());
        _tab      = new Fl_Hor_Slider(0, 0, 0, 0);
        _wrap     = new Fl_Check_Button(0, 0, 0, 0, "Wrap lines");
        _ret      = false;
        _run      = false;
        _font     = FL_COURIER;
        _fontsize = 14;
        _grid->add(_border,   1,   1,  -1,   4);
        _grid->add(_wrap,     1,   6,  -1,   4);
        _grid->add(_line,     1,  13,  -1,   4);
        _grid->add(_tab,      1,  20,  -1,   4);
        _grid->add(_format,   1,  25,  -1,   4);
        _grid->add(_layout,   1,  30,  -1,   4);
        _grid->add(_align,    1,  35,  -1,   4);
        _grid->add(_fonts,    1,  40,  -1,   4);
        _grid->add(_file,     1,  45,  -1,   4);
        _grid->add(_label,    1,  50,  -1,   13);
        _grid->add(_print,  -34,  -5,  16,   4);
        _grid->add(_close,  -17,  -5,  16,   4);
        add(_grid);
        util::labelfont(this);
        _align->add("Left Align");
        _align->add("Center Align");
        _align->add("Right Align");
        _align->tooltip("Line numbers are only used for left aligned text.");
        _align->value(0);
        _align->textfont(flw::PREF_FONT);
        _align->textsize(flw::PREF_FONTSIZE);
        _border->tooltip("Print line border around the print area.");
        _close->callback(_DlgPrintText::Callback, this);
        _file->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
        _file->callback(_DlgPrintText::Callback, this);
        _file->tooltip("Select output PostScript file.");
        _fonts->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
        _fonts->callback(_DlgPrintText::Callback, this);
        _fonts->tooltip("Select font to use.");
        _format->textfont(flw::PREF_FONT);
        _format->textsize(flw::PREF_FONTSIZE);
        _label->align(FL_ALIGN_TOP | FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
        _label->box(FL_BORDER_BOX);
        _label->box(FL_THIN_DOWN_BOX);
        _layout->textfont(flw::PREF_FONT);
        _layout->textsize(flw::PREF_FONTSIZE);
        _line->align(FL_ALIGN_TOP | FL_ALIGN_LEFT);
        _line->callback(_DlgPrintText::Callback, this);
        _line->color(FL_BACKGROUND2_COLOR);
        _line->range(0, 6);
        _line->precision(0);
        _line->value(0);
        _line->tooltip("Set minimum line number width.\nSet to 0 to disable.");
        _print->callback(_DlgPrintText::Callback, this);
        _tab->align(FL_ALIGN_TOP | FL_ALIGN_LEFT);
        _tab->callback(_DlgPrintText::Callback, this);
        _tab->color(FL_BACKGROUND2_COLOR);
        _tab->range(0, 16);
        _tab->precision(0);
        _tab->value(0);
        _tab->tooltip("Replace tabs with spaces.\nSet to 0 to disable.");
        _wrap->tooltip("Wrap long lines or they will be clipped.");
        priv::_init_printer_formats(_format, _layout);
        _DlgPrintText::Callback(_line, this);
        _DlgPrintText::Callback(_tab, this);
        callback(_DlgPrintText::Callback, this);
        copy_label(title.c_str());
        set_modal();
        resizable(_grid);
        util::center_window(this, priv::PARENT);
        _grid->do_layout();
        set_label();
    }
    static void Callback(Fl_Widget* w, void* o) {
        auto self = static_cast<_DlgPrintText*>(o);
        if (w == self || w == self->_close) {
            self->_run = false;
            self->hide();
        }
        else if (w == self->_file) {
            auto filename = fl_file_chooser("Save To PostScript File", "PostScript Files (*.ps)\tAll Files (*)", self->_file->label());
            if (filename != nullptr) {
                self->_file->copy_label(filename);
            }
        }
        else if (w == self->_fonts) {
            auto dlg = dlg::Font(self->_font, self->_fontsize, "Select Print Font", true);
            if (dlg.run() == true) {
                auto l = util::format("%s - %d", dlg.fontname().c_str(), dlg.fontsize());
                self->_fonts->copy_label(l.c_str());
                self->_font     = dlg.font();
                self->_fontsize = dlg.fontsize();
            }
        }
        else if (w == self->_line) {
            auto l = util::format("Line number: %d", (int) self->_line->value());
            self->_line->copy_label(l.c_str());
            self->redraw();
        }
        else if (w == self->_print) {
            self->print();
        }
        else if (w == self->_tab) {
            auto l = util::format("Tab replacement: %d", (int) self->_tab->value());
            self->_tab->copy_label(l.c_str());
            self->redraw();
        }
    }
    void print() {
        auto border  = _border->value();
        auto wrap    = _wrap->value();
        auto line    = static_cast<int>(_line->value());
        auto tab     = static_cast<int>(_tab->value());
        auto format  = static_cast<Fl_Paged_Device::Page_Format>(_format->value());
        auto layout  = (_layout->value() == 0) ? Fl_Paged_Device::Page_Layout::PORTRAIT : Fl_Paged_Device::Page_Layout::LANDSCAPE;
        auto align   = (_align->value() == 0) ? FL_ALIGN_LEFT : (_align->value() == 1) ? FL_ALIGN_CENTER : FL_ALIGN_RIGHT;
        auto file    = _file->label();
        auto printer = util::PrintText(file, format, layout, _font, _fontsize, align, wrap, border, line);
        auto err     = printer.print(_text, tab);
        if (err == "") {
            auto s = _label2;
            s += util::format("\n%d page%s was printed.", printer.page_count(), printer.page_count() > 1 ? "s" : "");
            _label->copy_label(s.c_str());
            _ret = true;
        }
        else {
            auto s = _label2;
            s += util::format("\nPrinting failed!\n%s", err.c_str());
            _label->copy_label(s.c_str());
            _ret = false;
        }
        redraw();
    }
    bool run() {
        _run = true;
        show();
        while (_run == true) {
            Fl::wait();
            Fl::flush();
        }
        return _ret;
    }
    void set_label() {
        auto len = 0;
        for (auto& s : _text) {
            auto l = fl_utf_nb_char((unsigned char*) s.c_str(), (int) s.length());
            if (l > len) {
                len = l;
            }
        }
        _label2 = util::format("Text contains %u lines.\nMax line length are %u characters.", (unsigned) _text.size(), (unsigned) len);
        _label->copy_label(_label2.c_str());
    }
};
}
bool dlg::print_text(const std::string& title, const std::string& text) {
    auto lines = util::split_string(text, "\n");
    priv::_DlgPrintText dlg(title, lines);
    return dlg.run();
}
bool dlg::print_text(const std::string& title, const StringVector& text) {
    priv::_DlgPrintText dlg(title, text);
    return dlg.run();
}
namespace priv {
class _DlgSelectCheckBoxes : public Fl_Double_Window {
    Fl_Button*                  _all;
    Fl_Button*                  _cancel;
    Fl_Button*                  _close;
    Fl_Button*                  _invert;
    Fl_Button*                  _none;
    Fl_Scroll*                  _scroll;
    GridGroup*                  _grid;
    const StringVector&         _labels;
    WidgetVector                _checkbuttons;
    bool                        _ret;
    bool                        _run;
public:
    _DlgSelectCheckBoxes(const std::string& title, const StringVector& strings) :
    Fl_Double_Window(0, 0, flw::PREF_FONTSIZE * 36, flw::PREF_FONTSIZE * 20),
    _labels(strings) {
        end();
        _all    = new Fl_Button(0, 0, 0, 0, "All On");
        _cancel = new Fl_Button(0, 0, 0, 0, label::CANCEL.c_str());
        _close  = new Fl_Return_Button(0, 0, 0, 0, label::OK.c_str());
        _grid   = new GridGroup(0, 0, w(), h());
        _invert = new Fl_Button(0, 0, 0, 0, "Invert");
        _none   = new Fl_Button(0, 0, 0, 0, "All Off");
        _scroll = new Fl_Scroll(0, 0, 0, 0);
        _ret    = false;
        _run    = false;
        _grid->add(_scroll,   1,  1, -1, -7);
        _grid->add(_invert, -67, -5, 10,  4);
        _grid->add(_none,   -56, -5, 10,  4);
        _grid->add(_all,    -45, -5, 10,  4);
        _grid->add(_cancel, -34, -5, 16,  4);
        _grid->add(_close,  -17, -5, 16,  4);
        add(_grid);
        for (auto& l : _labels) {
            auto b = new Fl_Check_Button(0, 0, 0, 0, l.c_str() + 1);
            b->value(*l.c_str() == '1');
            _checkbuttons.push_back(b);
            _scroll->add(b);
        }
        _all->callback(_DlgSelectCheckBoxes::Callback, this);
        _cancel->callback(_DlgSelectCheckBoxes::Callback, this);
        _close->callback(_DlgSelectCheckBoxes::Callback, this);
        _invert->callback(_DlgSelectCheckBoxes::Callback, this);
        _none->callback(_DlgSelectCheckBoxes::Callback, this);
        _scroll->box(FL_BORDER_BOX);
        util::labelfont(this);
        callback(_DlgSelectCheckBoxes::Callback, this);
        copy_label(title.c_str());
        set_modal();
        resizable(_grid);
        util::center_window(this, priv::PARENT);
    }
    static void Callback(Fl_Widget* w, void* o) {
        auto self = static_cast<_DlgSelectCheckBoxes*>(o);
        if (w == self || w == self->_cancel) {
            self->_run = false;
            self->hide();
        }
        else if (w == self->_close) {
            self->_ret = true;
            self->_run = false;
            self->hide();
        }
        else if (w == self->_all) {
            for (auto b : self->_checkbuttons) {
                static_cast<Fl_Check_Button*>(b)->value(1);
            }
        }
        else if (w == self->_none) {
            for (auto b : self->_checkbuttons) {
                static_cast<Fl_Check_Button*>(b)->value(0);
            }
        }
        else if (w == self->_invert) {
            for (auto b : self->_checkbuttons) {
                static_cast<Fl_Check_Button*>(b)->value(static_cast<Fl_Check_Button*>(b)->value() ? 0 : 1);
            }
        }
    }
    void resize(int X, int Y, int W, int H) override {
        Fl_Double_Window::resize(X, Y, W, H);
        _grid->resize(0, 0, W, H);
        auto y = _scroll->y() + 4;
        for (auto b : _checkbuttons) {
            b->resize(_scroll->x() + 4, y, _scroll->w() - Fl::scrollbar_size() - 8, flw::PREF_FONTSIZE * 2);
            y += flw::PREF_FONTSIZE * 2;
        }
    }
    StringVector run() {
        StringVector res;
        _run = true;
        show();
        while (_run == true) {
            Fl::wait();
            Fl::flush();
        }
        if (_ret == true) {
            for (auto b : _checkbuttons) {
                res.push_back(std::string((static_cast<Fl_Check_Button*>(b)->value() == 0) ? "0" : "1") + b->label());
            }
        }
        return res;
    }
};
}
StringVector dlg::select_checkboxes(const std::string& title, const StringVector& list) {
    priv::_DlgSelectCheckBoxes dlg(title, list);
    return dlg.run();
}
namespace priv {
class _DlgSelectChoice : public Fl_Double_Window {
    Fl_Button*                  _cancel;
    Fl_Button*                  _close;
    Fl_Choice*                  _choice;
    GridGroup*                  _grid;
    bool                        _run;
    int                         _ret;
public:
    _DlgSelectChoice(const std::string& title, const StringVector& strings, int selected) :
    Fl_Double_Window(0, 0, flw::PREF_FONTSIZE * 30, flw::PREF_FONTSIZE * 6) {
        end();
        _cancel = new Fl_Button(0, 0, 0, 0, label::CANCEL.c_str());
        _choice = new Fl_Choice(0, 0, 0, 0);
        _close  = new Fl_Return_Button(0, 0, 0, 0, label::OK.c_str());
        _grid   = new GridGroup(0, 0, w(), h());
        _ret    = -1;
        _run    = false;
        _grid->add(_choice,   1,  1, -1,  4);
        _grid->add(_cancel, -34, -5, 16,  4);
        _grid->add(_close,  -17, -5, 16,  4);
        add(_grid);
        for (const auto& string : strings) {
            _choice->add(string.c_str());
        }
        _cancel->callback(_DlgSelectChoice::Callback, this);
        _choice->textfont(flw::PREF_FONT);
        _choice->textsize(flw::PREF_FONTSIZE);
        _choice->value(selected);
        _close->callback(_DlgSelectChoice::Callback, this);
        util::labelfont(this);
        callback(_DlgSelectChoice::Callback, this);
        copy_label(title.c_str());
        set_modal();
        resizable(_grid);
        util::center_window(this, priv::PARENT);
        _grid->do_layout();
    }
    static void Callback(Fl_Widget* w, void* o) {
        auto self = static_cast<_DlgSelectChoice*>(o);
        if (w == self || w == self->_cancel) {
            self->_run = false;
            self->hide();
        }
        else if (w == self->_close) {
            self->_ret = self->_choice->value();
            self->_run = false;
            self->hide();
        }
    }
    int run() {
        _run = true;
        show();
        while (_run == true) {
            Fl::wait();
            Fl::flush();
        }
        return _ret;
    }
};
}
int dlg::select_choice(const std::string& title, const StringVector& list, int selected) {
    priv::_DlgSelectChoice dlg(title, list, selected);
    return dlg.run();
}
namespace priv {
class _DlgSelectString : public Fl_Double_Window {
    Fl_Button*                  _cancel;
    Fl_Button*                  _close;
    Fl_Input*                   _filter;
    GridGroup*                  _grid;
    ScrollBrowser*              _list;
    const StringVector&         _strings;
    bool                        _run;
public:
    _DlgSelectString(const std::string& title, const StringVector& strings, int selected_string_index, const std::string& selected_string, bool fixed_font, int W, int H) :
    Fl_Double_Window(0, 0, ((fixed_font == true) ? flw::PREF_FIXED_FONTSIZE : flw::PREF_FONTSIZE) * W, ((fixed_font == true) ? flw::PREF_FIXED_FONTSIZE : flw::PREF_FONTSIZE) * H),
    _strings(strings) {
        end();
        _cancel = new Fl_Button(0, 0, 0, 0, label::CANCEL.c_str());
        _close  = new Fl_Return_Button(0, 0, 0, 0, label::SELECT.c_str());
        _filter = new Fl_Input(0, 0, 0, 0);
        _grid   = new GridGroup(0, 0, w(), h());
        _list   = new ScrollBrowser(0, 0, 0, 0);
        _run    = false;
        _grid->add(_filter,   1,  1, -1,  4);
        _grid->add(_list,     1,  6, -1, -6);
        _grid->add(_cancel, -34, -5, 16,  4);
        _grid->add(_close,  -17, -5, 16,  4);
        add(_grid);
        _cancel->callback(_DlgSelectString::Callback, this);
        _close->callback(_DlgSelectString::Callback, this);
        _filter->callback(_DlgSelectString::Callback, this);
        _filter->tooltip("Enter text to filter rows that macthes the text.\nPress tab to switch focus between input and list widget.");
        _filter->when(FL_WHEN_CHANGED);
        _list->callback(_DlgSelectString::Callback, this);
        _list->tooltip("Use Page Up or Page Down in list to scroll faster,");
        if (fixed_font == true) {
            _filter->textfont(flw::PREF_FIXED_FONT);
            _filter->textsize(flw::PREF_FIXED_FONTSIZE);
            _list->textfont(flw::PREF_FIXED_FONT);
            _list->textsize(flw::PREF_FIXED_FONTSIZE);
        }
        else {
            _filter->textfont(flw::PREF_FONT);
            _filter->textsize(flw::PREF_FONTSIZE);
            _list->textfont(flw::PREF_FONT);
            _list->textsize(flw::PREF_FONTSIZE);
        }
        {
            auto r = 0;
            auto f = 0;
            for (const auto& string : _strings) {
                _list->add(string.c_str());
                if (string == selected_string) {
                    r = f + 1;
                }
                f++;
            }
            if (selected_string_index > 0 && selected_string_index <= (int) _strings.size()) {
                _list->value(selected_string_index);
                _list->middleline(selected_string_index);
            }
            else if (r > 0) {
                _list->value(r);
                _list->middleline(r);
            }
            else {
                _list->value(1);
            }
        }
        _filter->take_focus();
        util::labelfont(this);
        callback(_DlgSelectString::Callback, this);
        copy_label(title.c_str());
        activate_button();
        set_modal();
        resizable(_grid);
        util::center_window(this, priv::PARENT);
        _grid->do_layout();
    }
    void activate_button() {
        if (_list->value() == 0) {
            _close->deactivate();
        }
        else {
            _close->activate();
        }
    }
    static void Callback(Fl_Widget* w, void* o) {
        auto self = static_cast<_DlgSelectString*>(o);
        if (w == self || w == self->_cancel) {
            self->_list->deselect();
            self->_run = false;
            self->hide();
        }
        else if (w == self->_close) {
            self->_run = false;
            self->hide();
        }
        else if (w == self->_filter) {
            self->filter(self->_filter->value());
            self->activate_button();
        }
        else if (w == self->_list) {
            self->activate_button();
            if (Fl::event_clicks() > 0 && self->_close->active()) {
                Fl::event_clicks(0);
                self->_run = false;
                self->hide();
            }
        }
    }
    void filter(const std::string& filter) {
        _list->clear();
        for (const auto& string : _strings) {
            if (filter == "") {
                _list->add(string.c_str());
            }
            else if (string.find(filter) != std::string::npos) {
                _list->add(string.c_str());
            }
        }
        _list->value(1);
    }
    int handle(int event) override {
        if (event == FL_KEYDOWN) {
            if (Fl::event_key() == FL_Enter) {
                if (_list->value() > 0) {
                    _run = false;
                    hide();
                }
                return 1;
            }
            else if (Fl::event_key() == FL_Tab) {
                if (Fl::focus() == _list || Fl::focus() == _list->menu()) {
                    _filter->take_focus();
                }
                else {
                    _list->take_focus();
                }
                return 1;
            }
        }
        return Fl_Double_Window::handle(event);
    }
    int run() {
        _run = true;
        show();
        while (_run == true) {
            Fl::wait();
            Fl::flush();
        }
        auto row = _list->value();
        if (row > 0) {
            auto selected = _list->text(row);
            for (int f = 0; f < static_cast<int>(_strings.size()); f++) {
                const auto& string = _strings[f];
                if (string == selected) {
                    return f;
                }
            }
        }
        return -1;
    }
};
}
int dlg::select_string(const std::string& title, const StringVector& list, int selected_row, bool fixed_font, int W, int H) {
    priv::_DlgSelectString dlg(title.c_str(), list, selected_row, "", fixed_font, W, H);
    return dlg.run();
}
int dlg::select_string(const std::string& title, const StringVector& list, const std::string& selected_row, bool fixed_font, int W, int H) {
    priv::_DlgSelectString dlg(title.c_str(), list, 0, selected_row, fixed_font, W, H);
    return dlg.run();
}
namespace priv {
class _DlgSlider : public Fl_Double_Window {
    Fl_Button*                  _cancel;
    Fl_Button*                  _close;
    Fl_Hor_Value_Slider*        _slider;
    GridGroup*                  _grid;
    bool                        _ret;
    bool                        _run;
    double&                     _value;
public:
    _DlgSlider(const std::string& title, double min, double max, double& value, double step) :
    Fl_Double_Window(0, 0, flw::PREF_FONTSIZE * 40, flw::PREF_FONTSIZE * 6),
    _value(value) {
        end();
        _cancel = new Fl_Button(0, 0, 0, 0, label::CANCEL.c_str());
        _slider = new Fl_Hor_Value_Slider(0, 0, 0, 0);
        _close  = new Fl_Return_Button(0, 0, 0, 0, label::OK.c_str());
        _grid   = new GridGroup(0, 0, w(), h());
        _ret    = false;
        _run    = false;
        _grid->add(_slider,   1,  1, -1,  4);
        _grid->add(_cancel, -34, -5, 16,  4);
        _grid->add(_close,  -17, -5, 16,  4);
        add(_grid);
        _cancel->callback(_DlgSlider::Callback, this);
        _slider->align(FL_ALIGN_LEFT    );
        _slider->callback(_DlgSlider::Callback, this);
        _slider->range(min, max);
        _slider->value(value);
        _slider->step(step);
        _slider->textfont(flw::PREF_FONT);
        _slider->textsize(flw::PREF_FONTSIZE);
        _close->callback(_DlgSlider::Callback, this);
        util::labelfont(this);
        callback(_DlgSlider::Callback, this);
        copy_label(title.c_str());
        set_modal();
        resizable(_grid);
        util::center_window(this, priv::PARENT);
        _grid->do_layout();
        _slider->value_width((max >= 100'000) ? flw::PREF_FONTSIZE * 10 : flw::PREF_FONTSIZE * 6);
    }
    static void Callback(Fl_Widget* w, void* o) {
        auto self = static_cast<_DlgSlider*>(o);
        if (w == self || w == self->_cancel) {
            self->_run = false;
            self->hide();
        }
        else if (w == self->_close) {
            self->_ret = true;
            self->_run = false;
            self->_value = self->_slider->value();
            self->hide();
        }
    }
    int run() {
        _run = true;
        show();
        while (_run == true) {
            Fl::wait();
            Fl::flush();
        }
        return _ret;
    }
};
}
bool dlg::slider(const std::string& title, double min, double max, double& value, double step) {
    priv::_DlgSlider dlg(title.c_str(), min, max, value, step);
    return dlg.run();
}
namespace priv {
class _DlgText : public Fl_Double_Window {
    Fl_Button*                  _cancel;
    Fl_Button*                  _close;
    Fl_Button*                  _save;
    Fl_Text_Buffer*             _buffer;
    Fl_Text_Display*            _text;
    GridGroup*                  _grid;
    bool                        _edit;
    bool                        _run;
    char*                       _res;
public:
    _DlgText(const std::string& title, const char* text, bool edit, int W, int H) :
    Fl_Double_Window(0, 0, flw::PREF_FONTSIZE * W, flw::PREF_FONTSIZE * H) {
        end();
        _buffer = new Fl_Text_Buffer();
        _cancel = new Fl_Button(0, 0, 0, 0, label::CANCEL.c_str());
        _close  = new Fl_Return_Button(0, 0, 0, 0, (edit == true) ? label::UPDATE.c_str() : label::CLOSE.c_str());
        _grid   = new GridGroup(0, 0, w(), h());
        _save   = new Fl_Button(0, 0, 0, 0, label::SAVE_DOT.c_str());
        _text   = (edit == false) ? new Fl_Text_Display(0, 0, 0, 0) : new Fl_Text_Editor(0, 0, 0, 0);
        _edit   = edit;
        _res    = nullptr;
        _run    = false;
        if (edit == false) {
            _cancel->hide();
            _grid->add(_text,     1,   1,  -1,  -6);
            _grid->add(_save,   -34,  -5,  16,   4);
            _grid->add(_close,  -17,  -5,  16,   4);
        }
        else {
            _grid->add(_text,     1,   1,  -1,  -6);
            _grid->add(_save,   -51,  -5,  16,   4);
            _grid->add(_cancel, -34,  -5,  16,   4);
            _grid->add(_close,  -17,  -5,  16,   4);
        }
        add(_grid);
        _buffer->text(text);
        _cancel->callback(_DlgText::Callback, this);
        _cancel->tooltip("Close and abort all changes.");
        _close->callback(_DlgText::Callback, this);
        _close->tooltip(_edit == true ? "Update text and close window." : "Close window.");
        _save->callback(_DlgText::Callback, this);
        _save->tooltip("Save text to file.");
        _text->buffer(_buffer);
        _text->linenumber_align(FL_ALIGN_RIGHT);
        _text->linenumber_bgcolor(FL_BACKGROUND_COLOR);
        _text->linenumber_fgcolor(FL_FOREGROUND_COLOR);
        _text->linenumber_font(flw::PREF_FIXED_FONT);
        _text->linenumber_size(flw::PREF_FIXED_FONTSIZE);
        _text->linenumber_width(flw::PREF_FIXED_FONTSIZE * 3);
        _text->take_focus();
        _text->textfont(flw::PREF_FIXED_FONT);
        _text->textsize(flw::PREF_FIXED_FONTSIZE);
        util::labelfont(this);
        callback(_DlgText::Callback, this);
        copy_label(title.c_str());
        set_modal();
        resizable(_grid);
        util::center_window(this, priv::PARENT);
        _grid->do_layout();
    }
    ~_DlgText() {
       _text->buffer(nullptr);
        delete _buffer;
    }
    static void Callback(Fl_Widget* w, void* o) {
        auto self = static_cast<_DlgText*>(o);
        if (w == self || w == self->_cancel) {
            self->_run = false;
            self->hide();
        }
        else if (w == self->_save) {
            auto filename = fl_file_chooser("Select Destination File", nullptr, nullptr, 0);
            if (filename != nullptr && self->_buffer->savefile(filename) != 0) {
                dlg::msg_alert("Save Error", util::format("Failed to save text to %s", filename));
            }
        }
        else if (w == self->_close) {
            if (self->_edit == true) {
                self->_res = self->_buffer->text();
            }
            self->_run = false;
            self->hide();
        }
    }
    char* run() {
        _run = true;
        show();
        while (_run == true) {
            Fl::wait();
            Fl::flush();
        }
        return _res;
    }
};
}
void dlg::text(const std::string& title, const std::string& text, int W, int H) {
    priv::_DlgText dlg(title.c_str(), text.c_str(), false, W, H);
    dlg.run();
}
bool dlg::text_edit(const std::string& title, std::string& text, int W, int H) {
    auto dlg = priv::_DlgText(title.c_str(), text.c_str(), true, W, H);
    auto res = dlg.run();
    if (res == nullptr) {
        return false;
    }
    text = res;
    free(res);
    return true;
}
namespace priv {
class _DlgTheme : public Fl_Double_Window {
    Fl_Box*                     _fixed_label;
    Fl_Box*                     _font_label;
    Fl_Browser*                 _theme;
    Fl_Button*                  _close;
    Fl_Button*                  _fixedfont;
    Fl_Button*                  _font;
    Fl_Check_Button*            _scale;
    Fl_Slider*                  _scale_val;
    GridGroup*                  _grid;
    bool                        _run;
    int                         _theme_row;
public:
    _DlgTheme(bool enable_font, bool enable_fixedfont) :
    Fl_Double_Window(0, 0, 10, 10, "Set Theme") {
        end();
        _close       = new Fl_Return_Button(0, 0, 0, 0, label::CLOSE.c_str());
        _fixedfont   = new Fl_Button(0, 0, 0, 0, label::MONO.c_str());
        _fixed_label = new Fl_Box(0, 0, 0, 0);
        _font        = new Fl_Button(0, 0, 0, 0, label::REGULAR.c_str());
        _font_label  = new Fl_Box(0, 0, 0, 0);
        _grid        = new GridGroup(0, 0, w(), h());
        _scale       = new Fl_Check_Button(0, 0, 0, 0, "!! Use Scaling");
        _scale_val   = new Fl_Slider(0, 0, 0, 0);
        _theme       = new Fl_Hold_Browser(0, 0, 0, 0);
        _theme_row   = 0;
        _run         = false;
        _grid->add(_theme,         1,   1,  -1, -21);
        _grid->add(_font_label,    1, -20,  -1,   4);
        _grid->add(_fixed_label,   1, -15,  -1,   4);
        _grid->add(_scale,         1, -10,  19,   4);
        _grid->add(_scale_val,    25, -10,  -1,   4);
        _grid->add(_font,        -51,  -5,  16,   4);
        _grid->add(_fixedfont,   -34,  -5,  16,   4);
        _grid->add(_close,       -17,  -5,  16,   4);
        add(_grid);
        if (enable_font == false) {
          _font->deactivate();
        }
        if (enable_fixedfont == false) {
          _fixedfont->deactivate();
        }
        _close->callback(_DlgTheme::Callback, this);
        _fixed_label->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
        _fixed_label->box(FL_BORDER_BOX);
        _fixed_label->color(FL_BACKGROUND2_COLOR);
        _fixed_label->tooltip("Default fixed font.");
        _fixedfont->callback(_DlgTheme::Callback, this);
        _fixedfont->tooltip("Set default fixed font.");
        _font->callback(_DlgTheme::Callback, this);
        _font->tooltip("Set default font.");
        _font_label->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
        _font_label->box(FL_BORDER_BOX);
        _font_label->color(FL_BACKGROUND2_COLOR);
        _font_label->tooltip("Default font.");
        _scale->callback(_DlgTheme::Callback, this);
        _scale->tooltip(
            "Turn on/off FLTK scaling for HiDPI screens.\n"
            "This work somewhat different depending on what desktop it is running on.\n"
            "Save settings and restart application."
        );
        _scale->value(flw::PREF_SCALE_ON);
        _scale_val->range(0.5, 2.0);
        _scale_val->step(0.05);
        _scale_val->value(flw::PREF_SCALE_VAL);
        _scale_val->type(FL_HORIZONTAL);
        _scale_val->callback(_DlgTheme::Callback, this);
        _scale_val->align(FL_ALIGN_LEFT);
        _scale_val->tooltip("Set scaling factor.");
        _theme->box(FL_BORDER_BOX);
        _theme->callback(_DlgTheme::Callback, this);
        _theme->textfont(flw::PREF_FONT);
        for (auto& name : flw::PREF_THEMES) {
            _theme->add(name.c_str());
        }
        if (Fl::screen_scaling_supported() == 0) {
            _scale->value(0);
            _scale->deactivate();
            _scale_val->deactivate();
        }
        _DlgTheme::Callback(_scale_val, this);
        resizable(_grid);
        callback(_DlgTheme::Callback, this);
        set_modal();
        update_pref();
        util::center_window(this, priv::PARENT);
    }
    static void Callback(Fl_Widget* w, void* o) {
        auto self = static_cast<_DlgTheme*>(o);
        if (w == self || w == self->_close) {
            self->_run = false;
            self->hide();
        }
        else if (w == self->_fixedfont) {
            dlg::Font fd(flw::PREF_FIXED_FONT, flw::PREF_FIXED_FONTSIZE, "Select Monospaced Font");
            if (fd.run() == true) {
                flw::PREF_FIXED_FONT     = fd.font();
                flw::PREF_FIXED_FONTSIZE = fd.fontsize();
                flw::PREF_FIXED_FONTNAME = fd.fontname();
                if (self->_font->active() == 0) {
                    flw::PREF_FONTSIZE = flw::PREF_FIXED_FONTSIZE;
                }
                self->update_pref();
            }
        }
        else if (w == self->_font) {
            dlg::Font fd(flw::PREF_FONT, flw::PREF_FONTSIZE, "Select Regular Font");
            if (fd.run() == true) {
                flw::PREF_FONT     = fd.font();
                flw::PREF_FONTSIZE = fd.fontsize();
                flw::PREF_FONTNAME = fd.fontname();
                Fl_Tooltip::font(flw::PREF_FONT);
                Fl_Tooltip::size(flw::PREF_FONTSIZE);
                if (self->_fixedfont->active() == 0) {
                    flw::PREF_FIXED_FONTSIZE = flw::PREF_FONTSIZE;
                }
                self->update_pref();
                #if defined(__linux__)
                    self->hide();
                    self->show();
                #endif
            }
        }
        else if (w == self->_theme) {
            auto row = self->_theme->value() - 1;
            if (row == priv::THEME_GLEAM) {
                priv::_load_gleam();
            }
            else if (row == priv::THEME_GLEAM_BLUE) {
                priv::_load_gleam_blue();
            }
            else if (row == priv::THEME_GLEAM_DARK) {
                priv::_load_gleam_dark();
            }
            else if (row == priv::THEME_GLEAM_TAN) {
                priv::_load_gleam_tan();
            }
            else if (row == priv::THEME_GTK) {
                priv::_load_gtk();
            }
            else if (row == priv::THEME_GTK_BLUE) {
                priv::_load_gtk_blue();
            }
            else if (row == priv::THEME_GTK_DARK) {
                priv::_load_gtk_dark();
            }
            else if (row == priv::THEME_GTK_TAN) {
                priv::_load_gtk_tan();
            }
            else if (row == priv::THEME_OXY) {
                priv::_load_oxy();
            }
            else if (row == priv::THEME_OXY_TAN) {
                priv::_load_oxy_tan();
            }
            else if (row == priv::THEME_PLASTIC) {
                priv::_load_plastic();
            }
            else if (row == priv::THEME_PLASTIC_TAN) {
                priv::_load_plastic_tan();
            }
            else {
                priv::_load_default();
            }
            self->update_pref();
        }
        else if (w == self->_scale) {
            flw::PREF_SCALE_ON = self->_scale->value();
        }
        else if (w == self->_scale_val) {
            flw::PREF_SCALE_VAL = self->_scale_val->value();
            self->_scale_val->copy_label(util::format("%.2f", flw::PREF_SCALE_VAL).c_str());
        }
    }
    void run() {
        _run = true;
        show();
        while (_run == true) {
            Fl::wait();
            Fl::flush();
        }
    }
    void update_pref() {
        size(flw::PREF_FONTSIZE * 30, flw::PREF_FONTSIZE * 32);
        _grid->resize(0, 0, w(), h());
        Fl_Tooltip::font(flw::PREF_FONT);
        Fl_Tooltip::size(flw::PREF_FONTSIZE);
        util::labelfont(this);
        _font_label->copy_label(util::format("%s - %d", flw::PREF_FONTNAME.c_str(), flw::PREF_FONTSIZE).c_str());
        _fixed_label->copy_label(util::format("%s - %d", flw::PREF_FIXED_FONTNAME.c_str(), flw::PREF_FIXED_FONTSIZE).c_str());
        _fixed_label->labelfont(flw::PREF_FIXED_FONT);
        _fixed_label->labelsize(flw::PREF_FIXED_FONTSIZE);
        _theme->textfont(flw::PREF_FONT);
        _theme->textsize(flw::PREF_FONTSIZE);
        priv::_scrollbar();
        for (int f = 0; f < priv::THEME_NIL; f++) {
            if (flw::PREF_THEME == flw::PREF_THEMES[f]) {
                _theme->value(f + 1);
                break;
            }
        }
        Fl::redraw();
    }
};
}
void dlg::theme(bool enable_font, bool enable_fixedfont) {
    auto dlg = priv::_DlgTheme(enable_font, enable_fixedfont);
    dlg.run();
}
namespace priv {
static const std::string _FONTDIALOG_LABEL = R"(
ABCDEFGHIJKLMNOPQRSTUVWXYZ /0123456789
abcdefghijklmnopqrstuvwxyz 
  
   

japanese: 
korean:  
tibetan: 
greek:   
ukrainian:  
thai: 
amharic:  
braille:     
math:  Eda = Q,  n  ,  f(i) 2H + O  2HO, R = 4.7 k

There is nothing else than now.
There is neither yesterday, certainly,
nor is there any tomorrow.
How old must you be before you know that?
There is only now, and if now is only two days,
then two days is your life and everything in it will be in proportion.
This is how you live a life in two days.
And if you stop complaining and asking for what you never will get,
you will have a good life.
A good life is not measured by any biblical span.
 Ernest Hemingway, For Whom the Bell Tolls
)";
class _FontLabel : public Fl_Box {
public:
    int font;
    int size;
    _FontLabel(int x, int y, int w, int h) : Fl_Box(x, y, w, h, _FONTDIALOG_LABEL.c_str()) {
        font = FL_HELVETICA;
        size = 14;
        align(FL_ALIGN_TOP | FL_ALIGN_LEFT | FL_ALIGN_INSIDE | FL_ALIGN_CLIP);
        box(FL_BORDER_BOX);
        color(FL_BACKGROUND2_COLOR);
    }
    void draw() override {
        draw_box();
        fl_font((Fl_Font) font, size);
        fl_color(FL_FOREGROUND_COLOR);
        fl_draw(label(), x() + 3, y() + 3, w() - 6, h() - 6, align());
    }
};
}
dlg::Font::Font(Fl_Font font, Fl_Fontsize fontsize, const std::string& title, bool limit_to_default) :
Fl_Double_Window(0, 0, flw::PREF_FONTSIZE * 64, flw::PREF_FONTSIZE * 36) {
    _create(font, "", fontsize, title, limit_to_default);
}
dlg::Font::Font(const std::string& font, Fl_Fontsize fontsize, const std::string& title, bool limit_to_default) :
Fl_Double_Window(0, 0, flw::PREF_FONTSIZE * 64, flw::PREF_FONTSIZE * 36) {
    _create(0, font, fontsize, title, limit_to_default);
}
void dlg::Font::_activate() {
    if (_fonts->value() == 0 || _sizes->value() == 0 || (_fonts->active() == 0 && _sizes->active() == 0)) {
        _select->deactivate();
    }
    else {
        _select->activate();
    }
}
void dlg::Font::Callback(Fl_Widget* w, void* o) {
    auto self = static_cast<Font*>(o);
    if (w == self || w == self->_cancel) {
        self->_run = false;
        self->hide();
    }
    else if (w == self->_fonts) {
        auto row = self->_fonts->value();
        if (row > 0) {
            static_cast<priv::_FontLabel*>(self->_label)->font = row - 1;
        }
        self->_activate();
        Fl::redraw();
    }
    else if (w == self->_select) {
        auto row1 = self->_fonts->value();
        auto row2 = self->_sizes->value();
        if (row1 > 0 && row2 > 0) {
            row1--;
            self->_fontname = util::remove_browser_format(util::to_string(flw::PREF_FONTNAMES[row1]));
            self->_font     = row1;
            self->_fontsize = row2 + 5;
            self->_ret      = true;
            self->_run      = false;
            self->hide();
        }
    }
    else if (w == self->_sizes) {
        auto row = self->_sizes->value();
        if (row > 0) {
            static_cast<priv::_FontLabel*>(self->_label)->size = row + 5;
        }
        self->_activate();
        Fl::redraw();
    }
}
void dlg::Font::_create(Fl_Font font, const std::string& fontname, Fl_Fontsize fontsize, const std::string& title, bool limit_to_default) {
    end();
    _cancel   = new Fl_Button(0, 0, 0, 0, label::CANCEL.c_str());
    _fonts    = new ScrollBrowser(12);
    _grid     = new GridGroup();
    _label    = new priv::_FontLabel(0, 0, 0, 0);
    _select   = new Fl_Button(0, 0, 0, 0, label::SELECT.c_str());
    _sizes    = new ScrollBrowser(6);
    _font     = -1;
    _fontsize = -1;
    _ret      = false;
    _run      = false;
    _grid->add(_fonts,    1,   1,  50,  -6);
    _grid->add(_sizes,   52,   1,  12,  -6);
    _grid->add(_label,   65,   1,  -1,  -6);
    _grid->add(_cancel, -34,  -5,  16,   4);
    _grid->add(_select, -17,  -5,  16,   4);
    add(_grid);
    _cancel->callback(Font::Callback, this);
    _cancel->labelfont(flw::PREF_FONT);
    _cancel->labelsize(flw::PREF_FONTSIZE);
    _fonts->box(FL_BORDER_BOX);
    _fonts->callback(Font::Callback, this);
    _fonts->textsize(flw::PREF_FONTSIZE);
    _fonts->when(FL_WHEN_CHANGED);
    static_cast<priv::_FontLabel*>(_label)->font = font;
    static_cast<priv::_FontLabel*>(_label)->size = fontsize;
    _select->callback(Font::Callback, this);
    _select->labelfont(flw::PREF_FONT);
    _select->labelsize(flw::PREF_FONTSIZE);
    _sizes->box(FL_BORDER_BOX);
    _sizes->callback(Font::Callback, this);
    _sizes->textsize(flw::PREF_FONTSIZE);
    _sizes->when(FL_WHEN_CHANGED);
    theme::load_fonts();
    auto count = 0;
    for (auto name : flw::PREF_FONTNAMES) {
        if (limit_to_default == true && count == 12) {
            break;
        }
        _fonts->add(name);
        count++;
    }
    for (auto f = 6; f <= 72; f++) {
        char buf[50];
        snprintf(buf, 50, "@r%2d  ", f);
        _sizes->add(buf);
    }
    if (fontsize >= 6 && fontsize <= 72) {
        _sizes->value(fontsize - 5);
        _sizes->middleline(fontsize - 5);
        static_cast<priv::_FontLabel*>(_label)->font = fontsize;
    }
    else {
        _sizes->value(14 - 5);
        _sizes->middleline(14 - 5);
        static_cast<priv::_FontLabel*>(_label)->font = 14;
    }
    if (fontname != "") {
        _select_name(fontname);
    }
    else if (font >= 0 && font < _fonts->size()) {
        _fonts->value(font + 1);
        _fonts->middleline(font + 1);
        static_cast<priv::_FontLabel*>(_label)->font = font;
    }
    else {
        _fonts->value(1);
        _fonts->middleline(1);
    }
    resizable(_grid);
    copy_label(title.c_str());
    callback(Font::Callback, this);
    set_modal();
    _fonts->take_focus();
    _grid->resize(0, 0, w(), h());
}
bool dlg::Font::run() {
    _ret = false;
    _run = true;
    _activate();
    util::center_window(this, priv::PARENT);
    show();
    while (_run == true) {
        Fl::wait();
        Fl::flush();
    }
    return _ret;
}
void dlg::Font::_select_name(const std::string& fontname) {
    auto count = 1;
    for (auto f : flw::PREF_FONTNAMES) {
        auto font_without_style = util::remove_browser_format(util::to_string(f));
        if (fontname == font_without_style) {
            _fonts->value(count);
            _fonts->middleline(count);
            static_cast<priv::_FontLabel*>(_label)->font = count - 1;
            return;
        }
        count++;
    }
    _fonts->value(1);
    static_cast<priv::_FontLabel*>(_label)->font = 0;
}
bool dlg::font(Fl_Font& font, Fl_Fontsize& fontsize, std::string& fontname, bool limit_to_default) {
    auto dlg = dlg::Font(font, fontsize, "Select Font", limit_to_default);
    if (dlg.run() == false) {
        return false;
    }
    font     = dlg.font();
    fontsize = dlg.fontsize();
    fontname = dlg.fontname();
    return true;
}
dlg::Progress::Progress(const std::string& title, bool cancel, bool pause, double min, double max) :
Fl_Double_Window(0, 0, flw::PREF_FONTSIZE * 40, flw::PREF_FONTSIZE * 12) {
    end();
    _cancel   = new Fl_Button(0, 0, 0, 0, label::CANCEL.c_str());
    _grid     = new GridGroup(0, 0, w(), h());
    _label    = new Fl_Hold_Browser(0, 0, 0, 0);
    _pause    = new Fl_Toggle_Button(0, 0, 0, 0, "&Pause");
    _progress = new Fl_Hor_Fill_Slider(0, 0, 0, 0);
    _ret      = true;
    _last     = 0;
    _grid->add(_label,     1,   1,  -1, -11);
    _grid->add(_progress,  1, -10,  -1,   4);
    _grid->add(_pause,   -34,  -5,  16,   4);
    _grid->add(_cancel,  -17,  -5,  16,   4);
    add(_grid);
    range(min, max);
    _cancel->callback(Progress::Callback, this);
    _label->box(FL_BORDER_BOX);
    _label->textfont(flw::PREF_FONT);
    _label->textsize(flw::PREF_FONTSIZE);
    _pause->callback(Progress::Callback, this);
    if (cancel == false) {
        _cancel->deactivate();
    }
    if (pause == false) {
        _pause->deactivate();
    }
    util::labelfont(this);
    callback(Progress::Callback, this);
    copy_label(title.c_str());
    set_modal();
    resizable(_grid);
    _grid->resize(0, 0, w(), h());
}
void dlg::Progress::Callback(Fl_Widget* w, void* o) {
    auto self = static_cast<Progress*>(o);
    if (w == self) {
    }
    else if (w == self->_cancel) {
        self->_ret = false;
    }
    else if (w == self->_pause) {
        bool cancel = self->_cancel->active();
        self->_cancel->deactivate();
        while (self->_pause->value() != 0) {
            util::sleep(20);
            Fl::check();
        }
        if (cancel == true) {
            self->_cancel->activate();
        }
    }
}
void dlg::Progress::range(double min, double max) {
    if (min < max && fabs(max - min) > 0.001) {
        _progress->show();
        _progress->range(min, max);
        _progress->value(min);
        _grid->resize(_label, 1, 1, -1, -11);
    }
    else {
        _progress->hide();
        _grid->resize(_label, 1, 1, -1, -6);
    }
}
void dlg::Progress::start() {
    util::center_window(this, priv::PARENT);
    Fl_Double_Window::show();
}
bool dlg::Progress::update(double value, const StringVector& messages, unsigned milli) {
    auto now = static_cast<unsigned>(util::milliseconds());
    if (now - _last > milli) {
        _progress->value(value);
        _label->clear();
        for (const auto& s : messages) {
            _label->add(s.c_str());
        }
        _last = now;
        Fl::check();
        Fl::flush();
    }
    return _ret;
}
bool dlg::Progress::update(const StringVector& messages, unsigned milli) {
    return update(0.0, messages, milli);
}
bool dlg::Progress::update(double value, const std::string& message, unsigned milli) {
    auto messages = std::vector<std::string>();
    messages.push_back(message);
    return update(value, messages, milli);
}
bool dlg::Progress::update(const std::string& message, unsigned milli) {
    return update(0.0, message, milli);
}
void dlg::Progress::value(double value) {
    if (value < _progress->minimum()) {
        _progress->value(_progress->minimum());
    }
    else if (value > _progress->maximum()) {
        _progress->value(_progress->maximum());
    }
    else {
        _progress->value(value);
    }
}
}
#include <FL/Fl_Double_Window.H>
#include <FL/Fl_Repeat_Button.H>
#include <FL/Fl_Return_Button.H>
#include <FL/fl_draw.H>
#include <time.h>
namespace flw {
class _DateChooserCanvas : public Fl_Widget {
    gnu::Date                   _date[7][8];
    std::string                 _text[7][8];
    int                         _col;
    int                         _row;
public:
    _DateChooserCanvas() :
    Fl_Widget(0, 0, 0, 0, 0) {
        _row   = 1;
        _col   = 1;
        _text[0][0] = "Week";
        _text[0][1] = "Mon";
        _text[0][2] = "Tue";
        _text[0][3] = "Wed";
        _text[0][4] = "Thu";
        _text[0][5] = "Fri";
        _text[0][6] = "Sat";
        _text[0][7] = "Sun";
    }
    void draw() override {
        int cw  = w() / 8;
        int ch  = h() / 7;
        int d   = 99;
        int col = 0;
        fl_rectf(x(), y(), w(), h(), FL_BACKGROUND_COLOR);
        for (int r = 0; r < 7; r++) {
            for (int c  = 0; c < 8; c++) {
                auto t  = _text[r][c];
                auto x1 = x() + (c * cw) + 1;
                auto y1 = y() + (r * ch) + 1;
                auto w1 = (c == 7) ? x() + w() - x1 : cw - 2;
                auto h1 = (r == 6) ? y() + h() - y1 : ch - 2;
                auto bg = FL_BACKGROUND_COLOR;
                auto fg = FL_FOREGROUND_COLOR;
                if (r == 0 || c == 0) {
                }
                else {
                    int v = atoi(t.c_str());
                    if (v <= d && col < 3) {
                        d = v;
                        col++;
                    }
                    if (r == _row && c == _col) {
                        bg = FL_SELECTION_COLOR;
                        fg = fl_contrast(FL_FOREGROUND_COLOR, bg);
                    }
                    else if (col == 2) {
                        bg = FL_BACKGROUND2_COLOR;
                    }
                    else {
                        bg = FL_DARK2;
                    }
                }
                fl_rectf(x1, y1, w1, h1, bg);
                fl_color(fg);
                fl_font(r == 0 || c == 0 ? FL_HELVETICA_BOLD : FL_HELVETICA, flw::PREF_FONTSIZE);
                fl_draw(t.c_str(), x1, y1, w1, h1, FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
                fl_rect(x1, y1, w1, h1, FL_DARK3);
            }
        }
    }
    gnu::Date get() {
        return _date[_row][_col];
    }
    int handle(int event) override {
        if (event == FL_PUSH) {
            take_focus();
            auto cw = (int) (w() / 8);
            auto ch = (int) (h() / 7);
            for (auto r = 1; r < 7; r++) {
                for (auto c = 1; c < 8; c++) {
                    auto x1 = (int) (x() + (c * cw));
                    auto y1 = (int) (y() + (r * ch));
                    if (Fl::event_x() >= x1 && Fl::event_x() < x1 + cw && Fl::event_y() >= y1 && Fl::event_y() < y1 + ch) {
                        _row = r;
                        _col = c;
                        do_callback();
                        redraw();
                        break;
                    }
                }
            }
            return 1;
        }
        else if (event == FL_FOCUS) {
            return 1;
        }
        else if (event == FL_KEYDOWN) {
            if (Fl::event_command() == 0) {
                int num = Fl::event_key();
                if (num == FL_Up) {
                    if (_row > 1) {
                        _row--;
                        redraw();
                        do_callback();
                    }
                    return 1;
                }
                else if (num == FL_Down) {
                    if (_row < 6) {
                        _row++;
                        redraw();
                        do_callback();
                    }
                    return 1;
                }
                else if (num == FL_Left) {
                    if (_col > 1) {
                        _col--;
                        redraw();
                        do_callback();
                    }
                    return 1;
                }
                else if (num == FL_Right) {
                    if (_col < 7) {
                        _col++;
                        redraw();
                        do_callback();
                    }
                    return 1;
                }
            }
        }
        return Fl_Widget::handle(event);
    }
    void set_current(int row, int col) {
        if (row != _row || col != _col) {
            _row = row;
            _col = col;
            do_callback();
        }
    }
    void set_date(int row, int col, const gnu::Date& date) {
        _date[row][col] = date;
    }
    void set_text(int row, int col, const std::string& text) {
        _text[row][col] = text;
    }
};
flw::DateChooser::DateChooser(int X, int Y, int W, int H, const char* l) :
GridGroup(X, Y, W, H, l) {
    end();
    _b1          = new Fl_Repeat_Button(0, 0, 0, 0, "@<<");
    _b2          = new Fl_Repeat_Button(0, 0, 0, 0, "@<");
    _b3          = new Fl_Repeat_Button(0, 0, 0, 0, "@>");
    _b4          = new Fl_Repeat_Button(0, 0, 0, 0, "@>>");
    _b5          = new Fl_Button(0, 0, 0, 0, "@refresh");
    _b6          = new Fl_Repeat_Button(0, 0, 0, 0, "@|<");
    _b7          = new Fl_Repeat_Button(0, 0, 0, 0, "@>|");
    _buttons     = new ToolGroup();
    _canvas      = new _DateChooserCanvas();
    _month_label = new Fl_Box(0, 0, 0, 0, "");
    gnu::Date date;
    set(date);
    _set_label();
    _buttons->add(_b6);
    _buttons->add(_b1);
    _buttons->add(_b2);
    _buttons->add(_b5, 8);
    _buttons->add(_b3);
    _buttons->add(_b4);
    _buttons->add(_b7);
    _buttons->expand_last(true);
    add(_buttons,     0, 0, 0, 4);
    add(_month_label, 0, 4, 0, 4);
    add(_canvas,      0, 8, 0, 0);
    _b1->callback(flw::DateChooser::_Callback, this);
    _b1->tooltip("Previous year.");
    _b2->callback(flw::DateChooser::_Callback, this);
    _b2->tooltip("Previous month.");
    _b3->callback(flw::DateChooser::_Callback, this);
    _b3->tooltip("Next month.");
    _b4->callback(flw::DateChooser::_Callback, this);
    _b4->tooltip("Next year.");
    _b5->callback(flw::DateChooser::_Callback, this);
    _b5->tooltip("Today.");
    _b6->callback(flw::DateChooser::_Callback, this);
    _b6->tooltip("10 years in the pas.t");
    _b7->callback(flw::DateChooser::_Callback, this);
    _b7->tooltip("10 years in the future.");
    _canvas->callback(flw::DateChooser::_Callback, this);
    _month_label->box(FL_UP_BOX);
    util::labelfont(this);
    tooltip("Use arrow keys to navigate\nUse ctrl+left/right to change month.");
    resizable(this);
    do_layout();
}
void flw::DateChooser::_Callback(Fl_Widget* w, void* o) {
    auto dc = static_cast<DateChooser*>(o);
    auto dt = dc->get();
    if (w == dc->_b6) {
        dt.add_months(-120);
        dc->set(dt);
    }
    else if (w == dc->_b1) {
        dt.add_months(-12);
        dc->set(dt);
    }
    else if (w == dc->_b2) {
        dt.add_months(-1);
        dc->set(dt);
    }
    else if (w == dc->_b5) {
        dt = gnu::Date(::time(0));
        dc->set(dt);
    }
    else if (w == dc->_b3) {
        dt.add_months(1);
        dc->set(dt);
    }
    else if (w == dc->_b4) {
        dt.add_months(12);
        dc->set(dt);
    }
    else if (w == dc->_b7) {
        dt.add_months(120);
        dc->set(dt);
    }
    else if (w == dc->_canvas) {
        dc->_set_label();
        dc->do_callback();
    }
    dc->_canvas->take_focus();
}
void flw::DateChooser::draw() {
    _month_label->labelfont(FL_HELVETICA_BOLD);
    Fl_Group::draw();
}
void flw::DateChooser::focus() {
    _canvas->take_focus();
}
gnu::Date flw::DateChooser::get() const {
    return static_cast<flw::_DateChooserCanvas*>(_canvas)->get();
}
int flw::DateChooser::handle(int event) {
    if (event == FL_KEYDOWN) {
        if (Fl::event_command()) {
            gnu::Date dt = get();
            if (Fl::event_key() == FL_Left) {
                dt.add_months(-1);
                set(dt);
                return 1;
            }
            else if (Fl::event_key() == FL_Right) {
                dt.add_months(+1);
                set(dt);
                return 1;
            }
        }
    }
    return Fl_Group::handle(event);
}
void flw::DateChooser::set(const gnu::Date& date) {
    auto arg    = date;
    auto canvas = static_cast<flw::_DateChooserCanvas*>(_canvas);
    if (arg.is_invalid() == true) {
        arg = gnu::Date();
    }
    else if (arg.year() < 2 && arg.month() < 2) {
        arg.set_month(2);
    }
    auto start_cell   = 0;
    auto first_date   = gnu::Date(arg.year(), arg.month(), 1);
    auto current_date = gnu::Date();
    char tmp[30];
    start_cell    = static_cast<int>(first_date.weekday()) - 1;
    start_cell    = start_cell + first_date.days_in_month() < 32 ? start_cell + 7 : start_cell;
    current_date  = first_date;
    current_date.add_days(-start_cell);
    for (auto r = 1; r <= 6; r++) {
        snprintf(tmp, 30, "%02d", current_date.week());
        canvas->set_text(r, 0, tmp);
        for (auto c = 1; c <= 7; c++) {
            snprintf(tmp, 30, "%02d", current_date.day());
            canvas->set_text(r, c, tmp);
            canvas->set_date(r, c, current_date);
            if (current_date.month() == arg.month() && current_date.day() == arg.day()) {
                canvas->set_current(r, c);
            }
            current_date.add_days(1);
        }
    }
    _set_label();
    redraw();
}
void flw::DateChooser::_set_label() {
    auto canvas = static_cast<flw::_DateChooserCanvas*>(_canvas);
    auto date   = canvas->get();
    auto string = date.format(gnu::Date::Format::WEEKDAY_MONTH_YEAR);
    _month_label->copy_label(string.c_str());
}
}
namespace flw {
struct _GridGroupChild {
    Fl_Widget*                  widget;
    Fl_Widget*                  focus;
    bool                        g;
    short                       x;
    short                       y;
    short                       w;
    short                       h;
    short                       l;
    short                       r;
    short                       t;
    short                       b;
    _GridGroupChild(Fl_Widget* WIDGET, Fl_Widget* F, int X, int Y, int W, int H) {
        widget = WIDGET;
        focus = F;
        set(X, Y, W, H);
        adjust();
    }
    void adjust(int L = 0, int R = 0, int T = 0, int B = 0) {
        l = L;
        r = R;
        t = T;
        b = B;
    }
    void set(int X, int Y, int W, int H) {
        x = X;
        y = Y;
        w = W;
        h = H;
    }
};
GridGroup::GridGroup(int X, int Y, int W, int H, const char* l) : Fl_Group(X, Y, W, H, l) {
    end();
    clip_children(1);
    resizable(nullptr);
    _size = 0;
}
GridGroup::~GridGroup() {
    for (auto v : _widgets) {
        delete static_cast<_GridGroupChild*>(v);
    }
}
void GridGroup::add(Fl_Widget* widget, int X, int Y, int W, int H, Fl_Widget* F) {
    _widgets.push_back(new _GridGroupChild(widget, F, X, Y, W, H));
    Fl_Group::add(widget);
}
void GridGroup::adjust(Fl_Widget* widget, int L, int R, int T, int B) {
    for (auto& v : _widgets) {
        auto child = static_cast<_GridGroupChild*>(v);
        if (child->widget == widget) {
            child->adjust(L, R, T, B);
            return;
        }
    }
#ifdef DEBUG
    fprintf(stderr, "Error: flw::GridGroup::adjust() failed to find widget (label=%s)!\n", widget->label());
#endif
}
void GridGroup::clear() {
    _widgets.clear();
    Fl_Group::clear();
}
int GridGroup::handle(int event) {
    if (event == FL_KEYDOWN && Fl::event_key() == FL_Tab) {
        if (children() > 0) {
            Fl_Widget* first   = nullptr;
            Fl_Widget* last    = nullptr;
            Fl_Widget* current = Fl::focus();
            _last_active_widget(&first, &last);
            if (Fl::event_shift() == 0 && first != nullptr && current != nullptr && current == last) {
                Fl::focus(first);
                redraw();
                return 1;
            }
            else if (Fl::event_shift() != 0 && first != nullptr && current != nullptr && current == first) {
                Fl::focus(last);
                redraw();
                return 1;
            }
        }
    }
    return Fl_Group::handle(event);
}
void GridGroup::_last_active_widget(Fl_Widget** first, Fl_Widget** last) {
    for (auto& v : _widgets) {
        auto child = static_cast<_GridGroupChild*>(v);
        auto g = child->widget->as_group();
        if (g == nullptr || child->focus != nullptr) {
            if (child->widget->active() != 0 && child->focus != nullptr) {
                *last = child->focus;
            }
            else if (child->widget->active() != 0) {
                *last = child->widget;
            }
            if (*first == nullptr && child->widget->active() != 0 && child->focus != nullptr) {
                *first = child->focus;
            }
            else if (*first == nullptr && child->widget->active() != 0) {
                *first = child->widget;
            }
        }
    }
}
Fl_Widget* GridGroup::remove(Fl_Widget* widget) {
    for (auto it = _widgets.begin(); it != _widgets.end(); it++) {
        auto child = static_cast<_GridGroupChild*>(*it);
        if (child->widget == widget) {
            delete child;
            Fl_Group::remove(widget);
            _widgets.erase(it);
            return widget;
        }
    }
#ifdef DEBUG
    fprintf(stderr, "Error: GridGroup::remove can't find widget!\n");
#endif
    return nullptr;
}
void GridGroup::resize(int X, int Y, int W, int H) {
    Fl_Widget::resize(X, Y, W, H);
    if (children() == 0 || W == 0 || H == 0 || visible() == 0) {
        return;
    }
    int size = (_size > 0) ? _size : flw::PREF_FONTSIZE / 2;
    for (const auto& v : _widgets) {
        auto child = static_cast<_GridGroupChild*>(v);
        if (child->widget != nullptr && child->widget->visible() != 0) {
            int widget_x  = 0;
            int widget_x2 = 0;
            int widget_y  = 0;
            int widget_y2 = 0;
            int widget_w  = 0;
            int widget_h  = 0;
            if (child->x >= 0) {
                widget_x = X + child->x * size;
            }
            else {
                widget_x = X + W + child->x * size;
            }
            if (child->y >= 0) {
                widget_y = Y + child->y * size;
            }
            else {
                widget_y = Y + H + child->y * size;
            }
            if (child->w == 0) {
                widget_x2 = X + W;
            }
            else if (child->w > 0) {
                widget_x2 = widget_x + child->w * size;
            }
            else {
                widget_x2 = X + W + child->w * size;
            }
            if (child->h == 0) {
                widget_y2 = Y + H;
            }
            else if (child->h > 0) {
                widget_y2 = widget_y + child->h * size;
            }
            else {
                widget_y2 = Y + H + child->h * size;
            }
            widget_w = widget_x2 - widget_x;
            widget_h = widget_y2 - widget_y;
            if (widget_w >= 0 && widget_h >= 0) {
                child->widget->resize(widget_x + child->l, widget_y + child->t, widget_w + child->r, widget_h + child->b);
            }
            else {
                child->widget->resize(0, 0, 0, 0);
            }
        }
    }
}
void GridGroup::resize(Fl_Widget* widget, int X, int Y, int W, int H) {
    for (auto& v : _widgets) {
        auto child = static_cast<_GridGroupChild*>(v);
        if (child->widget == widget) {
            child->set(X, Y, W, H);
            return;
        }
    }
#ifdef DEBUG
    fprintf(stderr, "Error: flw::GridGroup::resize() failed to find widget (label=%s)!\n", widget->label());
#endif
}
}
#include <algorithm>
namespace flw {
static constexpr const char* _INPUTMENU_TOOLTIP = "Use up/down arrows to switch between previous values.\nPress ctrl + space to open menu button (if visible).";
class _InputMenu : public Fl_Input {
public:
    bool            show_menu;
    int             index;
    StringVector    history;
    _InputMenu() : Fl_Input(0, 0, 0, 0) {
        index     = -1;
        show_menu = false;
    }
    int handle(int event) override {
        if (event == FL_KEYBOARD) {
            auto key = Fl::event_key();
            if (Fl::event_ctrl() != 0 && key == ' ') {
                if (history.size() > 0) {
                    show_menu = true;
                    do_callback();
                }
                return 1;
            }
            else if (key == FL_Up && history.size() > 0) {
                if (index <= 0) {
                    value("");
                    index = -1;
                }
                else {
                    index--;
                    show_menu = false;
                    value(history[index].c_str());
                }
                return 1;
            }
            else if (key == FL_Down && history.size() > 0 && index < static_cast<int>(history.size()) - 1) {
                index++;
                value(history[index].c_str());
                show_menu = false;
                return 1;
            }
            else {
                show_menu = false;
            }
        }
        return Fl_Input::handle(event);
    }
};
InputMenu::InputMenu(int X, int Y, int W, int H, const char* l) : Fl_Group(X, Y, W, H, l) {
    end();
    _input = new flw::_InputMenu();
    _menu  = new Fl_Menu_Button(0, 0, 0, 0);
    Fl_Group::add(_input);
    Fl_Group::add(_menu);
    _input->callback(InputMenu::_CallbackInput, this);
    _input->when(FL_WHEN_ENTER_KEY_ALWAYS);
    _menu->callback(InputMenu::_CallbackMenu, this);
    _menu->tooltip(_INPUTMENU_TOOLTIP);
    tooltip(_INPUTMENU_TOOLTIP);
    update_pref();
    resize(X, Y, W, H);
}
void InputMenu::_CallbackInput(Fl_Widget*, void* o) {
    auto self = static_cast<InputMenu*>(o);
    if (self->_input->show_menu == true) {
        if (self->_menu->visible() != 0) {
            self->_menu->popup();
        }
    }
    else {
        self->do_callback();
    }
}
void InputMenu::_CallbackMenu(Fl_Widget*, void* o) {
    auto self  = static_cast<InputMenu*>(o);
    auto index = self->_menu->find_index(self->_menu->text());
    if (index >= 0 && index < static_cast<int>(self->_input->history.size())) {
        self->_input->value(self->_input->history[index].c_str());
        self->_input->index = index;
    }
    self->_input->take_focus();
}
void InputMenu::clear() {
    _menu->clear();
    _input->history.clear();
    _input->index = -1;
}
flw::StringVector InputMenu::get_history() const {
    return _input->history;
}
void InputMenu::insert(const std::string& string, unsigned max_list_len) {
    for (auto it = _input->history.begin(); it != _input->history.end(); ++it) {
        if (*it == string) {
            _input->history.erase(it);
            break;
        }
    }
    _input->history.insert(_input->history.begin(), string);
    while (static_cast<unsigned>(_input->history.size()) > max_list_len) {
        _input->history.pop_back();
    }
    _menu->clear();
    for (const auto& s : _input->history) {
        _menu->add(flw::util::fix_menu_string(s.c_str()).c_str());
    }
    _input->index = -1;
    _input->value(string.c_str());
    _input->insert_position(string.length(), 0);
}
void InputMenu::resize(int X, int Y, int W, int H) {
    Fl_Widget::resize(X, Y, W, H);
    if (_menu->visible() != 0) {
        auto mw = flw::PREF_FONTSIZE;
        _input->resize(X, Y, W - flw::PREF_FONTSIZE - mw, H);
        _menu->resize(X + W - flw::PREF_FONTSIZE - mw, Y, flw::PREF_FONTSIZE + mw, H);
    }
    else {
        _input->resize(X, Y, W, H);
    }
}
void InputMenu::update_pref(Fl_Font text_font, Fl_Fontsize text_size) {
    labelfont(flw::PREF_FONT);
    labelsize(flw::PREF_FONTSIZE);
    _input->textfont(text_font);
    _input->textsize(text_size);
    _menu->textfont(text_font);
    _menu->textsize(text_size);
}
std::string InputMenu::value() const {
    return flw::util::to_string(_input->value());
}
void InputMenu::value(const std::string& string) {
    _input->value(string.c_str());
}
void InputMenu::_values(const StringVector& menu_list, const std::string& input_value) {
    clear();
    _input->history = menu_list;
    for (const auto& s : _input->history) {
        _menu->add(flw::util::fix_menu_string(s.c_str()).c_str());
    }
    _input->value(input_value.c_str());
    _input->insert_position(input_value.length(), 0);
}
}
namespace flw {
namespace util {
RecentMenu::RecentMenu(Fl_Menu_* menu, Fl_Callback* callback, void* userdata, const std::string& base_label, const std::string& clear_label) {
    _menu     = menu;
    _callback = callback;
    _base     = base_label;
    _clear    = clear_label;
    _user     = userdata;
    _max      = 10;
    _menu->add((_base + _clear).c_str(), 0, RecentMenu::_Callback, this, FL_MENU_DIVIDER);
}
void RecentMenu::_add(const std::string& item, bool append) {
    if (item == "") {
        _items.clear();
    }
    else if (append == true) {
        _add_string(_items, _max, item);
    }
    else {
        _insert_string(_items, _max, item);
    }
    auto index = _menu->find_index(_base.c_str());
    if (index >= 0) {
        _menu->clear_submenu(index);
        _menu->add((_base + _clear).c_str(), 0, RecentMenu::_Callback, this, FL_MENU_DIVIDER);
    }
    for (const auto& f : _items) {
        _menu->add((_base + "/" + flw::util::fix_menu_string(f)).c_str(), 0, _callback, _user);
    }
}
size_t RecentMenu::_add_string(StringVector& items, size_t max_size, const std::string& string) {
    for (auto it = items.begin(); it != items.end(); ++it) {
        if (*it == string) {
            items.erase(it);
            break;
        }
    }
    items.push_back(string);
    while (items.size() > max_size) {
        items.erase(items.begin());
    }
    return items.size();
}
void RecentMenu::_Callback(Fl_Widget*, void* o) {
    static_cast<RecentMenu*>(o)->_add("", false);
}
size_t RecentMenu::_insert_string(StringVector& items, size_t max_size, const std::string& string) {
    for (auto it = items.begin(); it != items.end(); ++it) {
        if (*it == string) {
            items.erase(it);
            break;
        }
    }
    items.insert(items.begin(), string);
    while (items.size() > max_size) {
        items.pop_back();
    }
    return items.size();
}
void RecentMenu::items(const StringVector& names) {
    auto res = StringVector();
    for (const auto& name : names) {
        _add(name, true);
    }
}
void RecentMenu::load_pref(Fl_Preferences& pref, const std::string& base_name) {
    auto index = 1;
    char buffer[1000];
    while (index <= 100) {
        auto key = flw::util::format("%s%d", base_name.c_str(), index++);
        pref.get(key.c_str(), buffer, "", 1000);
        if (*buffer == 0) {
            break;
        }
        _add(buffer, true);
    }
}
void RecentMenu::save_pref(Fl_Preferences& pref, const std::string& base_name) {
    auto index = 1;
    for (const auto& s : _items) {
        pref.set(flw::util::format("%s%d", base_name.c_str(), index++).c_str(), s.c_str());
    }
    pref.set(flw::util::format("%s%d", base_name.c_str(), index++).c_str(), "");
}
}
}
#include <FL/fl_draw.H>
flw::SplitGroup::SplitGroup(int X, int Y, int W, int H, const char* l) : Fl_Group(X, Y, W, H, l) {
    end();
    clip_children(1);
    resizable(nullptr);
    clear();
}
void flw::SplitGroup::add(Fl_Widget* widget, bool first) {
    if (_widgets[first] != nullptr) {
        remove(_widgets[first]);
        delete _widgets[first];
    }
    _widgets[first] = widget;
    if (widget != nullptr) {
        Fl_Group::add(widget);
    }
}
void flw::SplitGroup::clear() {
    Fl_Group::clear();
    _drag          = false;
    _min_split_pos = 50;
    _split_pos     = -1;
    _pos           = Pos::VERTICAL;
    _widgets[0]    = nullptr;
    _widgets[1]    = nullptr;
}
int flw::SplitGroup::handle(int event) {
    if (event == FL_DRAG) {
        if (_drag == true) {
            auto pos = 0;
            if (_pos == Pos::VERTICAL) {
                pos = Fl::event_x() - x();
            }
            else {
                pos = Fl::event_y() - y();
            }
            if (pos != _split_pos && pos >= _min_split_pos) {
                _split_pos = pos;
                do_layout();
            }
            return 1;
        }
    }
    else if (event == FL_LEAVE) {
        if (_pos == Pos::VERTICAL) {
            if (Fl::event_y() < y() || Fl::event_y() > y() + h() || Fl::event_x() < x() || Fl::event_x() > x() + w()) {
                _drag = false;
                fl_cursor(FL_CURSOR_DEFAULT);
            }
        }
        else {
            if (Fl::event_y() < y() || Fl::event_y() > y() + h() || Fl::event_x() < x() || Fl::event_x() > x() + w()) {
                _drag = false;
                fl_cursor(FL_CURSOR_DEFAULT);
            }
        }
    }
    else if (event == FL_MOVE) {
        if (_widgets[0] != nullptr && _widgets[1] != nullptr && _widgets[0]->visible() != 0 && _widgets[1]->visible() != 0) {
            if (_pos == Pos::VERTICAL) {
                auto mx  = Fl::event_x();
                auto pos = x() + _split_pos;
                if (mx > (pos - 3) && mx <= (pos + 3)) {
                    if (_drag == false) {
                        _drag = true;
                        fl_cursor(FL_CURSOR_WE);
                    }
                    return 1;
                }
            }
            else {
                auto my  = Fl::event_y();
                auto pos = y() + _split_pos;
                if (my > (pos - 3) && my <= (pos + 3)) {
                    if (_drag == false) {
                        _drag = true;
                        fl_cursor(FL_CURSOR_NS);
                    }
                    return 1;
                }
            }
        }
        if (_drag == true) {
            _drag = false;
            fl_cursor(FL_CURSOR_DEFAULT);
        }
    }
    else if (event == FL_PUSH) {
        if (_drag == true) {
            return 1;
        }
    }
    return Fl_Group::handle(event);
}
void flw::SplitGroup::hide_child(bool first) {
    if (_widgets[first] == nullptr) {
        return;
    }
    _widgets[first]->hide();
    do_layout();
}
void flw::SplitGroup::pos(Pos pos) {
    _pos       = pos;
    _split_pos = -1;
    do_layout();
    Fl::redraw();
}
void flw::SplitGroup::resize(int X, int Y, int W, int H) {
    Fl_Widget::resize(X, Y, W, H);
    if (W == 0 || H == 0) {
        return;
    }
    auto currx    = X;
    auto curry    = Y;
    auto currh    = H;
    auto currw    = W;
    if (_pos == Pos::VERTICAL) {
        if (_widgets[0] != nullptr && _widgets[1] != nullptr && _widgets[0]->visible() != 0 && _widgets[1]->visible() != 0) {
            if (_split_pos < 0) {
                _split_pos = W / 2;
            }
            else if (_split_pos >= W - _min_split_pos) {
                _split_pos = W - _min_split_pos;
            }
            else if (_split_pos < _min_split_pos) {
                _split_pos = _min_split_pos;
            }
            auto max = (X + W) - 4;
            auto pos = _split_pos + X;
            if (pos < X) {
                pos = X;
            }
            else if (pos > max) {
                pos = max;
            }
            auto w1 = pos - (X + 2);
            auto w2 = (X + W) - (pos + 2);
            _widgets[1]->resize(currx, curry, w1, currh);
            _widgets[0]->resize(currx + w1 + 4, curry, w2, currh);
        }
        else if (_widgets[0] && _widgets[0]->visible()) {
            _widgets[0]->resize(currx, curry, currw, currh);
        }
        else if (_widgets[1] && _widgets[1]->visible()) {
            _widgets[1]->resize(currx, curry, currw, currh);
        }
    }
    else if (_widgets[0] != nullptr && _widgets[1] != nullptr && _widgets[0]->visible() != 0 && _widgets[1]->visible() != 0) {
        if (_split_pos < 0) {
            _split_pos = H / 2;
        }
        else if (_split_pos >= H - _min_split_pos) {
            _split_pos = H - _min_split_pos;
        }
        else if (_split_pos < _min_split_pos) {
            _split_pos = _min_split_pos;
        }
        auto max = (Y + H) - 4;
        auto pos = _split_pos + Y;
        if (pos < Y) {
            pos = Y;
        }
        else if (pos > max) {
            pos = max;
        }
        auto h1 = pos - (Y + 2);
        auto h2 = (Y + H) - (pos + 2);
        _widgets[1]->resize(currx, curry, currw, h1);
        _widgets[0]->resize(currx, curry + h1 + 4, currw, h2);
    }
    else if (_widgets[0] != nullptr && _widgets[0]->visible() != 0) {
        _widgets[0]->resize(currx, curry, currw, currh);
    }
    else if (_widgets[1] != nullptr && _widgets[1]->visible() != 0) {
        _widgets[1]->resize(currx, curry, currw, currh);
    }
}
void flw::SplitGroup::show_child(bool first) {
    if (_widgets[first] == nullptr) {
        return;
    }
    _widgets[first]->show();
    do_layout();
}
#include <assert.h>
#include <algorithm>
#include <FL/Fl_Toggle_Button.H>
#include <FL/fl_draw.H>
namespace flw {
class _TabsGroupButton : public Fl_Toggle_Button {
public:
    int        tw;
    Fl_Widget* widget;
    _TabsGroupButton(Fl_Boxtype box_type, Fl_Boxtype dbox_type, Fl_Color color, const std::string& label, Fl_Widget* widget_, void* o) :
    Fl_Toggle_Button(0, 0, 0, 0) {
        tw     = 0;
        widget = widget_;
        copy_label(label.c_str());
        tooltip("");
        when(FL_WHEN_CHANGED);
        callback(TabsGroup::CallbackButton, o);
        selection_color(color);
        labelfont(flw::PREF_FONT);
        labelsize(flw::PREF_FONTSIZE);
        box(FL_THIN_UP_BOX);
        down_box(FL_NO_BOX);
        if (box_type != FL_MAX_BOXTYPE) {
            box(box_type);
        }
        if (dbox_type != FL_MAX_BOXTYPE) {
            down_box(dbox_type);
        }
    }
};
class _TabsGroup : public Fl_Group {
public:
    _TabsGroup(int X, int Y, int W, int H) :
    Fl_Group(X, Y, W, H) {
    }
    void resize(int X, int Y, int W, int H) {
        Fl_Widget::resize(X, Y, W, H);
    }
};
TabsGroup::TabsGroup(int X, int Y, int W, int H, const char* l) : Fl_Group(X, Y, W, H, l) {
    end();
    clip_children(1);
    resizable(nullptr);
    _scroll   = new Fl_Scrollbar(0, 0, 0, 0);
    _tabs     = new _TabsGroup(0, 0, 0, 0);
    _active1  = -1;
    _active2  = -1;
    _color    = FL_SELECTION_COLOR;
    _e        = 0;
    _keyboard = true;
    _n        = 0;
    _s        = 0;
    _down_box = FL_MAX_BOXTYPE;
    _up_box   = FL_MAX_BOXTYPE;
    _visible  = 0;
    _w        = 0;
    _width1   = flw::PREF_FONTSIZE * TabsGroup::DEFAULT_VER_TAB_WIDTH;
    _width2   = TabsGroup::DEFAULT_MAX_HOR_TAB_WIDTH;
    _tabs->end();
    _tabs->add(_scroll);
    Fl_Group::add(_tabs);
    _scroll->linesize(4);
    _scroll->value(1, 1, 1, 16);
    _scroll->callback(TabsGroup::CallbackScrollbar, this);
    _tabs->tooltip(TabsGroup::Help());
    _tabs->box(FL_NO_BOX);
    _tabs->clip_children(1);
    tab_pos(Pos::TOP);
    update_pref();
}
void TabsGroup::_activate(Fl_Widget* widget) {
    auto count   = 0;
    auto current = _active1;
    _active1 = -1;
    for (auto button : _widgets) {
        auto b = static_cast<_TabsGroupButton*>(button);
        if (b == widget || b->widget == widget) {
            _active1 = count;
            _active2 = (current != _active1) ? current : _active2;
            b->value(1);
            b->widget->show();
            b->widget->take_focus();
        }
        else {
            b->value(0);
            b->widget->hide();
        }
        count++;
    }
    do_layout();
    auto but = _active_button();
    if (but == nullptr) {
        return;
    }
    if (is_tabs_horizontal() ==  true) {
        if (but->x() < _scroll->x()) {
            _scroll->value(_active1 + 1);
            do_layout();
        }
        else if (but->x() + but->w() > x() + w()) {
            _scroll->value(_active1 - _visible + 2);
            do_layout();
        }
    }
    else if (is_tabs_vertical() == true) {
        if (but->y() < _scroll->y()) {
            _scroll->value(_active1 + 1);
            do_layout();
        }
        else if (but->y() + but->h() > h() + y()) {
            _scroll->value(_active1 - _visible + 2);
            do_layout();
        }
    }
    _resize_active_widget();
    Fl::redraw();
}
Fl_Widget* TabsGroup::_active_button() {
    return _active1 >= 0 && _active1 < static_cast<int>(_widgets.size()) ?
        _widgets[_active1] :
        nullptr;
}
void TabsGroup::add(const std::string& label, Fl_Widget* widget, const Fl_Widget* after, const std::string& tooltip) {
    if (find(widget) != -1) {
        return;
    }
    auto button = new _TabsGroupButton(_up_box, _down_box, _color, label, widget, this);
    auto idx    = (after != nullptr) ? find(after) : static_cast<int>(_widgets.size());
    button->copy_tooltip(tooltip.c_str());
    if (idx < 0 || idx >= static_cast<int>(_widgets.size()) - 1) {
        Fl_Group::add(widget);
        _tabs->add(button);
        _widgets.push_back(button);
    }
    else {
        idx++;
        auto b = static_cast<_TabsGroupButton*>(_widgets[idx]);
        Fl_Group::insert(*widget, b->widget);
        _tabs->insert(*button, b);
        _widgets.insert(_widgets.begin() + idx, button);
    }
    TabsGroup::CallbackButton(button, this);
}
void TabsGroup::CallbackButton(Fl_Widget* sender, void* object) {
    static_cast<TabsGroup*>(object)->_activate(sender);
}
void TabsGroup::CallbackScrollbar(Fl_Widget*, void* object) {
    auto self = static_cast<TabsGroup*>(object);
    if (self->is_tabs_horizontal() ==  true) {
        self->_resize_top_bottom(self->x(), self->y(), self->w(), self->h());
    }
    else if (self->is_tabs_vertical() == true) {
        self->_resize_left_right(self->x(), self->y(), self->w(), self->h());
    }
    self->redraw();
    self->_tabs->redraw_label();
}
Fl_Widget* TabsGroup::child(int index) const {
    return index >= 0 && index < static_cast<int>(_widgets.size()) ?
        static_cast<_TabsGroupButton*>(_widgets[index])->widget :
        nullptr;
}
void TabsGroup::clear() {
    _active1 = -1;
    _active2 = -1;
    _widgets.clear();
    _tabs->remove(_scroll);
    Fl_Group::remove(_tabs);
    _tabs->clear();
    Fl_Group::clear();
    Fl_Group::add(_tabs);
    _tabs->add(_scroll);
    update_pref();
    do_layout();
    Fl::redraw();
}
void TabsGroup::debug(bool all) const {
#ifdef DEBUG
    puts("------------------------------------------------------------");
    auto w = ((TabsGroup*) this)->_active_button();
    printf("TabsGroup ==>\n");
    printf("    _tab_pos  = %d\n", (int) _tab_pos);
    printf("    active    = %s\n", w ? w->label() : "NULL");
    printf("    _active1  = %d\n", _active1);
    printf("    _active2  = %d\n", _active2);
    printf("    _drag     = %d\n", _drag);
    printf("    _width1   = %d\n", _width1);
    printf("    _width2   = %d\n", _width2);
    printf("    _keyboard = %d\n", _keyboard);
    printf("    _widgets  = %d\n", static_cast<int>(_widgets.size()));
    printf("    _visible  = %d\n", _visible);
    printf("    _area     = %d - %d :: %d - %d\n", _area.x(), _area.y(), _area.w(), _area.h());
    printf("    scrollbar = %d - %d\n", (int) _scroll->value(), (int) _scroll->maximum());
    printf("    children  = %d\n", children());
    printf("\n");
    if (all == true) {
        flw::debug::print(this->_tabs);
        printf("\n");
        int f = 0;
        for (auto widget : _widgets) {
            auto b = static_cast<_TabsGroupButton*>(widget);
            printf("%2d: %s\n", f++, b->label());
        }
    }
    puts("------------------------------------------------------------");
    fflush(stdout);
#else
    (void) all;
#endif
}
int TabsGroup::find(const Fl_Widget* widget) const {
    auto num = 0;
    for (const auto W : _widgets) {
        const auto b = static_cast<_TabsGroupButton*>(W);
        if (b->widget == widget) {
            return num;
        }
        else {
            num++;
        }
    }
    return -1;
}
int TabsGroup::handle(int event) {
    if (is_tabs_vertical() == true) {
        if (event == FL_DRAG) {
            if (_drag == true) {
                auto pos   = 0;
                auto width = flw::PREF_FONTSIZE * TabsGroup::MIN_WIDTH;
                if (is_tabs_left() == true) {
                    pos = Fl::event_x() - x();
                }
                else if (is_tabs_right() == true) {
                    pos = x() + w() - Fl::event_x();
                }
                if (pos != _width1 && pos >= width && pos <= w() - width) {
                    _width1 = pos;
                    do_layout();
                }
                return 1;
            }
        }
        else if (event == FL_LEAVE) {
            _drag = false;
            fl_cursor(FL_CURSOR_DEFAULT);
        }
        else if (event == FL_MOVE) {
            auto event_x = Fl::event_x();
            if (_tab_pos == Pos::LEFT || _tab_pos == Pos::LEFT2) {
                auto pos = x() + _width1;
                if (event_x > (pos - 3) && event_x <= (pos + 3)) {
                    if (_drag == false) {
                        _drag = true;
                        fl_cursor(FL_CURSOR_WE);
                    }
                    return 1;
                }
            }
            else if (_tab_pos == Pos::RIGHT || _tab_pos == Pos::RIGHT2) {
                auto pos = x() + w() - _width1;
                if (event_x > (pos - 3) && event_x <= (pos + 3)) {
                    if (_drag == false) {
                        _drag = true;
                        fl_cursor(FL_CURSOR_WE);
                    }
                    return 1;
                }
            }
            if (_drag == true) {
                _drag = false;
                fl_cursor(FL_CURSOR_DEFAULT);
            }
        }
        else if (event == FL_PUSH) {
            if (_drag == true) {
                return 1;
            }
        }
    }
    if (event == FL_KEYBOARD && _keyboard == true) {
        auto key   = Fl::event_key();
        auto alt   = Fl::event_alt() != 0;
        auto alt2  = alt;
        auto shift = Fl::event_shift() != 0;
#ifdef __APPLE__
        alt2 = Fl::event_command() != 0;
#endif
        if (_widgets.size() < 2) {
        }
        else if (alt2 == true && key >= '0' && key <= '9') {
            auto tab = key - '0';
            tab = (tab == 0) ? 9 : tab - 1;
            if (tab < static_cast<int>(_widgets.size())) {
                TabsGroup::CallbackButton(_widgets[tab], this);
            }
            return 1;
        }
        else if (alt == true && shift == true && (key == FL_Left || key == FL_Up)) {
            if (_active1 - 1 == _active2) {
                _active2 = _active1;
            }
            else if (_active1 == 0 && _widgets.size() > 1) {
                _active2--;
            }
            auto tab = swap(_active1, _active1 - 1);
            TabsGroup::CallbackButton(_widgets[tab], this);
            return 1;
        }
        else if (alt == true && shift == true && (key == FL_Right || key == FL_Down)) {
            if (_active1 + 1 == _active2) {
                _active2 = _active1;
            }
            else if (_active1 == static_cast<int>(_widgets.size()) - 1 && _widgets.size() > 1) {
                _active2++;
            }
            auto tab = swap(_active1, _active1 + 1);
            TabsGroup::CallbackButton(_widgets[tab], this);
            return 1;
        }
        else if (alt == true && key == FL_Left) {
            auto tab = (_active1 == 0) ? static_cast<int>(_widgets.size()) - 1 : _active1 - 1;
            TabsGroup::CallbackButton(_widgets[tab], this);
            return 1;
        }
        else if (alt == true && key == FL_Right) {
            auto tab = (_active1 == static_cast<int>(_widgets.size()) - 1) ? 0 : _active1 + 1;
            TabsGroup::CallbackButton(_widgets[tab], this);
            return 1;
        }
        else if (alt == true && (key == FL_Up || key == FL_Down)) {
            auto tab = (_active2 == -1) ? _active1 : _active2;
            TabsGroup::CallbackButton(_widgets[tab], this);
            return 1;
        }
    }
    else if (event == FL_FOCUS) {
        auto widget = value();
        if (widget != nullptr && widget != Fl::focus()) {
            widget->take_focus();
            return 1;
        }
    }
    return Fl_Group::handle(event);
}
const char* TabsGroup::Help() {
    static const char* const HELP =
    "Use alt + left/right to move between tabs.\n"
    "Use alt + up/down to jump between two last widgets.\n"
    "Or alt + [1 - 9, 0] to select tab from 1 - 10.\n"
    "And alt + shift + left/right to move tabs.\n"
    "Tabs on the left/right side can have its width changed by dragging the mouse.";
    return HELP;
}
void TabsGroup::hide_tabs() {
    _tabs->hide();
    do_layout();
}
void TabsGroup::insert(const std::string& label, Fl_Widget* widget, const Fl_Widget* before, const std::string& tooltip) {
    if (find(widget) != -1) {
        return;
    }
    auto button = new _TabsGroupButton(_up_box, _down_box, _color, label, widget, this);
    auto idx    = (before != nullptr) ? find(before) : 0;
    button->copy_tooltip(tooltip.c_str());
    if (idx >= static_cast<int>(_widgets.size())) {
        Fl_Group::add(widget);
        _tabs->add(button);
        _widgets.push_back(button);
    }
    else {
        auto b = static_cast<_TabsGroupButton*>(_widgets[idx]);
        Fl_Group::insert(*widget, b->widget);
        _tabs->insert(*button, b);
        _widgets.insert(_widgets.begin() + idx, button);
    }
    TabsGroup::CallbackButton(button, this);
    do_layout();
}
Fl_Widget* TabsGroup::remove(int index) {
    if (index < 0 || index >= static_cast<int>(_widgets.size())) {
        return nullptr;
    }
    auto button = static_cast<_TabsGroupButton*>(_widgets[index]);
    auto res    = button->widget;
    _widgets.erase(_widgets.begin() + index);
    remove(res);
    _tabs->remove(button);
    delete button;
    if (index < _active1) {
        _active1--;
    }
    else if (_active1 == static_cast<int>(_widgets.size())) {
        _active1 = static_cast<int>(_widgets.size()) - 1;
    }
    do_layout();
    TabsGroup::CallbackButton(_active_button(), this);
    return res;
}
void TabsGroup::resize(int X, int Y, int W, int H) {
    Fl_Widget::resize(X, Y, W, H);
    if (W == 0 || H == 0) {
        return;
    }
    if (_tabs->visible() == 0) {
        _area = Fl_Rect(X + _w, Y + _n, W - _w - _e, H - _n - _s);
    }
    else {
        fl_font(flw::PREF_FONT, flw::PREF_FONTSIZE);
        if (is_tabs_horizontal() == true) {
            _resize_top_bottom(X, Y, W, H);
        }
        else if (is_tabs_vertical() == true) {
            _resize_left_right(X, Y, W, H);
        }
    }
    _resize_active_widget();
    Fl::redraw();
}
void TabsGroup::_resize_active_widget() {
    auto but = static_cast<_TabsGroupButton*>(_active_button());
    if (but == nullptr) {
        return;
    }
    if (Fl_Rect(but->widget) != _area) {
        but->widget->resize(_area.x(), _area.y(), _area.w(), _area.h());
        Fl::redraw();
    }
}
void TabsGroup::_resize_left_right(int X, int Y, int W, int H) {
    auto height = flw::PREF_FONTSIZE + TabsGroup::HEIGHT;
    auto pack_h = (height + _space) * static_cast<int>(_widgets.size()) - _space;
    auto scroll = 0;
    _visible = static_cast<int>(H / (height + _space));
    if (_width1 < flw::PREF_FONTSIZE * TabsGroup::MIN_WIDTH) {
        _width1 = flw::PREF_FONTSIZE * TabsGroup::MIN_WIDTH;
    }
    else if (_width1 > W - flw::PREF_FONTSIZE * TabsGroup::MIN_WIDTH) {
        _width1 = W - flw::PREF_FONTSIZE * TabsGroup::MIN_WIDTH;
    }
    if (pack_h > H) {
        auto size = static_cast<int>(_widgets.size() - _visible + 2);
        scroll = Fl::scrollbar_size();
        _scroll->range(1, size > 0 ? size : 1);
        _scroll->show();
    }
    else {
        _scroll->value(1);
        _scroll->resize(0, 0, 0, 0);
        _scroll->hide();
    }
    if (is_tabs_left() == true) {
        _tabs->resize(X, Y, _width1, H);
        _area = Fl_Rect(X + _width1 + _w, Y + _n, W - _width1 - _w - _e, H - _n - _s);
        if (_tab_pos == Pos::LEFT) {
            _scroll->resize(_tabs->x(), _tabs->y(), scroll, _tabs->h());
        }
        else if (_tab_pos == Pos::LEFT2) {
            _scroll->resize(_tabs->x() + _width1 - scroll, _tabs->y(), scroll, _tabs->h());
        }
    }
    else if (is_tabs_right() == true) {
        _tabs->resize(X + W - _width1, Y, _width1, H);
        _area = Fl_Rect(X + _w, Y + _n, W - _width1 - _w - _e, H - _n - _s);
        if (_tab_pos == Pos::RIGHT) {
            _scroll->resize(_tabs->x() + _tabs->w() - scroll, _tabs->y(), scroll, _tabs->h());
        }
        else if (_tab_pos == Pos::RIGHT2) {
            _scroll->resize(_tabs->x(), _tabs->y(), scroll, _tabs->h());
        }
    }
    auto ypos = -(_scroll->value() - 1);
    ypos *= height + _space;
    ypos += _tabs->y();
    for (auto widget : _widgets) {
        auto b  = static_cast<_TabsGroupButton*>(widget);
        b->tw = 0;
        b->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE | FL_ALIGN_CLIP);
        if (_tab_pos == Pos::LEFT) {
            b->resize(_tabs->x() + scroll, ypos, _tabs->w() - scroll, height);
        }
        else if (_tab_pos == Pos::LEFT2) {
            b->resize(_tabs->x(), ypos, _tabs->w() - scroll, height);
        }
        else if (_tab_pos == Pos::RIGHT) {
            b->resize(_tabs->x(), ypos, _tabs->w() - scroll, height);
        }
        else if (_tab_pos == Pos::RIGHT2) {
            b->resize(_tabs->x() + scroll, ypos, _tabs->w() - scroll, height);
        }
        ypos += height + _space;
    }
}
void TabsGroup::_resize_top_bottom(int X, int Y, int W, int H) {
    auto height = flw::PREF_FONTSIZE + TabsGroup::HEIGHT;
    auto pack_w = 0;
    auto scroll = 0;
    auto width  = 0;
    auto minw   = flw::PREF_FONTSIZE * TabsGroup::MIN_WIDTH + _space;
    auto maxw   = flw::PREF_FONTSIZE * _width2 + _space;
    _visible = 0;
    fl_font(labelfont(), labelsize());
    for (auto widget : _widgets) {
        auto b  = static_cast<_TabsGroupButton*>(widget);
        auto th = 0;
        b->tw = 0;
        fl_measure(b->label(), b->tw, th);
        if (b->tw + flw::PREF_FONTSIZE > width) {
            width = b->tw + flw::PREF_FONTSIZE;
        }
    }
    if (width < minw) {
        width = minw;
    }
    else if (width > maxw) {
        width = maxw;
    }
    pack_w   = (width + _space) * static_cast<int>(_widgets.size()) - _space;
    _visible = static_cast<int>(W / (width + _space));
    if (pack_w - _space > W) {
        auto size = static_cast<int>(_widgets.size() - _visible + 2);
        scroll = Fl::scrollbar_size();
        _scroll->show();
        _scroll->range(1, size > 0 ? size : 1);
    }
    else {
        _scroll->value(1);
        _scroll->resize(0, 0, 0, 0);
        _scroll->hide();
    }
    if (is_tabs_top() == true) {
        _tabs->resize(X, Y, W, height + scroll);
        _area = Fl_Rect(X + _w, Y + height + scroll + _n, W - _w - _e, H - height - scroll - _n - _s);
        if (_tab_pos == Pos::TOP) {
            _scroll->resize(_tabs->x(), _tabs->y(), _tabs->w(), scroll);
        }
        else if (_tab_pos == Pos::TOP2) {
            _scroll->resize(_tabs->x(), _tabs->y() + height, _tabs->w(), scroll);
        }
    }
    else if (is_tabs_bottom() == true) {
        _tabs->resize(X, Y + H - height - scroll, W, height + scroll);
        _area = Fl_Rect(X + _w, Y + _n, W - _w - _e, H - height - scroll - _n - _s);
        if (_tab_pos == Pos::BOTTOM) {
            _scroll->resize(_tabs->x(), _tabs->y() + _tabs->h() - scroll, _tabs->w(), scroll);
        }
        else if (_tab_pos == Pos::BOTTOM2) {
            _scroll->resize(_tabs->x(), _tabs->y(), _tabs->w(), scroll);
        }
    }
    auto xpos = -(_scroll->value() - 1);
    xpos *= width + _space;
    xpos += _tabs->x();
    for (auto widget : _widgets) {
        auto b  = static_cast<_TabsGroupButton*>(widget);
        if (b->tw >= width) {
            b->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE | FL_ALIGN_CLIP);
        }
        else {
            b->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE | FL_ALIGN_CLIP);
        }
        if (_tab_pos == Pos::TOP) {
            b->resize(xpos, _tabs->y() + scroll, width, height);
        }
        else if (_tab_pos == Pos::TOP2) {
            b->resize(xpos, _tabs->y(), width, height);
        }
        else if (_tab_pos == Pos::BOTTOM) {
            b->resize(xpos, _tabs->y() + _tabs->h() - height - scroll, width, height);
        }
        else if (_tab_pos == Pos::BOTTOM2) {
            b->resize(xpos, _tabs->y() + _tabs->h() - height, width, height);
        }
        xpos += width + _space;
    }
}
void TabsGroup::show_tabs() {
    _tabs->show();
    do_layout();
}
void TabsGroup::sort(bool ascending, bool casecompare) {
    auto pack = const_cast<Fl_Widget**>(_tabs->array());
    auto butt = _active_button();
    if (ascending == true && casecompare == true) {
        std::sort(_widgets.begin(), _widgets.end(), [](const Fl_Widget* a, const Fl_Widget* b) { return strcmp(a->label(), b->label()) < 0; });
    }
    else if (ascending == true && casecompare == false) {
        std::sort(_widgets.begin(), _widgets.end(), [](const Fl_Widget* a, const Fl_Widget* b) { return fl_utf_strcasecmp(a->label(), b->label()) < 0; });
    }
    else if (ascending == false && casecompare == true) {
        std::sort(_widgets.begin(), _widgets.end(), [](const Fl_Widget* a, const Fl_Widget* b) { return strcmp(b->label(), a->label()) < 0; });
    }
    else if (ascending == false && casecompare == false) {
        std::sort(_widgets.begin(), _widgets.end(), [](const Fl_Widget* a, const Fl_Widget* b) { return fl_utf_strcasecmp(b->label(), a->label()) < 0; });
    }
    for (int f = 1; f < _tabs->children(); f++) {
        pack[f] = _widgets[f - 1];
        if (_widgets[f - 1] == butt) {
            _active1 = f - 1;
        }
    }
    _activate(butt);
}
int TabsGroup::swap(int from, int to) {
    auto last = static_cast<int>(_widgets.size()) - 1;
    if (_widgets.size() < 2 || to < -1 || to > static_cast<int>(_widgets.size())) {
        return _active1;
    }
    auto active = (_active1 == from);
    auto pack   = const_cast<Fl_Widget**>(_tabs->array());
    if (from == 0 && to == -1) {
        auto widget = _widgets[0];
        for (int f = 1; f <= last; f++) {
            _widgets[f - 1] = _widgets[f];
            pack[f] = pack[f + 1];
        }
        pack[last + 1] = widget;
        _widgets[last] = widget;
        if (active == true) {
            _active1 = last;
        }
        util::swap_rect(_widgets[last - 1], _widgets[last]);
    }
    else if (from == last && to == static_cast<int>(_widgets.size())) {
        auto widget = _widgets[last];
        for (int f = last; f > 0; f--) {
            _widgets[f] = _widgets[f - 1];
            pack[f + 1] = pack[f];
        }
        pack[1] = widget;
        _widgets[0] = widget;
        if (active == true) {
            _active1 = 0;
        }
        util::swap_rect(_widgets[0], _widgets[1]);
    }
    else {
        auto widget = _widgets[from];
        pack[from + 1] = pack[to + 1];
        pack[to + 1] = widget;
        _widgets[from] = _widgets[to];
        _widgets[to] = widget;
        if (active == true) {
            _active1 = to;
        }
        util::swap_rect(_widgets[from], _widgets[to]);
    }
    return _active1;
}
void TabsGroup::tab_box(Fl_Boxtype up_box, Fl_Boxtype down_box) {
    _up_box   = up_box;
    _down_box = down_box;
    for (auto widget : _widgets) {
        auto b = static_cast<_TabsGroupButton*>(widget);
        if (_up_box == FL_MAX_BOXTYPE) {
            b->box(FL_THIN_UP_BOX);
        }
        else {
            b->box(_up_box);
        }
        if (_down_box == FL_MAX_BOXTYPE) {
            b->down_box(FL_NO_BOX);
        }
        else {
            b->down_box(_down_box);
        }
    }
}
void TabsGroup::tab_color(Fl_Color color) {
    _color = color;
    for (auto widget : _widgets) {
        auto b = static_cast<_TabsGroupButton*>(widget);
        b->selection_color(_color);
    }
}
std::string TabsGroup::tab_label(const Fl_Widget* widget) {
    auto num = find(widget);
    if (num == -1) {
        return "";
    }
    return _widgets[num]->label();
}
void TabsGroup::tab_label(const std::string& label, Fl_Widget* widget) {
    auto num = find(widget);
    if (num == -1) {
        return;
    }
    _widgets[num]->copy_label(label.c_str());
}
void TabsGroup::tab_pos(Pos pos, int space) {
    _tab_pos = pos;
    _space   = (space >= 0 && space <= TabsGroup::MAX_SPACE) ? space : TabsGroup::DEFAULT_SPACE;
    if (is_tabs_horizontal() == true) {
        _scroll->type(FL_HORIZONTAL);
    }
    else if (is_tabs_vertical() == true) {
        _scroll->type(FL_VERTICAL);
    }
    _scroll->value(1);
    _activate(_active_button());
}
std::string TabsGroup::tooltip(Fl_Widget* widget) const {
    auto num = find(widget);
    if (num == -1) {
        return "";
    }
    return flw::util::to_string(_widgets[num]->tooltip());
}
void TabsGroup::tooltip(const std::string& tooltip, Fl_Widget* widget) {
    auto num = find(widget);
    if (num == -1) {
        return;
    }
    _widgets[num]->copy_tooltip(tooltip.c_str());
}
void TabsGroup::update_pref(Fl_Font font, Fl_Fontsize fontsize) {
    _drag = false;
    labelfont(font);
    labelsize(fontsize);
    _width1 = flw::PREF_FONTSIZE * TabsGroup::DEFAULT_VER_TAB_WIDTH;
    _width2 = TabsGroup::DEFAULT_MAX_HOR_TAB_WIDTH;
    for (auto widget : _widgets) {
        widget->labelfont(font);
        widget->labelsize(fontsize);
    }
}
Fl_Widget* TabsGroup::value() const {
    return _active1 >= 0 && _active1 < static_cast<int>(_widgets.size()) ?
        static_cast<_TabsGroupButton*>(_widgets[_active1])->widget :
        nullptr;
}
void TabsGroup::value(int num) {
    if (num >= 0 && num < static_cast<int>(_widgets.size())) {
        _activate(_widgets[num]);
    }
}
}
namespace flw {
struct _ToolGroupChild {
    Fl_Widget*                  widget;
    int                         size;
    _ToolGroupChild(Fl_Widget* WIDGET, int SIZE) {
        set(WIDGET);
        set(SIZE);
    }
    void set(Fl_Widget* WIDGET) {
        widget = WIDGET;
    }
    void set(int SIZE) {
        size = SIZE;
    }
};
ToolGroup::ToolGroup(int X, int Y, int W, int H, const char* l) : Fl_Group(X, Y, W, H, l) {
    end();
    clip_children(1);
    resizable(nullptr);
    _pos    = Pos::HORIZONTAL;
    _expand = false;
}
ToolGroup::~ToolGroup() {
    clear();
}
Fl_Widget* ToolGroup::add(Fl_Widget* widget, unsigned size) {
    if (find(widget) != children()) {
        return nullptr;
    }
    _widgets.push_back(new _ToolGroupChild(widget, size));
    Fl_Group::add(widget);
    return widget;
}
void ToolGroup::clear() {
    for (auto v : _widgets) {
        delete static_cast<_ToolGroupChild*>(v);
    }
    _widgets.clear();
    Fl_Group::clear();
}
Fl_Widget* ToolGroup::remove(Fl_Widget* widget) {
    if (find(widget) == children()) {
        return nullptr;
    }
    for (auto it = _widgets.begin(); it != _widgets.end(); it++) {
        auto child = static_cast<_ToolGroupChild*>(*it);
        if (child->widget == widget) {
            Fl_Group::remove(widget);
            _widgets.erase(it);
            delete child;
            return widget;
        }
    }
    return nullptr;
}
Fl_Widget* ToolGroup::replace(Fl_Widget* old_widget, Fl_Widget* new_widget) {
    if (find(old_widget) == children()) {
        return nullptr;
    }
    for (auto it = _widgets.begin(); it != _widgets.end(); it++) {
        auto child = static_cast<_ToolGroupChild*>(*it);
        if (child->widget == old_widget) {
            insert(*new_widget, old_widget);
            child->set(new_widget);
            Fl_Group::remove(old_widget);
            return old_widget;
        }
    }
    return nullptr;
}
void ToolGroup::resize(const int X, const int Y, const int W, const int H) {
    Fl_Widget::resize(X, Y, W, H);
    if (children() == 0 || W == 0 || H == 0 || visible() == 0) {
        return;
    }
    auto leftover = (_pos == Pos::HORIZONTAL) ? W : H;
    auto count    = 0;
    auto last     = static_cast<Fl_Widget*>(nullptr);
    auto avg      = 0;
    auto xpos     = X;
    auto ypos     = Y;
    for (auto v : _widgets) {
        auto child = static_cast<_ToolGroupChild*>(v);
        last = child->widget;
        if (child->size > 0) {
            leftover -= (child->size * flw::PREF_FONTSIZE);
        }
        else {
            count++;
        }
    }
    if (count > 0) {
        avg = leftover / count;
    }
    for (auto v : _widgets) {
        auto child = static_cast<_ToolGroupChild*>(v);
        if (child->widget != nullptr) {
            if (_pos == Pos::HORIZONTAL) {
                if (_expand == true && child->widget == last) {
                    child->widget->resize(xpos, Y, X + W - xpos, H);
                }
                else if (child->size > 0) {
                    child->widget->resize(xpos, Y, child->size * flw::PREF_FONTSIZE, H);
                    xpos += flw::PREF_FONTSIZE * child->size;
                }
                else {
                    child->widget->resize(xpos, Y, avg, H);
                    xpos += avg;
                }
            }
            else if (_pos == Pos::VERTICAL) {
                if (_expand == true && child->widget == last) {
                    child->widget->resize(X, ypos, W, Y + H - ypos);
                }
                else if (child->size > 0) {
                    child->widget->resize(X, ypos, W, child->size * flw::PREF_FONTSIZE);
                    ypos += flw::PREF_FONTSIZE * child->size;
                }
                else {
                    child->widget->resize(X, ypos, W, avg);
                    ypos += avg;
                }
            }
        }
    }
}
void ToolGroup::size(Fl_Widget* widget, unsigned size) {
    for (auto v : _widgets) {
        auto child = static_cast<_ToolGroupChild*>(v);
        if (child->widget == widget) {
            child->set(size);
            return;
        }
    }
}
void ToolGroup::size(unsigned size) {
    for (auto v : _widgets) {
        auto child = static_cast<_ToolGroupChild*>(v);
        child->set(size);
    }
    do_layout();
}
}
namespace flw {
static const std::string _SCROLLBROWSER_MENU_ALL  = "Copy all Lines";
static const std::string _SCROLLBROWSER_MENU_LINE = "Copy Current Line";
static const std::string _SCROLLBROWSER_TOOLTIP   = "Right click to show the menu.";
ScrollBrowser::ScrollBrowser(int lines, int X, int Y, int W, int H, const char* l) : Fl_Hold_Browser(X, Y, W, H, l) {
    end();
    _menu      = new Fl_Menu_Button(0, 0, 0, 0);
    _flag_move = true;
    _flag_menu = true;
    scroll_lines(lines);
    static_cast<Fl_Group*>(this)->add(_menu);
    _menu->add(_SCROLLBROWSER_MENU_LINE.c_str(), 0, ScrollBrowser::Callback, this);
    _menu->add(_SCROLLBROWSER_MENU_ALL.c_str(), 0, ScrollBrowser::Callback, this);
    _menu->type(Fl_Menu_Button::POPUP3);
    tooltip(_SCROLLBROWSER_TOOLTIP.c_str());
    update_pref();
}
void ScrollBrowser::Callback(Fl_Widget*, void* o) {
    auto self  = static_cast<ScrollBrowser*>(o);
    auto txt   = self->_menu->text();
    auto label = std::string((txt != nullptr) ? txt : "");
    auto clip  = std::string();
    clip.reserve(self->size() * 40 + 100);
    if (label == _SCROLLBROWSER_MENU_LINE) {
        if (self->value() > 0) {
            clip = util::remove_browser_format(util::to_string(self->text(self->value())));
        }
    }
    else if (label == _SCROLLBROWSER_MENU_ALL) {
        for (auto f = 1; f <= self->size(); f++) {
            auto s = util::remove_browser_format(util::to_string(self->text(f)));
            clip += s;
            clip += "\n";
        }
    }
    if (clip != "") {
        Fl::copy(clip.c_str(), clip.length(), 2);
    }
}
int ScrollBrowser::handle(int event) {
    if (event == FL_MOUSEWHEEL) {
        if (_flag_move == true) {
            if (Fl::event_dy() > 0) {
                topline(topline() + _scroll);
            }
            else if (Fl::event_dy() < 0) {
                topline(topline() - _scroll);
            }
            return 1;
        }
    }
    else if (event == FL_KEYBOARD) {
        if (_flag_move == true) {
            auto key = Fl::event_key();
            if (key == FL_Page_Up) {
                auto line = value();
                if (line == 1) {
                }
                else if (line - _scroll < 1) {
                    value(1);
                    do_callback();
                }
                else {
                    value(line - _scroll);
                    topline(line - _scroll);
                    do_callback();
                }
                return 1;
            }
            else if (key == FL_Page_Down) {
                auto line = value();
                if (line == size()) {
                }
                else if (line + _scroll > size()) {
                    value(size());
                    do_callback();
                }
                else {
                    value(line + _scroll);
                    bottomline(line + _scroll);
                    do_callback();
                }
                return 1;
            }
        }
    }
    else if (event == FL_PUSH) {
        if (_flag_menu == true && Fl::event_button() == FL_RIGHT_MOUSE) {
            _menu->popup();
            return 1;
        }
    }
    return Fl_Hold_Browser::handle(event);
}
void ScrollBrowser::update_pref(Fl_Font text_font, Fl_Fontsize text_size) {
    labelfont(flw::PREF_FONT);
    labelsize(flw::PREF_FONTSIZE);
    textfont(text_font);
    textsize(text_size);
    _menu->textfont(text_font);
    _menu->textsize(text_size);
}
}
#include <FL/fl_draw.H>
#include <FL/Fl.H>
flw::WaitCursor* flw::WaitCursor::WAITCURSOR = nullptr;
flw::WaitCursor::WaitCursor() {
    if (WaitCursor::WAITCURSOR == nullptr) {
        WaitCursor::WAITCURSOR = this;
        fl_cursor(FL_CURSOR_WAIT);
        Fl::redraw();
        Fl::flush();
    }
}
flw::WaitCursor::~WaitCursor() {
    if (WaitCursor::WAITCURSOR == this) {
        WaitCursor::WAITCURSOR = nullptr;
        fl_cursor(FL_CURSOR_DEFAULT);
    }
}
#include <algorithm>
#ifdef __cplusplus
extern "C" {
#endif
    void rainbow(unsigned hashsize, const void* in, const size_t in_len, uint8_t out[32], const uint64_t seed);
#ifdef __cplusplus
}
#endif
namespace fle {
std::string APPLICATION;
namespace limits {
    const size_t FIND_LIST_MAX               =             30;
    const size_t HEXFILE_DIVIDER             =              5;
    const size_t MOUSE_SCROLL_MAX            =             15;
    const size_t TAB_WIDTH_MAX               =              8;
    const size_t UNDO_WARNING                =  1'000'000'000;
    const size_t WRAP_DEF                    =             80;
    const size_t WRAP_MAX                    =            140;
    const size_t WRAP_MIN                    =             60;
    const size_t AUTOCOMPLETE_FILESIZE_DEF   =     50'000'000;
    const size_t AUTOCOMPLETE_FILESIZE_MAX   =    100'000'000;
    const size_t AUTOCOMPLETE_FILESIZE_MIN   =      1'000'000;
    const size_t AUTOCOMPLETE_FILESIZE_STEP  =      1'000'000;
    size_t       AUTOCOMPLETE_FILESIZE_VAL   =     50'000'000;
    const size_t AUTOCOMPLETE_LINES_DEF      =         50'000;
    const size_t AUTOCOMPLETE_LINES_MAX      =        100'000;
    const size_t AUTOCOMPLETE_LINES_MIN      =          1'000;
    const size_t AUTOCOMPLETE_LINES_STEP     =          1'000;
    size_t       AUTOCOMPLETE_LINES_VAL      =         50'000;
    const size_t AUTOCOMPLETE_WORD_SIZE_DEF  =             40;
    const size_t AUTOCOMPLETE_WORD_SIZE_MAX  =            100;
    const size_t AUTOCOMPLETE_WORD_SIZE_MIN  =             10;
    const size_t AUTOCOMPLETE_WORD_SIZE_STEP =              1;
    size_t       AUTOCOMPLETE_WORD_SIZE_VAL  =             40;
    const size_t COUNT_CHAR_DEF              =          5'000;
    const size_t COUNT_CHAR_MAX              =      1'000'000;
    const size_t COUNT_CHAR_MIN              =              0;
    const size_t COUNT_CHAR_STEP             =          5'000;
    size_t       COUNT_CHAR_VAL              =          5'000;
    const size_t FILE_BACKUP_SIZE_DEF        =     50'000'000;
    const size_t FILE_BACKUP_SIZE_MAX        =    100'000'000;
    const size_t FILE_BACKUP_SIZE_MIN        =      1'000'000;
    const size_t FILE_BACKUP_SIZE_STEP       =      1'000'000;
    size_t       FILE_BACKUP_SIZE_VAL        =     50'000'000;
    const size_t FILE_SIZE_DEF               =  1'000'000'000;
    const size_t FILE_SIZE_MAX               =  2'000'000'000;
    const size_t FILE_SIZE_MIN               =     10'000'000;
    const size_t FILE_SIZE_STEP              =     10'000'000;
    size_t       FILE_SIZE_VAL               =  1'000'000'000;
    size_t       FORCE_RESTYLING             =              0;
    const size_t OUTPUT_LINES_DEF            =        100'000;
    const size_t OUTPUT_LINES_MAX            =        500'000;
    const size_t OUTPUT_LINES_MIN            =         50'000;
    const size_t OUTPUT_LINES_STEP           =         10'000;
    size_t       OUTPUT_LINES_VAL            =        100'000;
    const size_t OUTPUT_LINE_LENGTH_DEF      =            400;
    const size_t OUTPUT_LINE_LENGTH_MAX      =           2000;
    const size_t OUTPUT_LINE_LENGTH_MIN      =             80;
    const size_t OUTPUT_LINE_LENGTH_STEP     =             10;
    size_t       OUTPUT_LINE_LENGTH_VAL      =            400;
    const size_t SCROLL_DEF                  =             30;
    const size_t SCROLL_MAX                  =             60;
    const size_t SCROLL_MIN                  =             10;
    const size_t SCROLL_STEP                 =              1;
    size_t       SCROLL_VAL                  =             30;
    const size_t STYLE_FILESIZE_DEF          =     20'000'000;
    const size_t STYLE_FILESIZE_MAX          =    100'000'000;
    const size_t STYLE_FILESIZE_MIN          =        500'000;
    const size_t STYLE_FILESIZE_STEP         =        500'000;
    size_t       STYLE_FILESIZE_VAL          =     20'000'000;
    const size_t WRAP_LINE_LENGTH_DEF        =          3'000;
    const size_t WRAP_LINE_LENGTH_MAX        =         10'000;
    const size_t WRAP_LINE_LENGTH_MIN        =            100;
    const size_t WRAP_LINE_LENGTH_STEP       =            100;
    size_t       WRAP_LINE_LENGTH_VAL        =          3'000;
}
static const char _FLE_HEX_STRINGS[32 * 16 + 1] =
    "000102030405060708090a0b0c0d0e0f"
    "101112131415161718191a1b1c1d1e1f"
    "202122232425262728292a2b2c2d2e2f"
    "303132333435363738393a3b3c3d3e3f"
    "404142434445464748494a4b4c4d4e4f"
    "505152535455565758595a5b5c5d5e5f"
    "606162636465666768696a6b6c6d6e6f"
    "707172737475767778797a7b7c7d7e7f"
    "808182838485868788898a8b8c8d8e8f"
    "909192939495969798999a9b9c9d9e9f"
    "a0a1a2a3a4a5a6a7a8a9aaabacadaeaf"
    "b0b1b2b3b4b5b6b7b8b9babbbcbdbebf"
    "c0c1c2c3c4c5c6c7c8c9cacbcccdcecf"
    "d0d1d2d3d4d5d6d7d8d9dadbdcdddedf"
    "e0e1e2e3e4e5e6e7e8e9eaebecedeeef"
    "f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff";
Bookmarks::Bookmarks(Editor* editor, std::string bookmarks) {
    _editor = editor;
    for (const auto& bookmark : gnu::str::split(bookmarks, ",")) {
        if (bookmark != "") {
            auto pos = gnu::str::to_int(bookmark, -1);
            if (pos != -1) {
                _vec.push_back(pos);
            }
        }
    }
}
bool Bookmarks::add(int pos) {
    for (auto it = _vec.begin(); it != _vec.end(); ++it) {
        if (pos < *it) {
            _vec.insert(it, pos);
            return true;
        }
        else if (pos == *it) {
            _vec.erase(it);
            return false;
        }
    }
    _vec.push_back(pos);
    return true;
}
void Bookmarks::debug() const {
#ifdef DEBUG
    printf("\nBookmarks:\n");
    int c = 0;
    for (auto pos : _vec) {
        printf("    pos[%2d]            = %9d\n", c++, (int) pos);
    }
    fflush(stdout);
#endif
}
int Bookmarks::find_next(int pos, size_t& index) {
    index = 0;
    for (auto& bookmark : _vec) {
        if (bookmark > pos) {
            return (int) bookmark;
        }
        index++;
    }
    index = 0;
    return (_vec.size() > 0) ? (int) _vec.front() : -1;
}
int Bookmarks::find_prev(int pos, size_t& index) {
    index = _vec.size() - 1;
    for (auto it = _vec.rbegin(); it != _vec.rend(); ++it) {
        if (*it < pos) {
            return (int) *it;
        }
        index--;
    }
    index = _vec.size() - 1;
    return (_vec.size() > 0) ? (int) _vec.back() : -1;
}
void Bookmarks::goto_next() {
    assert(_editor);
    auto index = (size_t) 0;
    auto next  = find_next(_editor->cursor_insert_position(), index);
    if (next >= 0) {
        _editor->cursor_move_to_pos(next, true);
        _editor->statusbar_set_message(gnu::str::format("Bookmark %d of %d", (int) index + 1, (int) _vec.size()));
    }
}
void Bookmarks::goto_prev() {
    assert(_editor);
    auto index = (size_t) 0;
    auto prev = find_prev(_editor->cursor_insert_position(), index);
    if (prev >= 0) {
        _editor->cursor_move_to_pos(prev, true);
        _editor->statusbar_set_message(gnu::str::format("Bookmark %d of %d", (int) index + 1, (int) _vec.size()));
    }
}
void Bookmarks::toggle() {
    assert(_editor);
    auto pos = _editor->cursor_insert_position();
    if (add(pos) == true) {
        _editor->statusbar_set_message(gnu::str::format("Bookmark added at pos %d (total %d)", pos + 1, (int) _vec.size()));
    }
    else {
        _editor->statusbar_set_message(gnu::str::format("Bookmark deleted at pos %d (total %d)", pos + 1, (int) _vec.size()));
    }
}
std::string Bookmarks::tostring() const {
    std::string res;
    for (auto pos : _vec) {
        if (res != "") {
            res += ",";
        }
        res += gnu::str::format("%d", pos);
    }
    return res;
}
size_t Bookmarks::update(int pos, int inserted, int deleted) {
    auto size1 = _vec.size();
    auto it    = _vec.begin();
    while (it != _vec.end()) {
        if (deleted > 0 && *it >= pos && *it <= pos + deleted) {
            it = _vec.erase(it);
        }
        else if (pos <= *it) {
            *it += inserted;
            *it -= deleted;
            it++;
        }
        else {
            it++;
        }
    }
    return size1 - _vec.size();
}
CursorPos::CursorPos() {
    drag  = -1;
    end   = -1;
    pos1  = -1;
    pos2  = -1;
    sel   = -1;
    start = -1;
    swap  = false;
    top1  = -1;
    top2  = -1;
}
CursorPos::CursorPos(int pos1_, int pos2_, int start_, int end_, bool swap_) {
    drag  = 0;
    end   = end_;
    pos1  = pos1_;
    pos2  = pos2_;
    sel   = -1;
    start = start_;
    swap  = swap_;
    top1  = -1;
    top2  = -1;
    if (start >= 0 && end > start) {
        drag = (pos1 > start) ? start : end;
    }
}
CursorPos::CursorPos(int pos1_, int pos2_, int drag_, int start_, int end_, bool swap_) {
    drag  = drag_;
    end   = end_;
    pos1  = pos1_;
    pos2  = pos2_;
    sel   = -1;
    start = start_;
    swap  = swap_;
    top1  = -1;
    top2  = -1;
}
void CursorPos::_convert(bool swapped) {
    if ((swapped == true && swap == false) || (swapped == false && swap == true)) {
        auto tmp = pos1;
        pos1 = pos2;
        pos2 = tmp;
        tmp = top1;
        top1 = top2;
        top2 = tmp;
        swap = swapped;
    }
}
void CursorPos::debug(int line, const char* file) const {
#ifdef DEBUG
    printf("\nCursorPos: (%s -  %d)\n", file, line);
    printf("    pos1               = %9d\n", pos1);
    printf("    pos2               = %9d\n", pos2);
    printf("    top1               = %9d\n", top1);
    printf("    top2               = %9d\n", top2);
    printf("    drag               = %9d\n", drag);
    printf("    start              = %9d\n", start);
    printf("    end                = %9d\n", end);
    printf("    sel                = %9d\n", sel);
    printf("    swap               = %9s\n", swap ? "TRUE" : "FALSE");
    fflush(stdout);
#else
    (void) line;
    (void) file;
#endif
}
EditorFlags::EditorFlags() {
    dnd        = false;
    fsearchdir = FSearchDir::FORWARD;
    fsplitview = FSplitView::VERTICAL;
    fwrap      = FWrap::NO;
    kommand    = false;
    ro         = false;
    tab_mode   = FTab::SOFT;
    tab_width  = 8;
    wrap_col   = 0;
}
void EditorFlags::debug() const {
#ifdef DEBUG
    printf("\nEditorFlags:\n");
    printf("    fsearchdir         = %9d\n", (int) fsearchdir);
    printf("    fsplitview         = %9d\n", (int) fsplitview);
    printf("    fwrap              = %9s\n", fwrap == FWrap::YES ? "YES" : "NO");
    printf("    kommand            = %9s\n", kommand ? "TRUE" : "FALSE");
    printf("    ro                 = %9s\n", ro ? "TRUE" : "FALSE");
    printf("    tab_mode           = %9s\n", tab_mode == FTab::HARD ? "HARD" : "SOFT");
    printf("    tab_width          = %9u\n", tab_width);
    printf("    wrap_col           = %9u\n", wrap_col);
    fflush(stdout);
#endif
}
void EditorFlags::set_tab_from_string(std::string s) {
    if (s == "FTab::HARD") {
        tab_mode = FTab::HARD;
    }
    else if (s == "FTab::SOFT") {
        tab_mode = FTab::SOFT;
    }
    else if (s == "1") {
        tab_width = 1;
    }
    else if (s == "2") {
        tab_width = 2;
    }
    else if (s == "3") {
        tab_width = 3;
    }
    else if (s == "4") {
        tab_width = 4;
    }
    else if (s == "5") {
        tab_width = 5;
    }
    else if (s == "6") {
        tab_width = 6;
    }
    else if (s == "7") {
        tab_width = 7;
    }
    else if (s == "8") {
        tab_width = 8;
    }
    else {
        assert(false);
    }
}
FileInfo::FileInfo() {
    binary      = false;
    fi          = gnu::file::File();
    flineending = FLineEnding::UNIX;
    reload_time = 0;
}
void FileInfo::debug() const {
#ifdef DEBUG
    printf("\nFileInfo:\n");
    printf("    backup_today       = %s\n", filename_backup_today.c_str());
    printf("    binary             = %9s\n", binary ? "TRUE" : "FALSE");
    printf("    file               = %s\n", fi.to_string().c_str());
    printf("    flineending        = %s\n", flineending == FLineEnding::UNIX ? "UNIX" : "WINDOWS");
    printf("    reload_time        = %9lld\n", (long long int) reload_time);
    fflush(stdout);
#endif
}
std::string FileInfo::TodayExt() {
    return "." + gnu::Time::FormatUnixToISO(gnu::Time::Clock(), false, true);
}
std::string help::find_lines() {
    std::string res = R"(Find lines in a file.
Enter an search string.
Or an valid regular expression (using pcre syntax).

Find all lines that starts with 'local'.
^local.*

Find all lines that end with 'do' and set found column.
.*(do$)

)";
    return res;
}
std::string help::flags(const Config& config) {
    std::string res;
    int width = 30;
    res += "Settings, flags and other limits:\n";
    res += gnu::str::format("%-*s = %d\n", width, "flw::PREF_FIXED_FONT", flw::PREF_FIXED_FONT);
    res += gnu::str::format("%-*s = %s\n", width, "flw::PREF_FIXED_FONTNAME", flw::PREF_FIXED_FONTNAME.c_str());
    res += gnu::str::format("%-*s = %d\n", width, "flw::PREF_FONT", flw::PREF_FONT);
    res += gnu::str::format("%-*s = %s\n", width, "flw::PREF_FONTNAME", flw::PREF_FONTNAME.c_str());
    res += gnu::str::format("%-*s = %d\n", width, "flw::PREF_FONTSIZE", flw::PREF_FONTSIZE);
    res += gnu::str::format("%-*s = %s\n", width, "pref::autocomplete", (int) config.pref_autocomplete ? "true" : "false");
    res += gnu::str::format("%-*s = %s\n", width, "pref::autoreload", config.pref_autoreload ? "true" : "false");
    res += gnu::str::format("%-*s = '%s'\n", width, "pref::backup", config.pref_backup.c_str());
    res += gnu::str::format("%-*s = %d\n", width, "pref::binary", config.pref_binary);
    res += gnu::str::format("%-*s = %d\n", width, "pref::cursor", (int) config.pref_cursor);
    res += gnu::str::format("%-*s = %s\n", width, "pref::pref_highlight", config.pref_highlight ? "true" : "false");
    res += gnu::str::format("%-*s = %s\n", width, "pref::indentation", config.pref_indentation ? "true" : "false");
    res += gnu::str::format("%-*s = %s\n", width, "pref::insert", config.pref_insert ? "true" : "false");
    res += gnu::str::format("%-*s = %s\n", width, "pref::linenumber", (int) config.pref_linenumber ? "true" : "false");
    res += gnu::str::format("%-*s = %d\n", width, "pref::tmp_fontsize", config.pref_tmp_fontsize);
    res += gnu::str::format("%-*s = %d\n", width, "pref::mouse_scroll", config.pref_mouse_scroll + 3);
    res += gnu::str::format("%-*s = %s\n", width, "pref::scheme", config.pref_scheme.c_str());
    res += gnu::str::format("%-*s = %s\n", width, "pref::statusbar", (int) config.pref_statusbar ? "true" : "false");
    res += gnu::str::format("%-*s = %d\n", width, "pref::wrap", config.pref_wrap);
    res += gnu::str::format("%-*s = %14s\n", width, "limits::AUTOCOMPLETE_FILESIZE", flw::util::format_int(limits::AUTOCOMPLETE_FILESIZE_VAL, '\'').c_str());
    res += gnu::str::format("%-*s = %14s\n", width, "limits::AUTOCOMPLETE_LINES", flw::util::format_int(limits::AUTOCOMPLETE_LINES_VAL, '\'').c_str());
    res += gnu::str::format("%-*s = %14s\n", width, "limits::AUTOCOMPLETE_WORD_SIZE", flw::util::format_int(limits::AUTOCOMPLETE_WORD_SIZE_VAL, '\'').c_str());
    res += gnu::str::format("%-*s = %14s\n", width, "limits::COUNT_CHAR", flw::util::format_int(limits::COUNT_CHAR_VAL, '\'').c_str());
    res += gnu::str::format("%-*s = %14s\n", width, "limits::FILE_BACKUP_SIZE", flw::util::format_int(limits::FILE_BACKUP_SIZE_VAL, '\'').c_str());
    res += gnu::str::format("%-*s = %14s\n", width, "limits::FILE_SIZE", flw::util::format_int(limits::FILE_SIZE_VAL, '\'').c_str());
    res += gnu::str::format("%-*s = %14s\n", width, "limits::FIND_LIST_MAX", flw::util::format_int(limits::FIND_LIST_MAX, '\'').c_str());
    res += gnu::str::format("%-*s = %14s\n", width, "limits::FORCE_RESTYLING", limits::FORCE_RESTYLING ? "YES" : "NO");
    res += gnu::str::format("%-*s = %14s\n", width, "limits::HEXFILE_SIZE_MAX", flw::util::format_int(limits::FILE_SIZE_VAL / limits::HEXFILE_DIVIDER, '\'').c_str());
    res += gnu::str::format("%-*s = %14s\n", width, "limits::OUTPUT_LINES", flw::util::format_int(limits::OUTPUT_LINES_VAL, '\'').c_str());
    res += gnu::str::format("%-*s = %14s\n", width, "limits::OUTPUT_LINE_LENGTH", flw::util::format_int(limits::OUTPUT_LINE_LENGTH_VAL, '\'').c_str());
    res += gnu::str::format("%-*s = %14s\n", width, "limits::SCROLL", flw::util::format_int(limits::SCROLL_VAL, '\'').c_str());
    res += gnu::str::format("%-*s = %14s\n", width, "limits::STYLE_FILESIZE", flw::util::format_int(limits::STYLE_FILESIZE_VAL, '\'').c_str());
    res += gnu::str::format("%-*s = %14s\n", width, "limits::UNDO_WARNING", flw::util::format_int(limits::UNDO_WARNING, '\'').c_str());
    res += gnu::str::format("%-*s = %14s\n", width, "limits::WRAP_LINE_LENGTH", flw::util::format_int(limits::WRAP_LINE_LENGTH_VAL, '\'').c_str());
    res += "\n";
    return res;
}
std::string help::general(const Config& config) {
    std::string res = R"(Font size can be overrided temporarily by using ctrl + mousewheel.
Right click to show the editor menu.
Use alt + mousewheel to scroll faster.

)";
    res += "Keyboard shortcuts:\n";
    std::string keys1;
    std::string keys2;
    for (size_t f = 0; f < static_cast<size_t>(fle::FKEY_SIZE); f++) {
        if (config.keys[f].help[0] != 0) {
            if (config.keys[f].kommand_u == false) {
                keys1 += config.keys[f].make_help(26);
            }
            else {
                keys2 += config.keys[f].make_help(26);
            }
        }
    }
    res += keys1;
    res += "\nCommand mode (press command key and release then key combination below):\n";
    res += keys2;
    res += "\n";
    return res;
}
std::string help::pcre() {
    std::string res = R"(Perl Compatible Regular Expressions

Regular expression basics:
.             Any character except newline
a             The character a
ab            The string ab
a|b           a or b
a*            0 or more a's
\             Escapes a special character

Regular expression quantifiers:
*             0 or more
+             1 or more
?             0 or 1
{2}           Exactly 2
{2, 5}        Between 2 and 5
{2,}          2 or more
Default is greedy. Append ? for reluctant.

Regular expression groups:
(...)         Capturing group
(?P<Y>...)    Capturing group named Y
(?:...)       Non-capturing group
(?>...)       Atomic group
(?|...)       Duplicate group numbers
\Y            Match the Y'th captured group
(?P=Y)        Match the named group Y
(?R)          Recurse into entire pattern
(?Y)          Recurse into numbered group Y
(?&Y)         Recurse into named group Y
\g{Y}         Match the named or numbered group Y
\g<Y>         Recurse into named or numbered group Y
(?#...)       Comment

Regular expression character classes:
[ab-d]        One character of: a, b, c, d
[^ab-d]       One character except: a, b, c, d
[\b]          Backspace character
\d            One digit
\D            One non-digit
\s            One whitespace
\S            One non-whitespace
\w            One word character
\W            One non-word character

Regular expression assertions:
^             Start of string
\A            Start of string, ignores m flag
$             End of string
\Z            End of string, ignores m flag
\b            Word boundary
\B            Non-word boundary
\G            Start of match
(?=...)       Positive lookahead
(?!...)       Negative lookahead
(?<=...)      Positive lookbehind
(?<!...)      Negative lookbehind
(?()|)        Conditional

Regular expression escapes:
\Q..\E        Remove special meaning

Regular expression flags:
i             Ignore case
m             ^ and $ match start and end of line
s             . matches newline as well
x             Allow spaces and comments
J             Duplicate group names allowed
U             Ungreedy quantifiers
(?iLmsux)     Set flags within regex

Regular expression special characters:
\n            Newline
\r            Carriage return
\t            Tab
\0            Null character
\YYY          Octal character YYY
\xYY          Hexadecimal character YY
\x{YY}        Hexadecimeal character YY
\cY           Control character Y

Regular expression posix classes:
[:alnum:]     Letters and digits
[:alpha:]     Letters
[:ascii:]     Ascii codes 0 - 127
[:blank:]     Space or tab only
[:cntrl:]     Control characters
[:digit:]     Decimal digits
[:graph:]     Visible characters, except space
[:lower:]     Lowercase letters
[:print:]     Visible characters
[:punct:]     Visible punctuation characters
[:space:]     Whitespace
[:upper:]     Uppercase letters
[:word:]      Word characters
[:xdigit:]    Hexadecimal digits

)";
    return res;
}
std::string help::replace_text() {
    std::string res = R"(Replace text in all files.
Enter an search string.
Or an valid regular expression (using pcre syntax).

)";
    return res;
}
std::string KeyConf::KeyDescr(int key) {
    if (key > 0x20 && key < 0x7F) {
        char b[20];
        snprintf(b, 20, "'%c'", key);
        return b;
    }
    switch (key) {
        case 0x20:
            return "space";
        case FL_BackSpace:
            return "backspace";
        case FL_Tab:
            return "tab";
        case FL_Enter:
            return "enter";
        case FL_Pause:
            return "pause";
        case FL_Scroll_Lock:
            return "scroll";
        case FL_Escape:
            return "escape";
        case FL_Home:
            return "home";
        case FL_Left:
            return "left";
        case FL_Up:
            return "up";
        case FL_Right:
            return "right";
        case FL_Down:
            return "down";
        case FL_Page_Up:
            return "page-up";
        case FL_Page_Down:
            return "page-down";
        case FL_End:
            return "end";
        case FL_Print:
            return "print";
        case FL_Insert:
            return "insert";
        case FL_Menu:
            return "menu";
        case FL_Help:
            return "help";
        case FL_Num_Lock:
            return "num";
        case FL_KP + 0:
            return "Kp 0";
        case FL_KP + 1:
            return "Kp 1";
        case FL_KP + 2:
            return "Kp 2";
        case FL_KP + 3:
            return "Kp 3";
        case FL_KP + 4:
            return "Kp 4";
        case FL_KP + 5:
            return "Kp 5";
        case FL_KP + 6:
            return "Kp 6";
        case FL_KP + 7:
            return "Kp 7";
        case FL_KP + 8:
            return "Kp 8";
        case FL_KP + 9:
            return "Kp 9";
        case FL_KP_Enter:
            return "kp enter";
        case FL_F + 1:
            return "F1";
        case FL_F + 2:
            return "F2";
        case FL_F + 3:
            return "F3";
        case FL_F + 4:
            return "F4";
        case FL_F + 5:
            return "F5";
        case FL_F + 6:
            return "F6";
        case FL_F + 7:
            return "F7";
        case FL_F + 8:
            return "F8";
        case FL_F + 9:
            return "F9";
        case FL_F + 10:
            return "F10";
        case FL_F + 11:
            return "F11";
        case FL_F + 12:
            return "F12";
        case FL_Shift_L:
            return "left shift";
        case FL_Shift_R:
            return "right shift";
        case FL_Control_L:
            return "left control";
        case FL_Control_R:
            return "right control";
        case FL_Caps_Lock:
            return "caps lock key";
        case FL_Meta_L:
            return "left meta";
        case FL_Meta_R:
            return "right meta";
        case FL_Alt_L:
            return "left alt";
        case FL_Alt_R:
            return "right alt";
        case FL_Delete:
            return "delete";
        default:
            return "?";
        }
}
bool KeyConf::has_custom_key() const {
    return alt_d != alt_u || ctrl_d != ctrl_u || shift_d != shift_u || kommand_d != kommand_u || key_d != key_u;
}
std::string KeyConf::make_help(int w) const {
    auto        lines = gnu::str::split(help, "|");
    std::string res;
    for (size_t f = 0; f < lines.size(); f++) {
        if (f == 0) {
            res += gnu::str::format("%-*s%s\n", w, to_string().c_str(), lines[f].c_str());
        }
        else {
            res += gnu::str::format("%-*s%s\n", w, "", lines[f].c_str());
        }
    }
    return res;
}
int KeyConf::to_int() const {
    if (kommand_u == true) {
        return 0;
    }
    auto res = key_u;
    if (alt_u == true) {
        res += FL_ALT;
    }
    if (ctrl_u == true) {
        res += FL_CTRL;
    }
    if (shift_u == true) {
        res += FL_SHIFT;
    }
    return res;
}
std::string KeyConf::to_string() const {
    std::string res;
    if (alt_u == true) {
        res = "alt";
    }
    if (ctrl_u == true) {
        if (res != "") {
            res += " + ";
        }
        res += "ctrl";
    }
    if (shift_u == true) {
        if (res != "") {
            res += " + ";
        }
        res += "shift";
    }
    if (res != "") {
        res += " + ";
    }
    res += KeyConf::KeyDescr(key_u);
    return res;
}
Message::Message(Config& config) : _config(config) {
    _id = 0;
    _id = _config.add_receiver(this);
}
Message::~Message() {
    _config.remove_receiver(this);
}
StatusBarInfo::StatusBarInfo() {
    col   = 0;
    end   = 0;
    pos   = 0;
    row   = 0;
    rows  = 0;
    start = 0;
}
void StatusBarInfo::debug() const {
#ifdef DEBUG
    printf("\nStatusBarInfo:\n");
    printf("    start              = %9d\n", start);
    printf("    end                = %9d\n", end);
    printf("    pos                = %9d\n", pos);
    printf("    selected           = %9d\n", end - start);
    printf("    rows               = %9d\n", rows);
    printf("    row                = %9d\n", row);
    printf("    column             = %9d\n", col);
#endif
}
gnu::file::Buf string::binary_to_hex(const void* in, size_t in_size, bool wide) {
    auto W  = 79.0;
    auto B1 = 16.0;
    auto B2 = 16;
    if (wide == true) {
        W  = 147.0;
        B1 = 32.0;
        B2 = 32;
    }
    auto size = static_cast<size_t>((in_size / B1 * W) + 4096);
    auto fbuf = gnu::file::Buf(size);
    auto pos  = (size_t) 0;
    auto buf  = static_cast<const unsigned char*>(in);
    auto p    = fbuf.str();
#ifdef DEBUG_EDITOR
    auto start = gnu::Time::Milli();
#endif
    for (size_t f = 0; f < in_size;) {
        sprintf(fbuf.str() + pos, "%08x:", static_cast<unsigned>(f));
        pos += 8;
        for (int e = 0; e < B2; e++) {
            if (f + e < in_size) {
                auto c = buf[f + e];
                auto h = 2 * c;
                p[pos++] = ' ';
                p[pos++] = fle::_FLE_HEX_STRINGS[h];
                p[pos++] = fle::_FLE_HEX_STRINGS[h + 1];
            }
            else {
                p[pos++] = ' ';
                p[pos++] = ' ';
                p[pos++] = ' ';
            }
            if (e == 7 || (B2 > 16 && (e == 15 || e == 23))) {
                p[pos++] = ' ';
                p[pos++] = '|';
            }
        }
        p[pos++] = ' ';
        p[pos++] = '|';
        p[pos++] = ' ';
        for (int e = 0; e < B2; e++) {
            if (f + e < in_size) {
                auto c = buf[f + e];
                if (c < 32 || c > 126) {
                    p[pos++] = '.';
                }
                else {
                    p[pos++] = c;
                }
            }
            else {
                p[pos++] = ' ';
            }
        }
        p[pos++]  = '\n';
        p[pos] = 0;
        f += B2;
    }
    fbuf.size(pos);
    return fbuf;
}
gnu::file::Buf string::binary_to_text(const void* in, size_t in_size) {
    static const void*   BUF = "Error: binary file to large!";
    const unsigned char* buf = static_cast<const unsigned char*>(in);
    size_t               utf = 0;
    for (size_t f = 0; f < in_size; f++) {
        if (buf[f] == '\t' || buf[f] == '\n' || buf[f] == '\r' || buf[f] == 0) {
            utf++;
        }
    }
    auto text_size = static_cast<size_t>(in_size + (in_size / 80) + 4096 + utf);
    if (text_size > limits::FILE_SIZE_VAL) {
        buf     = static_cast<const unsigned char*>(BUF);
        in_size = strlen(reinterpret_cast<const char*>(buf));
    }
    auto text_pos  = 0;
    auto fbuf      = gnu::file::Buf(text_size);
    auto nl        = 0;
    auto p         = fbuf.str();
    for (size_t f = 0; f < in_size; f++) {
        auto c = buf[f];
        if (c >= 0x20 && c < 0x7F) {
            p[text_pos++] = c;
            nl++;
        }
        else if (c == '\t') {
            p[text_pos++] = 0xc5;
            p[text_pos++] = 0xa7;
            nl++;
        }
        else if (c == '\n') {
            p[text_pos++] = 0xc5;
            p[text_pos++] = 0x88;
            nl++;
        }
        else if (c == '\r') {
            p[text_pos++] = 0xc5;
            p[text_pos++] = 0x99;
            nl++;
        }
        else if (c == 0) {
            p[text_pos++] = 0xc3;
            p[text_pos++] = 0x98;
            nl++;
        }
        else {
            p[text_pos++] = '.';
            nl++;
        }
        if (nl >= 80 && text_pos > 0) {
            p[text_pos++] = '\n';
            nl = 0;
        }
    }
    fbuf.size(text_pos);
    return fbuf;
}
std::string string::buffer_to_hex(const void* in, size_t in_size) {
    auto fbuf = gnu::file::Buf(in_size * 2);
    auto p    = fbuf.str();
    auto buf  = static_cast<const unsigned char*>(in);
    auto pos  = 0;
    for (size_t f = 0; f < in_size; f++) {
        auto h = 2 * buf[f];
        p[pos++] = fle::_FLE_HEX_STRINGS[h];
        p[pos++] = fle::_FLE_HEX_STRINGS[h + 1];
    }
    return fbuf.c_str();
}
std::string string::fix_dnd_filename(std::string filename) {
    gnu::str::replace(filename, "%20", " ");
    gnu::str::replace(filename, "%25", "%");
    gnu::str::replace(filename, "%23", "#");
    gnu::str::replace(filename, "%24", "$");
    gnu::str::replace(filename, "%3C", "<");
    gnu::str::replace(filename, "%3E", ">");
    gnu::str::replace(filename, "%3F", "?");
    gnu::str::replace(filename, "%5B", "[");
    gnu::str::replace(filename, "%5D", "]");
    gnu::str::replace(filename, "%7B", "{");
    gnu::str::replace(filename, "%7C", "|");
    gnu::str::replace(filename, "%7D", "}");
    return filename;
}
std::string string::fnltab(std::string text) {
    gnu::str::replace(text, "\\t", "\t");
    gnu::str::replace(text, "\\n", "\n");
    return text;
}
bool string::is_one_char(const char* in) {
    assert(in);
    if (*in == 0) {
        return false;
    }
    auto ustring = reinterpret_cast<const unsigned char*>(in);
    auto count   = 0;
    while (*ustring != 0) {
        count += (*ustring & 0xc0) != 0x80;
        ustring++;
        if (count > 1) {
            return false;
        }
    }
    return true;
}
int string::make_word_list(const char* text, fle::StringSet& words, const fle::StringSet& custom) {
    auto time     = gnu::Time::Milli();
    auto tokens   = Token::MakeWord();
    auto len      = strlen(text);
    auto word_len = (size_t) 0;
    auto tmp      = fle::StringHash();
    char word[limits::AUTOCOMPLETE_WORD_SIZE_MAX + 10];
    tmp.max_load_factor(0.8);
    if (len > 1'000'000) {
        tmp.reserve(50'000);
    }
    while (*text != 0) {
        auto c = (unsigned char) *text;
        auto t = tokens.get(c);
        if (t & Token::LETTER) {
            if (word_len < limits::AUTOCOMPLETE_WORD_SIZE_VAL) {
                word[word_len] = c;
                word_len++;
            }
        }
        else if (word_len > 1 && word_len < limits::AUTOCOMPLETE_WORD_SIZE_VAL) {
            word[word_len] = 0;
            tmp.insert(word);
            word_len = 0;
        }
        else {
            word_len = 0;
        }
        text++;
        if (tmp.size() > limits::AUTOCOMPLETE_LINES_VAL) {
            break;
        }
    }
    if (word_len > 1 && word_len < limits::AUTOCOMPLETE_WORD_SIZE_VAL) {
        word[word_len] = 0;
        tmp.insert(word);
    }
    for (const auto& w : custom) {
        tmp.insert(w);
    }
    for (const auto& w : tmp) {
        words.insert(w);
    }
    time = gnu::Time::Milli() - time;
#ifdef DEBUG_EDITOR
    printf("string::wordlist(%d words from %d bytes) in %u mS\n", (int) words.size(), (int) len, (unsigned) time);
    fflush(stdout);
#endif
    return time;
}
std::string string::rainbow_hex(const void* in, size_t in_size) {
    uint8_t out[32];
    rainbow(256, in, in_size, out, 0);
    return string::buffer_to_hex(out, 32);
}
void string::replace_char(char* in, char find, char replace) {
    assert(in);
    while (*in != 0) {
        if (*in == find) {
            *in = replace;
        }
        in++;
    }
}
int string::toints(const std::string& string, int numbers[], int size, int def) {
    auto in  = string.c_str();
    auto end = (char*) nullptr;
    auto res = 0;
    errno = 0;
    for (int f = 0; f < size; f++) {
        numbers[f] = def;
    }
    for (int f = 0; f < size; f++) {
        auto n = strtol(in, &end, 10);
        if (errno != 0) {
            break;
        }
        else if (in == end) {
            break;
        }
        else {
            numbers[res++] = n;
        }
        in = end;
    }
    return res;
}
std::string string::tolower(std::string in) {
    std::transform(in.begin(), in.end(), in.begin(), [](unsigned char c) { return std::tolower(c); });
    return in;
}
StyleProp::StyleProp() {
    attr_d    = attr_u    = 0;
    bgattr_d  = bgattr_u  = 0;
    bgcolor_d = bgcolor_u = 0;
    bold_d    = bold_u    = 0;
    color_d   = color_u   = 0;
    italic_d  = italic_u  = 0;
}
StyleProp::StyleProp(Fl_Color color, unsigned attr, bool bold, bool italic, Fl_Color bgcolor, unsigned bgattr) {
    attr_d    = attr_u    = attr;
    bgattr_d  = bgattr_u  = bgattr;
    bgcolor_d = bgcolor_u = bgcolor;
    bold_d    = bold_u    = bold;
    color_d   = color_u   = color;
    italic_d  = italic_u  = italic;
}
void StyleProp::debug(int index) const {
#ifdef DEBUG
    unsigned char r, g, b;
    printf("StyleProp(%d)\n", index);
    Fl::get_color(color_d, r, g, b);
    printf("    color_d:   0x%02x, 0x%02x, 0x%02x, %u\n", r, g, b, color_d);
    Fl::get_color(color_u, r, g, b);
    printf("    color_u:   0x%02x, 0x%02x, 0x%02x, %u\n", r, g, b, color_u);
    printf("    attr_d:    %u\n", attr_d);
    printf("    attr_u:    %u\n", attr_u);
    Fl::get_color(bgcolor_d, r, g, b);
    printf("    bgcolor_d: 0x%02x, 0x%02x, 0x%02x, %u\n", r, g, b, bgcolor_d);
    Fl::get_color(bgcolor_u, r, g, b);
    printf("    bgcolor_u: 0x%02x, 0x%02x, 0x%02x, %u\n", r, g, b, bgcolor_u);
    printf("    bgattr_d:  %u\n", bgattr_d);
    printf("    bgattr_u:  %u\n", bgattr_u);
    printf("    bold_d:    %u\n", bold_d);
    printf("    bold_u:    %u\n", bold_u);
    printf("    italic_d:  %u\n", italic_d);
    printf("    italic_u:  %u\n\n", italic_u);
    fflush(stdout);
#else
    (void) index;
#endif
}
int StyleProp::font() const {
    if (bold_u != bold_d && italic_u != italic_d) {
        return 3;
    }
    else if (italic_u != italic_d) {
        return 2;
    }
    else if (bold_u != bold_d) {
        return 1;
    }
    return 0;
}
void StyleProp::reset() {
    attr_u    = attr_d;
    bgattr_u  = bgattr_d;
    bgcolor_u = bgcolor_d;
    bold_u    = bold_d;
    color_u   = color_d;
    italic_u  = italic_d;
}
Token::Token() {
    _char[(unsigned char) 0]    = Token::NIL;
    _char[(unsigned char) '\t'] = Token::SPACE;
    _char[(unsigned char) '\n'] = Token::NEWLINE;
    _char[(unsigned char) '\r'] = Token::NEWLINE;
    _char[(unsigned char) ' ']  = Token::SPACE;
    _char[(unsigned char) '!']  = Token::PUNCTUATOR;
    _char[(unsigned char) '"']  = Token::STRING;
    _char[(unsigned char) '#']  = Token::PUNCTUATOR;
    _char[(unsigned char) '$']  = Token::PUNCTUATOR;
    _char[(unsigned char) '%']  = Token::PUNCTUATOR;
    _char[(unsigned char) '&']  = Token::PUNCTUATOR;
    _char[(unsigned char) '\''] = Token::STRING;
    _char[(unsigned char) '(']  = Token::PUNCTUATOR;
    _char[(unsigned char) ')']  = Token::PUNCTUATOR;
    _char[(unsigned char) '*']  = Token::PUNCTUATOR;
    _char[(unsigned char) '+']  = Token::PUNCTUATOR;
    _char[(unsigned char) ',']  = Token::PUNCTUATOR;
    _char[(unsigned char) '-']  = Token::PUNCTUATOR;
    _char[(unsigned char) '.']  = Token::PUNCTUATOR;
    _char[(unsigned char) '/']  = Token::PUNCTUATOR;
    _char[(unsigned char) ':']  = Token::PUNCTUATOR;
    _char[(unsigned char) ';']  = Token::PUNCTUATOR;
    _char[(unsigned char) '<']  = Token::PUNCTUATOR;
    _char[(unsigned char) '=']  = Token::PUNCTUATOR;
    _char[(unsigned char) '>']  = Token::PUNCTUATOR;
    _char[(unsigned char) '?']  = Token::PUNCTUATOR;
    _char[(unsigned char) '@']  = Token::PUNCTUATOR;
    _char[(unsigned char) '[']  = Token::PUNCTUATOR;
    _char[(unsigned char) '\\'] = Token::PUNCTUATOR;
    _char[(unsigned char) ']']  = Token::PUNCTUATOR;
    _char[(unsigned char) '^']  = Token::PUNCTUATOR;
    _char[(unsigned char) '_']  = Token::PUNCTUATOR;
    _char[(unsigned char) '`']  = Token::PUNCTUATOR;
    _char[(unsigned char) '{']  = Token::PUNCTUATOR;
    _char[(unsigned char) '|']  = Token::PUNCTUATOR;
    _char[(unsigned char) '}']  = Token::PUNCTUATOR;
    _char[(unsigned char) '~']  = Token::PUNCTUATOR;
    _char[127]                  = Token::CTRL;
    _char[192]                  = Token::CTRL;
    _char[193]                  = Token::CTRL;
    set(1, 8, Token::CTRL);
    set(11, 12, Token::CTRL);
    set(14, 31, Token::CTRL);
    set('0', '9', Token::DECIMAL);
    set('A', 'Z', Token::LETTER);
    set('a', 'z', Token::LETTER);
    set(128, 191, Token::UTF2);
    set(194, 244, Token::UTF1);
    set(245, 255, Token::CTRL);
}
Token::Token(const Token& other) {
    for (int f = 0; f < 256; f++) {
        _char[f] = other._char[f];
    }
}
Token::Token(Token&& other) {
    for (int f = 0; f < 256; f++) {
        _char[f] = other._char[f];
    }
}
Token& Token::operator=(const Token& other) {
    for (int f = 0; f < 256; f++) {
        _char[f] = other._char[f];
    }
    return *this;
}
Token& Token::operator=(Token&& other) {
    for (int f = 0; f < 256; f++) {
        _char[f] = other._char[f];
    }
    return *this;
}
void Token::Debug(unsigned t) {
#ifdef DEBUG
    printf("Token(%u): ", (unsigned) t);
    if (t & Token::NIL)           printf("NIL, ");
    if (t & Token::CTRL)          printf("CTRL, ");
    if (t & Token::NEWLINE)       printf("NEWLINE, ");
    if (t & Token::SPACE)         printf("SPACE, ");
    if (t & Token::PUNCTUATOR)    printf("PUNCTUATOR, ");
    if (t & Token::DECIMAL)       printf("DECIMAL, ");
    if (t & Token::LETTER)        printf("LETTER, ");
    if (t & Token::IDENT1)        printf("IDENT1, ");
    if (t & Token::IDENT2)        printf("IDENT2, ");
    if (t & Token::HEX)           printf("HEX, ");
    if (t & Token::NUM_SEPARATOR) printf("NUM_SEPARATOR, ");
    if (t & Token::VALUE)         printf("VALUE, ");
    if (t & Token::PRAGMA)        printf("PRAGMA, ");
    if (t & Token::UTF1)          printf("UTF1, ");
    if (t & Token::UTF2)          printf("UTF2, ");
    printf("\n");
    fflush(stdout);
#else
    (void) t;
#endif
}
Token::Type Token::get_first(const char* in) const {
    if (*in == 0) {
        return Token::NIL;
    }
    auto uin = reinterpret_cast<const unsigned char*>(in);
    if (uin[0] < 128) {
        return get(uin[0]);
    }
    else if (uin[0] >= 240 && uin[0] <= 244) {
        if (uin[1] < 128 || uin[1] > 191) return Token::NIL;
        if (uin[2] < 128 || uin[2] > 191) return Token::NIL;
        if (uin[3] < 128 || uin[3] > 191) return Token::NIL;
        return get(uin[0]);
    }
    else if (uin[0] >= 224 && uin[0] <= 239) {
        if (uin[1] < 128 || uin[1] > 191) return Token::NIL;
        if (uin[2] < 128 || uin[2] > 191) return Token::NIL;
        return get(uin[0]);
    }
    else if (uin[0] >= 194 && uin[0] <= 223) {
        if (uin[1] < 128 || uin[1] > 191) return Token::NIL;
        return get(uin[0]);
    }
    return Token::NIL;
}
Token::Type Token::get_last(const char* in, int len) const {
    if (*in == 0 || len == 0) {
        return Token::NIL;
    }
    auto last = len - 1;
    auto uin  = reinterpret_cast<const unsigned char*>(in);
    if (uin[last] < 128) {
        return get(uin[last]);
    }
    else if (len > 3) {
        uin += last - 3;
        if (uin[3] < 128 || uin[3] > 191)   return Token::NIL;
        if (uin[2] >= 194 && uin[2] <= 223) return get(uin[2]);
        if (uin[2] < 128 || uin[2] > 191)   return Token::NIL;
        if (uin[1] >= 224 && uin[1] <= 239) return get(uin[1]);
        if (uin[1] < 128 || uin[1] > 191)   return Token::NIL;
        if (uin[0] >= 240 && uin[0] <= 244) return get(uin[0]);
    }
    else if (len > 2) {
        uin += last - 2;
        if (uin[2] < 128 || uin[2] > 191)   return Token::NIL;
        if (uin[1] >= 194 && uin[1] <= 223) return get(uin[1]);
        if (uin[1] < 128 || uin[1] > 191)   return Token::NIL;
        if (uin[0] >= 224 && uin[0] <= 239) return get(uin[0]);
    }
    else if (len > 1) {
        uin += last - 1;
        if (uin[1] < 128 || uin[1] > 191)   return Token::NIL;
        if (uin[0] >= 194 && uin[0] <= 223) return get(uin[0]);
    }
    return Token::NIL;
}
Token Token::MakeWord() {
    auto res = Token();
    res.set('_', Token::LETTER);
    res.set('0', '9', Token::LETTER);
    res.set(128, 191, Token::LETTER);
    res.set(194, 244, Token::LETTER);
    return res;
}
Token& Token::set(uint8_t index, uint16_t value) {
    _char[index] = value;
    return *this;
}
Token& Token::set(uint8_t index_from, uint8_t index_to, uint16_t value) {
    for (int f = index_from; f <= index_to; f++) {
        _char[f] = value;
    }
    return *this;
}
}
namespace fle {
Config::Config() {
    _del               = false;
    _id                = 0;
    active             = nullptr;
    disable_autoreload = false;
    disable_lineending = false;
    disable_style      = false;
    disable_tab        = false;
    pref_autocomplete  = true;
    pref_autoreload    = true;
    pref_backup        = gnu::file::File();
    pref_binary        = FBinFile::NO;
    pref_cursor        = Fl_Text_Display::NORMAL_CURSOR;
    pref_highlight     = false;
    pref_indentation   = true;
    pref_insert        = true;
    pref_linenumber    = true;
    pref_mouse_scroll  = 3;
    pref_scheme        = style::SCHEME_DEF;
    pref_shrink_status = 0;
    pref_statusbar     = true;
    pref_tmp_fontsize  = 0;
    pref_undo          = FUndoMode::FLE_V1;
    pref_undo_buffer   = true;
    pref_wrap          = 80;
    _init_colors();
    _init_keys();
    _init_tabs();
    init_scheme(flw::PREF_FIXED_FONTSIZE);
}
bool Config::add_find_word(const std::string& word, bool append) {
    if (word == "" || gnu::str::is_whitespace(word) == true || word.find_first_of("\n\r\t") != std::string::npos || word.length() > 80) {
        return false;
    }
    if (find_list.size() > 0 && find_list.front() == word) {
        return false;
    }
    if (append == true) {
        gnu::str::list_append(find_list, word, limits::FIND_LIST_MAX);
    }
    else {
        gnu::str::list_insert(find_list, word, limits::FIND_LIST_MAX);
    }
    return true;
}
int Config::add_receiver(Message* object) {
    for (const auto o : _list) {
        if (o == object) {
            return object->object_id();
        }
    }
    _list.push_back(object);
    return ++_id;
}
bool Config::add_replace_word(const std::string& word, bool append) {
    if (word == "" || gnu::str::is_whitespace(word) == true || word.find_first_of("\n\r\t") != std::string::npos || word.length() > 80) {
        return false;
    }
    else if (replace_list.size() > 0 && replace_list.front() == word) {
        return false;
    }
    if (append == true) {
        gnu::str::list_append(replace_list, word, limits::FIND_LIST_MAX);
    }
    else {
        gnu::str::list_insert(replace_list, word, limits::FIND_LIST_MAX);
    }
    return true;
}
std::string Config::create_backup_filename(const std::string& filename) {
    if (pref_backup.is_dir() == false || filename == "") {
        return "";
    }
    std::string res = filename;
    gnu::str::replace(res, "\\", "_");
    gnu::str::replace(res, "/", "_");
    gnu::str::replace(res, ":", "_");
    return pref_backup.filename() + "/" + res;
}
void Config::debug() const {
#ifdef DEBUG
    printf("\nConfig: %p\n", this);
    printf("    active             = %p\n", active);
    printf("    id                 = %2d\n", _id);
    printf("    find_words         = %2d\n", (int) find_list.size());
    printf("    custom_words       = %2d\n", (int) custom_words.size());
    printf("    disable_autoreload = %s\n", disable_autoreload ? "true" : "false");
    printf("    disable_lineending = %s\n", disable_lineending ? "true" : "false");
    printf("    disable_style      = %s\n", disable_style ? "true" : "false");
    printf("    disable_tab        = %s\n", disable_tab ? "true" : "false");
    printf("    pref_autocomplete  = %s\n", pref_autocomplete ? "true" : "false");
    printf("    pref_autoreload    = %s\n", pref_autoreload ? "true" : "false");
    printf("    pref_backup        = %s\n", pref_backup.c_str());
    printf("    pref_binary        = %2d\n", (int) pref_binary);
    printf("    pref_cursor        = %2d\n", pref_cursor);
    printf("    pref_highlight     = %s\n", pref_highlight ? "true" : "false");
    printf("    pref_indentation   = %s\n", pref_indentation ? "true" : "false");
    printf("    pref_insert        = %s\n", pref_insert ? "true" : "false");
    printf("    pref_linenumber    = %s\n", pref_linenumber ? "true" : "false");
    printf("    pref_mouse_scroll  = %2u\n", pref_mouse_scroll);
    printf("    pref_scheme        = %s\n", pref_scheme.c_str());
    printf("    pref_shrink_status = %2d\n", pref_shrink_status);
    printf("    pref_statusbar     = %s\n", pref_statusbar ? "true" : "false");
    printf("    pref_tmp_fontsize  = %2d\n", pref_tmp_fontsize);
    printf("    pref_undo          = %2d\n", (int) pref_undo);
    printf("    pref_undo_buffer   = %s\n", pref_undo_buffer ? "true" : "false");
    printf("    pref_wrap          = %2u\n", pref_wrap);
    fflush(stdout);
#endif
}
bool Config::has_fle_undo() const {
    return pref_undo == FUndoMode::FLE_V1 || pref_undo == FUndoMode::FLE_V2 || pref_undo == FUndoMode::FLE_V3;
}
void Config::_init_colors() {
    size_t i = 0;
    blue[i++]    = StyleProp(fl_rgb_color(0xa3, 0xa3, 0xa3));
    blue[i++]    = StyleProp(fl_rgb_color(0x20, 0x28, 0x31));
    blue[i++]    = StyleProp(fl_rgb_color(0xd6, 0xd6, 0xd6));
    blue[i++]    = StyleProp(fl_rgb_color(0xa3, 0xa3, 0xa3));
    blue[i++]    = StyleProp(fl_rgb_color(0x6a, 0x7b, 0x83));
    blue[i++]    = StyleProp(fl_rgb_color(0x30, 0x38, 0x41));
    blue[i++]    = StyleProp(fl_rgb_color(0xff, 0x00, 0x00));
    blue[i++]    = StyleProp(fl_rgb_color(0x58, 0x58, 0xbc));
    blue[i++]    = StyleProp(fl_rgb_color(0x8a, 0x7e, 0x9f));
    blue[i++]    = StyleProp(fl_rgb_color(0x95, 0x46, 0x46));
    blue[i++]    = StyleProp(fl_rgb_color(0x8e, 0x8e, 0x00));
    blue[i++]    = StyleProp(fl_rgb_color(0x28, 0x75, 0x83));
    blue[i++]    = StyleProp(fl_rgb_color(0x88, 0x55, 0x00));
    blue[i++]    = StyleProp(fl_rgb_color(0xa3, 0xa3, 0xa3));
    blue[i++]    = StyleProp(fl_rgb_color(0x29, 0x63, 0x38));
    blue[i++]    = StyleProp(fl_rgb_color(0x29, 0x63, 0x38));
    blue[i++]    = StyleProp(fl_rgb_color(0x60, 0x60, 0x60));
    blue[i++]    = StyleProp(fl_rgb_color(0x60, 0x60, 0x60));
    blue[i++]    = StyleProp(fl_rgb_color(0xa3, 0xa3, 0xa3));
    i = 0;
    dark[i++]    = StyleProp(fl_rgb_color(0xa3, 0xa3, 0xa3));
    dark[i++]    = StyleProp(fl_rgb_color(0x20, 0x20, 0x20));
    dark[i++]    = StyleProp(fl_rgb_color(0xd6, 0xd6, 0xd6));
    dark[i++]    = StyleProp(fl_rgb_color(0xa3, 0xa3, 0xa3));
    dark[i++]    = StyleProp(fl_rgb_color(0x68, 0x68, 0x68));
    dark[i++]    = StyleProp(fl_rgb_color(0x30, 0x30, 0x30));
    dark[i++]    = StyleProp(fl_rgb_color(0xff, 0x00, 0x00));
    dark[i++]    = StyleProp(fl_rgb_color(0x58, 0x58, 0xbc));
    dark[i++]    = StyleProp(fl_rgb_color(0x8a, 0x7e, 0x9f));
    dark[i++]    = StyleProp(fl_rgb_color(0x95, 0x46, 0x46));
    dark[i++]    = StyleProp(fl_rgb_color(0x8e, 0x8e, 0x00));
    dark[i++]    = StyleProp(fl_rgb_color(0x28, 0x75, 0x83));
    dark[i++]    = StyleProp(fl_rgb_color(0x88, 0x55, 0x00));
    dark[i++]    = StyleProp(fl_rgb_color(0xa3, 0xa3, 0xa3));
    dark[i++]    = StyleProp(fl_rgb_color(0x29, 0x63, 0x38));
    dark[i++]    = StyleProp(fl_rgb_color(0x29, 0x63, 0x38));
    dark[i++]    = StyleProp(fl_rgb_color(0x60, 0x60, 0x60));
    dark[i++]    = StyleProp(fl_rgb_color(0x60, 0x60, 0x60));
    dark[i++]    = StyleProp(fl_rgb_color(0xa3, 0xa3, 0xa3));
    i = 0;
    def[i++]     = StyleProp(FL_FOREGROUND_COLOR);
    def[i++]     = StyleProp(FL_BACKGROUND2_COLOR);
    def[i++]     = StyleProp(FL_SELECTION_COLOR);
    def[i++]     = StyleProp(FL_FOREGROUND_COLOR);
    def[i++]     = StyleProp(FL_INACTIVE_COLOR);
    def[i++]     = StyleProp(49);
    def[i++]     = StyleProp(FL_FOREGROUND_COLOR);
    def[i++]     = StyleProp(FL_FOREGROUND_COLOR);
    def[i++]     = StyleProp(FL_FOREGROUND_COLOR);
    def[i++]     = StyleProp(FL_FOREGROUND_COLOR);
    def[i++]     = StyleProp(FL_FOREGROUND_COLOR);
    def[i++]     = StyleProp(FL_FOREGROUND_COLOR);
    def[i++]     = StyleProp(FL_FOREGROUND_COLOR);
    def[i++]     = StyleProp(FL_FOREGROUND_COLOR);
    def[i++]     = StyleProp(FL_FOREGROUND_COLOR);
    def[i++]     = StyleProp(FL_FOREGROUND_COLOR);
    def[i++]     = StyleProp(FL_FOREGROUND_COLOR);
    def[i++]     = StyleProp(FL_FOREGROUND_COLOR);
    def[i++]     = StyleProp(FL_FOREGROUND_COLOR);
    i = 0;
    light[i++]   = StyleProp(fl_rgb_color(0x38, 0x3a, 0x42));
    light[i++]   = StyleProp(fl_rgb_color(0xe6, 0xe6, 0xe6));
    light[i++]   = StyleProp(fl_rgb_color(0xc8, 0xc8, 0xc8));
    light[i++]   = StyleProp(fl_rgb_color(0x38, 0x3a, 0x42));
    light[i++]   = StyleProp(fl_rgb_color(0x8e, 0x8e, 0x8e));
    light[i++]   = StyleProp(fl_rgb_color(0xd6, 0xd6, 0xd6));
    light[i++]   = StyleProp(fl_rgb_color(0xff, 0x00, 0x00));
    light[i++]   = StyleProp(fl_rgb_color(0x16, 0x16, 0xff));
    light[i++]   = StyleProp(fl_rgb_color(0xa2, 0x54, 0xd6));
    light[i++]   = StyleProp(fl_rgb_color(0xa0, 0x00, 0x00));
    light[i++]   = StyleProp(fl_rgb_color(0x7e, 0x7e, 0x00));
    light[i++]   = StyleProp(fl_rgb_color(0x37, 0x7d, 0xaa));
    light[i++]   = StyleProp(fl_rgb_color(0xed, 0xa0, 0x5c));
    light[i++]   = StyleProp(fl_rgb_color(0x38, 0x3a, 0x42));
    light[i++]   = StyleProp(fl_rgb_color(0x16, 0x8e, 0x16));
    light[i++]   = StyleProp(fl_rgb_color(0x00, 0x60, 0x00));
    light[i++]   = StyleProp(fl_rgb_color(0xb0, 0xb0, 0xb0));
    light[i++]   = StyleProp(fl_rgb_color(0xb0, 0xb0, 0xb0));
    light[i++]   = StyleProp(fl_rgb_color(0x38, 0x3a, 0x42));
    i = 0;
    neon[i++]    = StyleProp(fl_rgb_color(0xff, 0xff, 0xff));
    neon[i++]    = StyleProp(fl_rgb_color(0x00, 0x00, 0x00));
    neon[i++]    = StyleProp(fl_rgb_color(0xe6, 0xe6, 0x00));
    neon[i++]    = StyleProp(fl_rgb_color(0xff, 0xff, 0xff));
    neon[i++]    = StyleProp(fl_rgb_color(0x95, 0x95, 0x95));
    neon[i++]    = StyleProp(fl_rgb_color(0x15, 0x15, 0x15));
    neon[i++]    = StyleProp(fl_rgb_color(0xff, 0x00, 0x00));
    neon[i++]    = StyleProp(fl_rgb_color(0x40, 0x40, 0xff));
    neon[i++]    = StyleProp(fl_rgb_color(0x9f, 0x00, 0x9f));
    neon[i++]    = StyleProp(fl_rgb_color(0xaa, 0x00, 0x00));
    neon[i++]    = StyleProp(fl_rgb_color(0xaa, 0xaa, 0x00));
    neon[i++]    = StyleProp(fl_rgb_color(0x42, 0xc1, 0xd8));
    neon[i++]    = StyleProp(fl_rgb_color(0xff, 0x9f, 0x00));
    neon[i++]    = StyleProp(fl_rgb_color(0xff, 0xff, 0xff));
    neon[i++]    = StyleProp(fl_rgb_color(0x00, 0xaa, 0x00));
    neon[i++]    = StyleProp(fl_rgb_color(0x00, 0xaa, 0x00));
    neon[i++]    = StyleProp(fl_rgb_color(0x85, 0x85, 0x85));
    neon[i++]    = StyleProp(fl_rgb_color(0x85, 0x85, 0x85));
    neon[i++]    = StyleProp(fl_rgb_color(0xff, 0xff, 0xff));
    i = 0;
    tan[i++]     = StyleProp(fl_rgb_color(0x58, 0x6e, 0x75));
    tan[i++]     = StyleProp(fl_rgb_color(0xfd, 0xf7, 0xe2));
    tan[i++]     = StyleProp(fl_rgb_color(0xc8, 0xc8, 0xc8));
    tan[i++]     = StyleProp(fl_rgb_color(0x58, 0x6e, 0x75));
    tan[i++]     = StyleProp(fl_rgb_color(0x83, 0x94, 0x96));
    tan[i++]     = StyleProp(fl_rgb_color(0xed, 0xe7, 0xd2));
    tan[i++]     = StyleProp(fl_rgb_color(0xff, 0x00, 0x00));
    tan[i++]     = StyleProp(fl_rgb_color(0x66, 0x79, 0xff));
    tan[i++]     = StyleProp(fl_rgb_color(0xba, 0x8f, 0x73));
    tan[i++]     = StyleProp(fl_rgb_color(0x81, 0x25, 0x25));
    tan[i++]     = StyleProp(fl_rgb_color(0x18, 0x7a, 0x76));
    tan[i++]     = StyleProp(fl_rgb_color(0x66, 0x66, 0x00));
    tan[i++]     = StyleProp(fl_rgb_color(0xb2, 0x47, 0xb8));
    tan[i++]     = StyleProp(fl_rgb_color(0x58, 0x6e, 0x75));
    tan[i++]     = StyleProp(fl_rgb_color(0x16, 0x8e, 0x16));
    tan[i++]     = StyleProp(fl_rgb_color(0x0a, 0x65, 0x2a));
    tan[i++]     = StyleProp(fl_rgb_color(0xa0, 0xa0, 0xa0));
    tan[i++]     = StyleProp(fl_rgb_color(0xa0, 0xa0, 0xa0));
    tan[i++]     = StyleProp(fl_rgb_color(0x58, 0x6e, 0x75));
}
void Config::_init_keys() {
    keys[FKEY_KOMMAND_START]        = { .num = FKEY_KOMMAND_START,        .alt_d = false, .alt_u = false, .ctrl_d = true,  .ctrl_u = false, .shift_d = false, .shift_u = false, .kommand_d = false, .kommand_u = false, .key_d = 'k',              .key_u = 0, .help = "Start command mode.|    Then press one of the command keys." };
    keys[FKEY_KOMMAND_STOP]         = { .num = FKEY_KOMMAND_STOP,         .alt_d = false, .alt_u = false, .ctrl_d = false, .ctrl_u = false, .shift_d = false, .shift_u = false, .kommand_d = true,  .kommand_u = false, .key_d = FL_Escape,        .key_u = 0, .help = "Stop command mode." };
    keys[FKEY_AUTOCOMPLETE]         = { .num = FKEY_AUTOCOMPLETE,         .alt_d = false, .alt_u = false, .ctrl_d = true,  .ctrl_u = false, .shift_d = false, .shift_u = false, .kommand_d = false, .kommand_u = false, .key_d = ' ',              .key_u = 0, .help = "Show autcomplete dialog." };
    keys[FKEY_BOOKMARKS_NEXT]       = { .num = FKEY_BOOKMARKS_NEXT,       .alt_d = false, .alt_u = false, .ctrl_d = false, .ctrl_u = false, .shift_d = false, .shift_u = false, .kommand_d = false, .kommand_u = false, .key_d = FL_F + 2,         .key_u = 0, .help = "Jump to next bookmark." };
    keys[FKEY_BOOKMARKS_PREV]       = { .num = FKEY_BOOKMARKS_PREV,       .alt_d = false, .alt_u = false, .ctrl_d = false, .ctrl_u = false, .shift_d = true,  .shift_u = false, .kommand_d = false, .kommand_u = false, .key_d = FL_F + 2,         .key_u = 0, .help = "Jump to previous bookmark." };
    keys[FKEY_BOOKMARKS_TOGGLE]     = { .num = FKEY_BOOKMARKS_TOGGLE,     .alt_d = false, .alt_u = false, .ctrl_d = false, .ctrl_u = false, .shift_d = false, .shift_u = false, .kommand_d = true,  .kommand_u = false, .key_d = 'b',              .key_u = 0, .help = "Toggle bookmark." };
    keys[FKEY_CASE_LOWER]           = { .num = FKEY_CASE_LOWER,           .alt_d = false, .alt_u = false, .ctrl_d = false, .ctrl_u = false, .shift_d = false, .shift_u = false, .kommand_d = true,  .kommand_u = false, .key_d = 'l',              .key_u = 0, .help = "Convert selected text to lower case." };
    keys[FKEY_CASE_UPPER]           = { .num = FKEY_CASE_UPPER,           .alt_d = false, .alt_u = false, .ctrl_d = false, .ctrl_u = false, .shift_d = true,  .shift_u = false, .kommand_d = true,  .kommand_u = false, .key_d = 'l',              .key_u = 0, .help = "Convert selected text to upper case." };
    keys[FKEY_COMMENT_BLOCK]        = { .num = FKEY_COMMENT_BLOCK,        .alt_d = false, .alt_u = false, .ctrl_d = false, .ctrl_u = false, .shift_d = false, .shift_u = false, .kommand_d = true,  .kommand_u = false, .key_d = 'c',              .key_u = 0, .help = "Toggle block comments for selected text." };
    keys[FKEY_COMMENT_LINE]         = { .num = FKEY_COMMENT_LINE,         .alt_d = true,  .alt_u = false, .ctrl_d = false, .ctrl_u = false, .shift_d = true,  .shift_u = false, .kommand_d = false, .kommand_u = false, .key_d = 'c',              .key_u = 0, .help = "Toggle line comments." };
    keys[FKEY_COPY_TEXT]            = { .num = FKEY_COPY_TEXT,            .alt_d = false, .alt_u = false, .ctrl_d = true,  .ctrl_u = false, .shift_d = false, .shift_u = false, .kommand_d = false, .kommand_u = false, .key_d = 'c',              .key_u = 0, .help = "Copy selected text or current line." };
    keys[FKEY_CUT_TEXT]             = { .num = FKEY_CUT_TEXT,             .alt_d = false, .alt_u = false, .ctrl_d = true,  .ctrl_u = false, .shift_d = false, .shift_u = false, .kommand_d = false, .kommand_u = false, .key_d = 'x',              .key_u = 0, .help = "Cut selected text or current line." };
    keys[FKEY_DELETE_LINE_LEFT]     = { .num = FKEY_DELETE_LINE_LEFT,     .alt_d = false, .alt_u = false, .ctrl_d = true,  .ctrl_u = false, .shift_d = true,  .shift_u = false, .kommand_d = false, .kommand_u = false, .key_d = FL_BackSpace,     .key_u = 0, .help = "Delete all characters to the left until start of line." };
    keys[FKEY_DELETE_LINE_RIGHT]    = { .num = FKEY_DELETE_LINE_RIGHT,    .alt_d = false, .alt_u = false, .ctrl_d = true,  .ctrl_u = false, .shift_d = true,  .shift_u = false, .kommand_d = false, .kommand_u = false, .key_d = FL_Delete,        .key_u = 0, .help = "Delete all characters to the right until end of the line." };
    keys[FKEY_DELETE_WORD_LEFT]     = { .num = FKEY_DELETE_WORD_LEFT,     .alt_d = false, .alt_u = false, .ctrl_d = true,  .ctrl_u = false, .shift_d = false, .shift_u = false, .kommand_d = false, .kommand_u = false, .key_d = FL_BackSpace,     .key_u = 0, .help = "Delete word to the left." };
    keys[FKEY_DELETE_WORD_RIGHT]    = { .num = FKEY_DELETE_WORD_RIGHT,    .alt_d = false, .alt_u = false, .ctrl_d = true,  .ctrl_u = false, .shift_d = false, .shift_u = false, .kommand_d = false, .kommand_u = false, .key_d = FL_Delete,        .key_u = 0, .help = "Delete word to the left." };
    keys[FKEY_DUP_TEXT]             = { .num = FKEY_DUP_TEXT,             .alt_d = true,  .alt_u = false, .ctrl_d = false, .ctrl_u = false, .shift_d = true,  .shift_u = false, .kommand_d = false, .kommand_u = false, .key_d = 'd',              .key_u = 0, .help = "Duplicate selection or current line if unselected." };
    keys[FKEY_ENTER1]               = { .num = FKEY_ENTER1,               .alt_d = false, .alt_u = false, .ctrl_d = false, .ctrl_u = false, .shift_d = false, .shift_u = false, .kommand_d = false, .kommand_u = false, .key_d = FL_Enter,         .key_u = 0, .help = "Break line and indent." };
    keys[FKEY_ENTER2]               = { .num = FKEY_ENTER2,               .alt_d = false, .alt_u = false, .ctrl_d = true,  .ctrl_u = false, .shift_d = false, .shift_u = false, .kommand_d = false, .kommand_u = false, .key_d = FL_Enter,         .key_u = 0, .help = "Insert new line and indent." };
    keys[FKEY_FIND_LINES]           = { .num = FKEY_FIND_LINES,           .alt_d = false, .alt_u = false, .ctrl_d = false, .ctrl_u = false, .shift_d = false, .shift_u = false, .kommand_d = true,  .kommand_u = false, .key_d = 'j',              .key_u = 0, .help = "Find lines in text and show result in output panel." };
    keys[FKEY_FIND_LINES_AGAIN]     = { .num = FKEY_FIND_LINES_AGAIN,     .alt_d = false, .alt_u = false, .ctrl_d = false, .ctrl_u = false, .shift_d = true,  .shift_u = false, .kommand_d = true,  .kommand_u = false, .key_d = 'j',              .key_u = 0, .help = "Repeat find lines." };
    keys[FKEY_GOTO_LINE]            = { .num = FKEY_GOTO_LINE,            .alt_d = false, .alt_u = false, .ctrl_d = true,  .ctrl_u = false, .shift_d = false, .shift_u = false, .kommand_d = false, .kommand_u = false, .key_d = 'g',              .key_u = 0, .help = "Goto line." };
    keys[FKEY_HELP]                 = { .num = FKEY_HELP,                 .alt_d = false, .alt_u = false, .ctrl_d = false, .ctrl_u = false, .shift_d = true,  .shift_u = false, .kommand_d = false, .kommand_u = false, .key_d = FL_F + 1,         .key_u = 0, .help = "Show editor help." };
    keys[FKEY_HOME]                 = { .num = FKEY_HOME,                 .alt_d = false, .alt_u = false, .ctrl_d = false, .ctrl_u = false, .shift_d = false, .shift_u = false, .kommand_d = false, .kommand_u = false, .key_d = FL_Home,          .key_u = 0, .help = "Move cursor to first word or first column." };
    keys[FKEY_JUMP_DOWN]            = { .num = FKEY_JUMP_DOWN,            .alt_d = false, .alt_u = false, .ctrl_d = true,  .ctrl_u = false, .shift_d = true,  .shift_u = false, .kommand_d = false, .kommand_u = false, .key_d = FL_Down,          .key_u = 0, .help = "Move cursor down (same number of lines as mouse scroll)." };
    keys[FKEY_JUMP_UP]              = { .num = FKEY_JUMP_UP,              .alt_d = false, .alt_u = false, .ctrl_d = true,  .ctrl_u = false, .shift_d = true,  .shift_u = false, .kommand_d = false, .kommand_u = false, .key_d = FL_Up,            .key_u = 0, .help = "Move cursor up (same number of lines as mouse scroll)." };
    keys[FKEY_MENU]                 = { .num = FKEY_MENU,                 .alt_d = false, .alt_u = false, .ctrl_d = true,  .ctrl_u = false, .shift_d = false, .shift_u = false, .kommand_d = false, .kommand_u = false, .key_d = 'm',              .key_u = 0, .help = "Show menu (where the mouse cursor is)." };
    keys[FKEY_MOVE_DOWN]            = { .num = FKEY_MOVE_DOWN,            .alt_d = true,  .alt_u = false, .ctrl_d = false, .ctrl_u = false, .shift_d = true,  .shift_u = false, .kommand_d = false, .kommand_u = false, .key_d = FL_Down,          .key_u = 0, .help = "Move current line(s) down." };
    keys[FKEY_MOVE_UP]              = { .num = FKEY_MOVE_UP,              .alt_d = true,  .alt_u = false, .ctrl_d = false, .ctrl_u = false, .shift_d = true,  .shift_u = false, .kommand_d = false, .kommand_u = false, .key_d = FL_Up,            .key_u = 0, .help = "Move current line(s) up." };
    keys[FKEY_OUTPUT_NEXT]          = { .num = FKEY_OUTPUT_NEXT,          .alt_d = false, .alt_u = false, .ctrl_d = false, .ctrl_u = false, .shift_d = false, .shift_u = false, .kommand_d = false, .kommand_u = false, .key_d = FL_F + 5,         .key_u = 0, .help = "Jump to next line in output panel." };
    keys[FKEY_OUTPUT_PREV]          = { .num = FKEY_OUTPUT_PREV,          .alt_d = false, .alt_u = false, .ctrl_d = false, .ctrl_u = false, .shift_d = true,  .shift_u = false, .kommand_d = false, .kommand_u = false, .key_d = FL_F + 5,         .key_u = 0, .help = "Jump to previous line in output panel." };
    keys[FKEY_OUTPUT_TOGGLE]        = { .num = FKEY_OUTPUT_TOGGLE,        .alt_d = false, .alt_u = false, .ctrl_d = false, .ctrl_u = false, .shift_d = false, .shift_u = false, .kommand_d = true,  .kommand_u = false, .key_d = '4',              .key_u = 0, .help = "Toggle output." };
    keys[FKEY_QUICK_FIND]           = { .num = FKEY_QUICK_FIND,           .alt_d = false, .alt_u = false, .ctrl_d = true,  .ctrl_u = false, .shift_d = false, .shift_u = false, .kommand_d = false, .kommand_u = false, .key_d = 'd',              .key_u = 0, .help = "Select current word (and set search word in find widget) or jump to next found word.|    Search is case sensitive and part of words can be found." };
    keys[FKEY_REDO]                 = { .num = FKEY_REDO,                 .alt_d = false, .alt_u = false, .ctrl_d = true,  .ctrl_u = false, .shift_d = true,  .shift_u = false, .kommand_d = false, .kommand_u = false, .key_d = 'z',              .key_u = 0, .help = "Redo changes." };
    keys[FKEY_REPLACE]              = { .num = FKEY_REPLACE,              .alt_d = false, .alt_u = false, .ctrl_d = false, .ctrl_u = false, .shift_d = false, .shift_u = false, .kommand_d = false, .kommand_u = false, .key_d = FL_F + 4,         .key_u = 0, .help = "Replace selection and search again." };
    keys[FKEY_SEARCH_BACKWARD]      = { .num = FKEY_SEARCH_BACKWARD,      .alt_d = false, .alt_u = false, .ctrl_d = false, .ctrl_u = false, .shift_d = true,  .shift_u = false, .kommand_d = false, .kommand_u = false, .key_d = FL_F + 3,         .key_u = 0, .help = "Search backward." };
    keys[FKEY_SEARCH_FORWARD]       = { .num = FKEY_SEARCH_FORWARD,       .alt_d = false, .alt_u = false, .ctrl_d = false, .ctrl_u = false, .shift_d = false, .shift_u = false, .kommand_d = false, .kommand_u = false, .key_d = FL_F + 3,         .key_u = 0, .help = "Search forward." };
    keys[FKEY_SELECT_LINE]          = { .num = FKEY_SELECT_LINE,          .alt_d = false, .alt_u = false, .ctrl_d = true,  .ctrl_u = false, .shift_d = false, .shift_u = false, .kommand_d = false, .kommand_u = false, .key_d = 'l',              .key_u = 0, .help = "Select current line." };
    keys[FKEY_SELECT_PAIR1]         = { .num = FKEY_SELECT_PAIR1,         .alt_d = false, .alt_u = false, .ctrl_d = false, .ctrl_u = false, .shift_d = false, .shift_u = false, .kommand_d = true,  .kommand_u = false, .key_d = 'p',              .key_u = 0, .help = "Select text between matching pairs of {}[]()<>." };
    keys[FKEY_SELECT_PAIR2]         = { .num = FKEY_SELECT_PAIR2,         .alt_d = false, .alt_u = false, .ctrl_d = false, .ctrl_u = false, .shift_d = true,  .shift_u = false, .kommand_d = true,  .kommand_u = false, .key_d = 'p',              .key_u = 0, .help = "Select text between matching pairs of {}[]()<>.|    Cursor will be moved to the end." };
    keys[FKEY_SELECT_STYLE]         = { .num = FKEY_SELECT_STYLE,         .alt_d = false, .alt_u = false, .ctrl_d = true,  .ctrl_u = false, .shift_d = true,  .shift_u = false, .kommand_d = false, .kommand_u = false, .key_d = 'd',              .key_u = 0, .help = "Select text with same highlightning code.|    Cursor will not be moved." };
    keys[FKEY_SHIFT_LEFT]           = { .num = FKEY_SHIFT_LEFT,           .alt_d = false, .alt_u = false, .ctrl_d = false, .ctrl_u = false, .shift_d = true,  .shift_u = false, .kommand_d = false, .kommand_u = false, .key_d = FL_Tab,           .key_u = 0, .help = "Insert/replace tab or shift lines to the left." };
    keys[FKEY_SHIFT_RIGHT]          = { .num = FKEY_SHIFT_RIGHT,          .alt_d = false, .alt_u = false, .ctrl_d = false, .ctrl_u = false, .shift_d = false, .shift_u = false, .kommand_d = false, .kommand_u = false, .key_d = FL_Tab,           .key_u = 0, .help = "Insert/replace tab or shift lines to the right." };
    keys[FKEY_SHOW_CUSTOM1]         = { .num = FKEY_SHOW_CUSTOM1,         .alt_d = false, .alt_u = false, .ctrl_d = true,  .ctrl_u = false, .shift_d = true,  .shift_u = false, .kommand_d = false, .kommand_u = false, .key_d = ' ',              .key_u = 0, .help = "Custom command 1" };
    keys[FKEY_SHOW_CUSTOM2]         = { .num = FKEY_SHOW_CUSTOM2,         .alt_d = true,  .alt_u = false, .ctrl_d = true,  .ctrl_u = false, .shift_d = true,  .shift_u = false, .kommand_d = false, .kommand_u = false, .key_d = ' ',              .key_u = 0, .help = "Custom command 2" };
    keys[FKEY_SHOW_FIND_REPLACE]    = { .num = FKEY_SHOW_FIND_REPLACE,    .alt_d = false, .alt_u = false, .ctrl_d = true,  .ctrl_u = false, .shift_d = false, .shift_u = false, .kommand_d = false, .kommand_u = false, .key_d = 'f',              .key_u = 0, .help = "Show find and replace widget (close with escape)." };
    keys[FKEY_SORT_ASCENDING]       = { .num = FKEY_SORT_ASCENDING,       .alt_d = false, .alt_u = false, .ctrl_d = false, .ctrl_u = false, .shift_d = false, .shift_u = false, .kommand_d = true,  .kommand_u = false, .key_d = 's',              .key_u = 0, .help = "Sort selected lines in ascending order." };
    keys[FKEY_SORT_DESCENDING]      = { .num = FKEY_SORT_DESCENDING,      .alt_d = false, .alt_u = false, .ctrl_d = false, .ctrl_u = false, .shift_d = true,  .shift_u = false, .kommand_d = true,  .kommand_u = false, .key_d = 's',              .key_u = 0, .help = "Sort selected lines in descending order." };
    keys[FKEY_UNDO]                 = { .num = FKEY_UNDO,                 .alt_d = false, .alt_u = false, .ctrl_d = true,  .ctrl_u = false, .shift_d = false, .shift_u = false, .kommand_d = false, .kommand_u = false, .key_d = 'z',              .key_u = 0, .help = "Undo changes." };
    keys[FKEY_VIEW_1]               = { .num = FKEY_VIEW_1,               .alt_d = false, .alt_u = false, .ctrl_d = false, .ctrl_u = false, .shift_d = false, .shift_u = false, .kommand_d = true,  .kommand_u = false, .key_d = '1',              .key_u = 0, .help = "Select left/top split edit widget." };
    keys[FKEY_VIEW_2]               = { .num = FKEY_VIEW_2,               .alt_d = false, .alt_u = false, .ctrl_d = false, .ctrl_u = false, .shift_d = false, .shift_u = false, .kommand_d = true,  .kommand_u = false, .key_d = '2',              .key_u = 0, .help = "Select right/bottom split edit widget or split editor." };
    keys[FKEY_VIEW_CLOSE]           = { .num = FKEY_VIEW_CLOSE,           .alt_d = false, .alt_u = false, .ctrl_d = false, .ctrl_u = false, .shift_d = false, .shift_u = false, .kommand_d = true,  .kommand_u = false, .key_d = '3',              .key_u = 0, .help = "Close split screen." };
    for (int f = 0; f < fle::FKEY_SIZE; f++) {
        keys[f].alt_u     = keys[f].alt_d;
        keys[f].ctrl_u    = keys[f].ctrl_d;
        keys[f].shift_u   = keys[f].shift_d;
        keys[f].kommand_u = keys[f].kommand_d;
        keys[f].key_u     = keys[f].key_d;
    }
}
void Config::init_scheme(Fl_Fontsize fs) {
    for (size_t f = 0; f <= style::STYLE_LAST; f++) {
        auto prop = style_prop(static_cast<style::STYLE>(f));
        scheme[f].color = prop->color();
        scheme[f].font  = flw::PREF_FIXED_FONT + prop->font();
        scheme[f].size  = fs;
        scheme[f].attr  = prop->attr();
        if (prop->bgcolor() != StyleProp::DEFAULT_BG && prop->bgattr() != 0) {
            scheme[f].bgcolor  = prop->bgcolor();
            scheme[f].attr    |= prop->bgattr();
        }
    }
}
void Config::init_scheme_to_default() {
    for (size_t f = 0; f <= style::STYLE_LAST; f++) {
        style_prop(static_cast<style::STYLE>(f))->reset();
    }
}
void Config::_init_tabs() {
    tab_bat             = FTab::HARD;
    tab_bat_width       = 4;
    tab_cpp             = FTab::SOFT;
    tab_cpp_width       = 4;
    tab_cs              = FTab::SOFT;
    tab_cs_width        = 4;
    tab_go              = FTab::SOFT;
    tab_go_width        = 4;
    tab_java            = FTab::SOFT;
    tab_java_width      = 4;
    tab_js              = FTab::SOFT;
    tab_js_width        = 4;
    tab_kotlin          = FTab::SOFT;
    tab_kotlin_width    = 4;
    tab_lua             = FTab::SOFT;
    tab_lua_width       = 4;
    tab_makefile        = FTab::HARD;
    tab_makefile_width  = 4;
    tab_markup          = FTab::SOFT;
    tab_markup_width    = 4;
    tab_php             = FTab::SOFT;
    tab_php_width       = 4;
    tab_python          = FTab::SOFT;
    tab_python_width    = 4;
    tab_ruby            = FTab::SOFT;
    tab_ruby_width      = 4;
    tab_rust            = FTab::SOFT;
    tab_rust_width      = 4;
    tab_shell           = FTab::SOFT;
    tab_shell_width     = 4;
    tab_text            = FTab::HARD;
    text_tab_width      = 4;
    tab_ts              = FTab::SOFT;
    tab_ts_width        = 4;
}
void Config::_load_color_pref(Fl_Preferences& pref) {
    _load_color_pref(pref, "blue", blue);
    _load_color_pref(pref, "dark", dark);
    _load_color_pref(pref, "def", def);
    _load_color_pref(pref, "light", light);
    _load_color_pref(pref, "neon", neon);
    _load_color_pref(pref, "tan", tan);
}
void Config::_load_color_pref(Fl_Preferences& pref, const std::string& name, StyleProp props[25]) {
    for (size_t f = 0; f <= style::STYLE_LAST; f++) {
        auto prop = &props[f];
        auto val  = 0;
        if (pref.get(gnu::str::format("%s_%02d_color", name.c_str(), f).c_str(), val, 0) == 1) {
            prop->color_u = val;
        }
        if (pref.get(gnu::str::format("%s_%02d_bgcolor", name.c_str(), f).c_str(), val, 0) == 1) {
            prop->bgcolor_u = val;
        }
        if (pref.get(gnu::str::format("%s_%02d_italic", name.c_str(), f).c_str(), val, 0) == 1) {
            prop->italic_u = val;
        }
        if (pref.get(gnu::str::format("%s_%02d_bold", name.c_str(), f).c_str(), val, 0) == 1) {
            prop->bold_u = val;
        }
        if (pref.get(gnu::str::format("%s_%02d_attr", name.c_str(), f).c_str(), val, 0) == 1) {
            prop->attr_u = val;
        }
        if (pref.get(gnu::str::format("%s_%02d_bgattr", name.c_str(), f).c_str(), val, 0) == 1) {
            prop->bgattr_u = val;
        }
    }
}
size_t Config::load_custom_wordlist(const std::string& filename) {
    custom_words.clear();
    if (filename == "") {
        send_message(message::CUSTOM_AUTOCOMPLETE);
        return 0;
    }
    auto buf = gnu::file::read(filename);
    if (buf.c_str() == nullptr) {
        send_message(message::CUSTOM_AUTOCOMPLETE);
        return 0;
    }
    string::make_word_list(buf.c_str(), custom_words);
    send_message(message::CUSTOM_AUTOCOMPLETE);
    return custom_words.size();
}
void Config::_load_key_pref(Fl_Preferences& pref) {
    _init_keys();
    auto keyboard = 0;
    pref.get("keyboard", keyboard, 0);
    if (keyboard == KeyConf::VERSION) {
        for (size_t f = 0; f < static_cast<size_t>(fle::FKEY_SIZE); f++) {
            auto value = 0;
            pref.get(gnu::str::format("alt_%02d", f).c_str(), value, keys[f].alt_d);
            keys[f].alt_u = value;
            pref.get(gnu::str::format("ctrl_%02d", f).c_str(), value, keys[f].ctrl_d);
            keys[f].ctrl_u = value;
            pref.get(gnu::str::format("shift_%02d", f).c_str(), value, keys[f].shift_d);
            keys[f].shift_u = value;
            pref.get(gnu::str::format("kommand_%02d", f).c_str(), value, keys[f].kommand_d);
            keys[f].kommand_u = value;
            pref.get(gnu::str::format("key_%02d", f).c_str(), value, keys[f].key_d);
            keys[f].key_u = value;
        }
    }
}
void Config::load_pref(Fl_Preferences& pref, FindReplace* findreplace) {
    auto val = 0;
    std::string s;
    _load_color_pref(pref);
    _load_key_pref(pref);
    {
        pref.get("fle.autocomplete", val, pref_autocomplete);
        pref_autocomplete = val;
        pref.get("fle.backup", s, "");
        gnu::file::File file(s);
        if (file.is_dir() == true) {
            pref_backup = file;
        }
        pref.get("fle.binary", val, 0);
        pref_binary = FBinFile::NO;
        if (val == 1) {
            pref_binary = FBinFile::TEXT;
        }
        else if (val == 2) {
            pref_binary = FBinFile::HEX_16;
        }
        else if (val == 3) {
            pref_binary = FBinFile::HEX_32;
        }
        pref.get("fle.cursor", val, Fl_Text_Display::NORMAL_CURSOR);
        pref_cursor = val;
        pref.get("fle.indent", val, pref_indentation);
        pref_indentation = val;
        pref.get("fle.highlight", val, pref_highlight);
        pref_highlight = val;
        pref.get("fle.insert", val, pref_insert);
        pref_insert = val;
        pref.get("fle.linenumber", val, pref_linenumber);
        pref_linenumber = val;
        pref.get("fle.reload", val, 0);
        pref_autoreload = val;
        pref.get("fle.scheme", s, style::SCHEME_DEF);
        pref_scheme = s;
        pref.get("fle.scroll", val, 0);
        pref_mouse_scroll = (val > 0 && (unsigned) val <= limits::MOUSE_SCROLL_MAX) ? val : 0;
        pref.get("fle.statusbar", val, pref_statusbar);
        pref_statusbar = val;
        pref.get("fle.undo_redo_mode", val, 0);
        pref_undo = FUndoMode::FLE_V1;
        if (val == static_cast<int>(FUndoMode::FLE_V2)) {
            pref_undo = FUndoMode::FLE_V2;
        }
        else if (val == static_cast<int>(FUndoMode::FLE_V3)) {
            pref_undo = FUndoMode::FLE_V3;
        }
        else if (val == static_cast<int>(FUndoMode::FLTK)) {
            pref_undo = FUndoMode::FLTK;
        }
        else if (val == static_cast<int>(FUndoMode::NONE)) {
            pref_undo = FUndoMode::NONE;
        }
    }
    {
        pref.get("tweak.autocomplete_filesize", val, 0);
        limits::AUTOCOMPLETE_FILESIZE_VAL = ((unsigned) val >= limits::AUTOCOMPLETE_FILESIZE_MIN && (unsigned) val <= limits::AUTOCOMPLETE_FILESIZE_MAX) ? val : limits::AUTOCOMPLETE_FILESIZE_DEF;
        pref.get("tweak.autocomplete_lines", val, 0);
        limits::AUTOCOMPLETE_LINES_VAL = ((unsigned) val >= limits::AUTOCOMPLETE_LINES_MIN && (unsigned) val <= limits::AUTOCOMPLETE_LINES_MAX) ? val : limits::AUTOCOMPLETE_LINES_DEF;
        pref.get("tweak.autocomplete_word_size", val, 0);
        limits::AUTOCOMPLETE_WORD_SIZE_VAL = ((unsigned) val >= limits::AUTOCOMPLETE_WORD_SIZE_MIN && (unsigned) val <= limits::AUTOCOMPLETE_WORD_SIZE_MAX) ? val : limits::AUTOCOMPLETE_WORD_SIZE_DEF;
        pref.get("tweak.count_char", val, 0);
        limits::COUNT_CHAR_VAL = ((unsigned) val >= limits::COUNT_CHAR_MIN && (unsigned) val <= limits::COUNT_CHAR_MAX) ? val : limits::COUNT_CHAR_DEF;
        pref.get("tweak.file_backup_size", val, 0);
        limits::FILE_BACKUP_SIZE_VAL = ((unsigned) val >= limits::FILE_BACKUP_SIZE_MIN && (unsigned) val <= limits::FILE_BACKUP_SIZE_MAX) ? val : limits::FILE_BACKUP_SIZE_DEF;
        pref.get("tweak.file_size", val, 0);
        limits::FILE_SIZE_VAL = ((unsigned) val >= limits::FILE_SIZE_MIN && (unsigned) val <= limits::FILE_SIZE_MAX) ? val : limits::FILE_SIZE_DEF;
        pref.get("tweak.force_restyling", val, 0);
        limits::FORCE_RESTYLING = (val == 1) ? 1 : 0;
        pref.get("tweak.output_lines", val, 0);
        limits::OUTPUT_LINES_VAL = ((unsigned) val >= limits::OUTPUT_LINES_MIN && (unsigned) val <= limits::OUTPUT_LINES_MAX) ? val : limits::OUTPUT_LINES_DEF;
        pref.get("tweak.output_line_length", val, 0);
        limits::OUTPUT_LINE_LENGTH_VAL = ((unsigned) val >= limits::OUTPUT_LINE_LENGTH_MIN && (unsigned) val <= limits::OUTPUT_LINE_LENGTH_MAX) ? val : limits::OUTPUT_LINE_LENGTH_DEF;
        pref.get("tweak.scroll", val, 0);
        limits::SCROLL_VAL = ((unsigned) val >= limits::SCROLL_MIN && (unsigned) val <= limits::SCROLL_MAX) ? val : limits::SCROLL_DEF;
        pref.get("tweak.style_filesize", val, 0);
        limits::STYLE_FILESIZE_VAL = ((unsigned) val >= limits::STYLE_FILESIZE_MIN && (unsigned) val <= limits::STYLE_FILESIZE_MAX) ? val : limits::STYLE_FILESIZE_DEF;
        pref.get("tweak.wrap_line_length", val, 0);
        limits::WRAP_LINE_LENGTH_VAL = ((unsigned) val >= limits::WRAP_LINE_LENGTH_MIN && (unsigned) val <= limits::WRAP_LINE_LENGTH_MAX) ? val : limits::WRAP_LINE_LENGTH_DEF;
    }
    {
        pref.get("finddialog.fregex", val, 0);
        FindDialog::REGEX = (val == (int) FRegex::YES) ? FRegex::YES : FRegex::NO;
        pref.get("finddialog.ftrim", val, 0);
        FindDialog::TRIM = (val == (int) FTrim::YES) ? FTrim::YES : FTrim::NO;
    }
    {
        pref.get("replacedialog.fcasecompare", val, 0);
        ReplaceDialog::CASECOMPARE = (val == (int) FCaseCompare::YES) ? FCaseCompare::YES : FCaseCompare::NO;
        pref.get("replacedialog.fnltab", val, 0);
        ReplaceDialog::NLTAB = (val >= (int) FNlTab::NO && val <= (int) FNlTab::YES) ? (FNlTab) val : FNlTab::NO;
        pref.get("replacedialog.fregex", val, 0);
        ReplaceDialog::REGEX = (val == (int) FRegex::YES) ? FRegex::YES : FRegex::NO;
        pref.get("replacedialog.fselection", val, 0);
        ReplaceDialog::SELECTION = (val == (int) FSelection::YES) ? FSelection::YES : FSelection::NO;
        pref.get("replacedialog.fwordcompare", val, 0);
        ReplaceDialog::WORDCOMPARE = (val == (int) FWordCompare::YES) ? FWordCompare::YES : FWordCompare::NO;
    }
    if (findreplace != nullptr) {
        pref.get("findreplace.fcasecompare", val, 0);
        findreplace->fcasecompare((val == (int) FCaseCompare::YES) ? FCaseCompare::YES : FCaseCompare::NO);
        pref.get("findreplace.fnltab", val, 0);
        if (val >= (int) FNlTab::NO && val <= (int) FNlTab::YES) {
            findreplace->fnltab((FNlTab) val);
        }
        pref.get("findreplace.fselection", val, 0);
        findreplace->fselection((val == (int) FSelection::YES) ? FSelection::YES : FSelection::NO);
        pref.get("findreplace.fwordcompare", val, 0);
        findreplace->fwordcompare((val == (int) FWordCompare::YES) ? FWordCompare::YES : FWordCompare::NO);
        pref.get("findreplace.fregex", val, 0);
        findreplace->fregex((val == (int) FRegex::YES) ? FRegex::YES : FRegex::NO);
    }
    {
        pref.get("fle.wordwrap", val, 80);
        pref_wrap = ((unsigned) val >= limits::WRAP_MIN && (unsigned) val <= limits::WRAP_MAX) ? val : limits::WRAP_DEF;
        pref.get("fle.syntax.bat.tab", val, (int) tab_mode(style::BAT));
        tab_mode(style::BAT, (val == 0) ? FTab::HARD : FTab::SOFT);
        pref.get("fle.syntax.bat.tab_width", val, tab_width(style::BAT));
        tab_width(style::BAT, val);
        pref.get("fle.syntax.cpp.tab", val, (int) tab_mode(style::CPP));
        tab_mode(style::CPP, (val == 0) ? FTab::HARD : FTab::SOFT);
        pref.get("fle.syntax.cpp.tab_width", val, tab_width(style::CPP));
        tab_width(style::CPP, val);
        pref.get("fle.syntax.cs.tab", val, (int) tab_mode(style::CS));
        tab_mode(style::CS, (val == 0) ? FTab::HARD : FTab::SOFT);
        pref.get("fle.syntax.cs.tab_width", val, tab_width(style::CS));
        tab_width(style::CS, val);
        pref.get("fle.syntax.go.tab", val, (int) tab_mode(style::GO));
        tab_mode(style::GO, (val == 0) ? FTab::HARD : FTab::SOFT);
        pref.get("fle.syntax.go.tab_width", val, tab_width(style::GO));
        tab_width(style::GO, val);
        pref.get("fle.syntax.java.tab", val, (int) tab_mode(style::JAVA));
        tab_mode(style::JAVA, (val == 0) ? FTab::HARD : FTab::SOFT);
        pref.get("fle.syntax.java.tab_width", val, tab_width(style::JAVA));
        tab_width(style::JAVA, val);
        pref.get("fle.syntax.js.tab", val, (int) tab_mode(style::JS));
        tab_mode(style::JS, (val == 0) ? FTab::HARD : FTab::SOFT);
        pref.get("fle.syntax.js.tab_width", val, tab_width(style::JS));
        tab_width(style::JS, val);
        pref.get("fle.syntax.kotlin.tab", val, (int) tab_mode(style::KOTLIN));
        tab_mode(style::KOTLIN, (val == 0) ? FTab::HARD : FTab::SOFT);
        pref.get("fle.syntax.kotlin.tab_width", val, tab_width(style::KOTLIN));
        tab_width(style::KOTLIN, val);
        pref.get("fle.syntax.lua.tab", val, (int) tab_mode(style::LUA));
        tab_mode(style::LUA, (val == 0) ? FTab::HARD : FTab::SOFT);
        pref.get("fle.syntax.lua.tab_width", val, tab_width(style::LUA));
        tab_width(style::LUA, val);
        pref.get("fle.syntax.makefile.tab", val, (int) tab_mode(style::MAKEFILE));
        tab_mode(style::MAKEFILE, (val == 0) ? FTab::HARD : FTab::SOFT);
        pref.get("fle.syntax.makefile.tab_width", val, tab_width(style::MAKEFILE));
        tab_width(style::MAKEFILE, val);
        pref.get("fle.syntax.markup.tab", val, (int) tab_mode(style::MARKUP));
        tab_mode(style::MARKUP, (val == 0) ? FTab::HARD : FTab::SOFT);
        pref.get("fle.syntax.markup.tab_width", val, tab_width(style::MARKUP));
        tab_width(style::MARKUP, val);
        pref.get("fle.syntax.python.tab", val, (int) tab_mode(style::PYTHON));
        tab_mode(style::PYTHON, (val == 0) ? FTab::HARD : FTab::SOFT);
        pref.get("fle.syntax.python.tab_width", val, tab_width(style::PYTHON));
        tab_width(style::PYTHON, val);
        pref.get("fle.syntax.ruby.tab", val, (int) tab_mode(style::RUBY));
        tab_mode(style::RUBY, (val == 0) ? FTab::HARD : FTab::SOFT);
        pref.get("fle.syntax.ruby.tab_width", val, tab_width(style::RUBY));
        tab_width(style::RUBY, val);
        pref.get("fle.syntax.rust.tab", val, (int) tab_mode(style::RUST));
        tab_mode(style::RUST, (val == 0) ? FTab::HARD : FTab::SOFT);
        pref.get("fle.syntax.rust.tab_width", val, tab_width(style::RUST));
        tab_width(style::RUST, val);
        pref.get("fle.syntax.shell.tab", val, (int) tab_mode(style::SHELL));
        tab_mode(style::SHELL, (val == 0) ? FTab::HARD : FTab::SOFT);
        pref.get("fle.syntax.shell.tab_width", val, tab_width(style::SHELL));
        tab_width(style::SHELL, val);
        pref.get("fle.syntax.text.tab", val, (int) tab_mode(style::TEXT));
        tab_mode(style::TEXT, (val == 0) ? FTab::HARD : FTab::SOFT);
        pref.get("fle.syntax.text.tab_width", val, tab_width(style::TEXT));
        tab_width(style::TEXT, val);
        pref.get("fle.syntax.ts.tab", val, (int) tab_mode(style::TS));
        tab_mode(style::TS, (val == 0) ? FTab::HARD : FTab::SOFT);
        pref.get("fle.syntax.ts.tab_width", val, tab_width(style::TS));
        tab_width(style::TS, val);
    }
    {
        size_t count = 1;
        while (count <= limits::FIND_LIST_MAX) {
            auto key = gnu::str::format("find.%d", (int) count++);
            pref.get(key.c_str(), s, "");
            if (s == "") {
                break;
            }
            add_find_word(s, true);
        }
        count = 1;
        while (count <= limits::FIND_LIST_MAX) {
            auto key = gnu::str::format("replace.%d", (int) count++);
            pref.get(key.c_str(), s, "");
            if (s == "") {
                break;
            }
            add_replace_word(s, true);
        }
    }
}
void Config::remove_receiver(const Message* object) {
    for (auto it = _list.begin(); it != _list.end(); ++it) {
        if (object == *it) {
            _list.erase(it);
            _del = true;
            return;
        }
    }
}
void Config::_save_color_pref(Fl_Preferences& pref) {
    _save_color_pref(pref, "blue", blue);
    _save_color_pref(pref, "dark", dark);
    _save_color_pref(pref, "def", def);
    _save_color_pref(pref, "light", light);
    _save_color_pref(pref, "neon", neon);
    _save_color_pref(pref, "tan", tan);
}
void Config::_save_color_pref(Fl_Preferences& pref, const std::string& name, const StyleProp props[25]) {
    for (size_t f = 0; f <= style::STYLE_LAST; f++) {
        auto prop = props[f];
        if (prop.color_u != prop.color_d) {
            pref.set(gnu::str::format("%s_%02d_color", name.c_str(), f).c_str(), (int) prop.color_u);
        }
        if (prop.bgcolor_u != prop.bgcolor_d) {
            pref.set(gnu::str::format("%s_%02d_bgcolor", name.c_str(), f).c_str(), (int) prop.bgcolor_u);
        }
        if (prop.italic_u != prop.italic_d) {
            pref.set(gnu::str::format("%s_%02d_italic", name.c_str(), f).c_str(), (int) prop.italic_u);
        }
        if (prop.bold_u != prop.bold_d) {
            pref.set(gnu::str::format("%s_%02d_bold", name.c_str(), f).c_str(), (int) prop.bold_u);
        }
        if (prop.attr_u != prop.attr_d) {
            pref.set(gnu::str::format("%s_%02d_attr", name.c_str(), f).c_str(), (int) prop.attr_u);
        }
        if (prop.bgattr_u != prop.bgattr_d) {
            pref.set(gnu::str::format("%s_%02d_bgattr", name.c_str(), f).c_str(), (int) prop.bgattr_u);
        }
    }
}
void Config::_save_key_pref(Fl_Preferences& pref) {
    for (int f = 0; f < fle::FKEY_SIZE; f++) {
        pref.set("keyboard", KeyConf::VERSION);
        if (keys[f].has_custom_key() == true) {
            pref.set(gnu::str::format("alt_%02d", f).c_str(), keys[f].alt_u);
            pref.set(gnu::str::format("ctrl_%02d", f).c_str(), keys[f].ctrl_u);
            pref.set(gnu::str::format("shift_%02d", f).c_str(), keys[f].shift_u);
            pref.set(gnu::str::format("kommand_%02d", f).c_str(), keys[f].kommand_u);
            pref.set(gnu::str::format("key_%02d", f).c_str(), keys[f].key_u);
        }
    }
}
void Config::save_pref(Fl_Preferences& pref, FindReplace* findreplace) {
    _save_color_pref(pref);
    _save_key_pref(pref);
    pref.set("fle.autocomplete", pref_autocomplete);
    pref.set("fle.backup", pref_backup.filename());
    pref.set("fle.binary", (int) pref_binary);
    pref.set("fle.cursor", pref_cursor);
    pref.set("fle.highlight", pref_highlight);
    pref.set("fle.indent", pref_indentation);
    pref.set("fle.insert", pref_insert);
    pref.set("fle.linenumber", pref_linenumber);
    pref.set("fle.reload", pref_autoreload);
    pref.set("fle.scheme", pref_scheme);
    pref.set("fle.scroll", (int) pref_mouse_scroll);
    pref.set("fle.statusbar", pref_statusbar);
    pref.set("fle.undo_redo_mode", (int) pref_undo);
    pref.set("fle.wordwrap", (int) pref_wrap);
    pref.set("tweak.autocomplete_filesize", (int) limits::AUTOCOMPLETE_FILESIZE_VAL);
    pref.set("tweak.autocomplete_lines", (int) limits::AUTOCOMPLETE_LINES_VAL);
    pref.set("tweak.autocomplete_word_size", (int) limits::AUTOCOMPLETE_WORD_SIZE_VAL);
    pref.set("tweak.count_char", (int) limits::COUNT_CHAR_VAL);
    pref.set("tweak.file_backup_size", (int) limits::FILE_BACKUP_SIZE_VAL);
    pref.set("tweak.file_size", (int) limits::FILE_SIZE_VAL);
    pref.set("tweak.output_lines", (int) limits::OUTPUT_LINES_VAL);
    pref.set("tweak.output_line_length", (int) limits::OUTPUT_LINE_LENGTH_VAL);
    pref.set("tweak.force_restyling", (int) limits::FORCE_RESTYLING);
    pref.set("tweak.scroll", (int) limits::SCROLL_VAL);
    pref.set("tweak.style_filesize", (int) limits::STYLE_FILESIZE_VAL);
    pref.set("tweak.wrap_line_length", (int) limits::WRAP_LINE_LENGTH_VAL);
    pref.set("finddialog.fregex", (int) FindDialog::REGEX);
    pref.set("finddialog.ftrim", (int) FindDialog::TRIM);
    pref.set("replacedialog.fcasecompare", (int) ReplaceDialog::CASECOMPARE);
    pref.set("replacedialog.fnltab", (int) ReplaceDialog::NLTAB);
    pref.set("replacedialog.fregex", (int) ReplaceDialog::REGEX);
    pref.set("replacedialog.fselection", (int) ReplaceDialog::SELECTION);
    pref.set("replacedialog.fwordcompare", (int) ReplaceDialog::WORDCOMPARE);
    if (findreplace != nullptr) {
        pref.set("findreplace.fcasecompare", (int) findreplace->fcasecompare());
        pref.set("findreplace.fnltab", (int) findreplace->fnltab());
        pref.set("findreplace.fregex", (int) findreplace->fregex());
        pref.set("findreplace.fselection", (int) findreplace->fselection());
        pref.set("findreplace.fwordcompare", (int) findreplace->fwordcompare());
    }
    pref.set("fle.syntax.bat.tab", (int) tab_mode(style::BAT));
    pref.set("fle.syntax.bat.tab_width", (int) tab_width(style::BAT));
    pref.set("fle.syntax.cpp.tab", (int) tab_mode(style::CPP));
    pref.set("fle.syntax.cpp.tab_width", (int) tab_width(style::CPP));
    pref.set("fle.syntax.cs.tab", (int) tab_mode(style::CS));
    pref.set("fle.syntax.cs.tab_width", (int) tab_width(style::CS));
    pref.set("fle.syntax.go.tab", (int) tab_mode(style::GO));
    pref.set("fle.syntax.go.tab_width", (int) tab_width(style::GO));
    pref.set("fle.syntax.java.tab", (int) tab_mode(style::JAVA));
    pref.set("fle.syntax.java.tab_width", (int) tab_width(style::JAVA));
    pref.set("fle.syntax.js.tab", (int) tab_mode(style::JS));
    pref.set("fle.syntax.js.tab_width", (int) tab_width(style::JS));
    pref.set("fle.syntax.kotlin.tab", (int) tab_mode(style::KOTLIN));
    pref.set("fle.syntax.kotlin.tab_width", (int) tab_width(style::KOTLIN));
    pref.set("fle.syntax.lua.tab", (int) tab_mode(style::LUA));
    pref.set("fle.syntax.lua.tab_width", (int) tab_width(style::LUA));
    pref.set("fle.syntax.makefile.tab", (int) tab_mode(style::MAKEFILE));
    pref.set("fle.syntax.makefile.tab_width", (int) tab_width(style::MAKEFILE));
    pref.set("fle.syntax.markup.tab", (int) tab_mode(style::MARKUP));
    pref.set("fle.syntax.markup.tab_width", (int) tab_width(style::MARKUP));
    pref.set("fle.syntax.python.tab", (int) tab_mode(style::PYTHON));
    pref.set("fle.syntax.python.tab_width", (int) tab_width(style::PYTHON));
    pref.set("fle.syntax.ruby.tab", (int) tab_mode(style::RUBY));
    pref.set("fle.syntax.ruby.tab_width", (int) tab_width(style::RUBY));
    pref.set("fle.syntax.rust.tab", (int) tab_mode(style::RUST));
    pref.set("fle.syntax.rust.tab_width", (int) tab_width(style::RUST));
    pref.set("fle.syntax.shell.tab", (int) tab_mode(style::SHELL));
    pref.set("fle.syntax.shell.tab_width", (int) tab_width(style::SHELL));
    pref.set("fle.syntax.text.tab", (int) tab_mode(style::TEXT));
    pref.set("fle.syntax.text.tab_width", (int) tab_width(style::TEXT));
    pref.set("fle.syntax.ts.tab", (int) tab_mode(style::TS));
    pref.set("fle.syntax.ts.tab_width", (int) tab_width(style::TS));
    int count = 1;
    for (const auto& find : find_list) {
        auto key = gnu::str::format("find.%d", count++);
        pref.set(key.c_str(), find);
    }
    count = 1;
    for (const auto& replace : replace_list) {
        auto key = gnu::str::format("replace.%d", count++);
        pref.set(key.c_str(), replace);
    }
}
void Config::send_message(const std::string& message, const std::string& s1, const std::string& s2, void* p) {
    static int COUNT = 0;
    auto       list  = _list;
    COUNT++;
    for (auto* o1 : list) {
        auto b = Message::CTRL::CONTINUE;
        if (_del == false) {
            b = o1->message(message, s1, s2, p);
        }
        else {
            for (auto* o2 : _list) {
                if (o1 == o2) {
                    b = o1->message(message, s1, s2, p);
                    break;
                }
            }
        }
        if (b == Message::CTRL::ABORT) {
            break;
        }
    }
    COUNT--;
    if (COUNT == 0) {
        _del = false;
    }
}
StyleProp* Config::style_prop(style::STYLE style) {
    if (pref_scheme == style::SCHEME_BLUE) {
        return &blue[style];
    }
    else if (pref_scheme == style::SCHEME_DARK) {
        return &dark[style];
    }
    else if (pref_scheme == style::SCHEME_LIGHT) {
        return &light[style];
    }
    else if (pref_scheme == style::SCHEME_NEON) {
        return &neon[style];
    }
    else if (pref_scheme == style::SCHEME_TAN) {
        return &tan[style];
    }
    else {
        return &def[style];
    }
}
FTab Config::tab_mode(const std::string& style_name) {
    if (style_name == style::BAT) {
        return tab_bat;
    }
    else if (style_name == style::CPP) {
        return tab_cpp;
    }
    else if (style_name == style::CS) {
        return tab_cs;
    }
    else if (style_name == style::GO) {
        return tab_go;
    }
    else if (style_name == style::JAVA) {
        return tab_java;
    }
    else if (style_name == style::JS) {
        return tab_js;
    }
    else if (style_name == style::KOTLIN) {
        return tab_kotlin;
    }
    else if (style_name == style::LUA) {
        return tab_lua;
    }
    else if (style_name == style::MAKEFILE) {
        return tab_makefile;
    }
    else if (style_name == style::MARKUP) {
        return tab_markup;
    }
    else if (style_name == style::PHP) {
        return tab_php;
    }
    else if (style_name == style::PYTHON) {
        return tab_python;
    }
    else if (style_name == style::RUBY) {
        return tab_ruby;
    }
    else if (style_name == style::RUST) {
        return tab_rust;
    }
    else if (style_name == style::SHELL) {
        return tab_shell;
    }
    else if (style_name == style::TS) {
        return tab_ts;
    }
    else {
        return tab_text;
    }
}
void Config::tab_mode(const std::string& style_name, FTab tab) {
    if (style_name == style::BAT) {
        tab_bat = tab;
    }
    else if (style_name == style::CPP) {
        tab_cpp = tab;
    }
    else if (style_name == style::CS) {
        tab_cs = tab;
    }
    else if (style_name == style::GO) {
        tab_go = tab;
    }
    else if (style_name == style::JAVA) {
        tab_java = tab;
    }
    else if (style_name == style::JS) {
        tab_js = tab;
    }
    else if (style_name == style::KOTLIN) {
        tab_kotlin = tab;
    }
    else if (style_name == style::LUA) {
        tab_lua = tab;
    }
    else if (style_name == style::MAKEFILE) {
        tab_makefile = tab;
    }
    else if (style_name == style::MARKUP) {
        tab_markup = tab;
    }
    else if (style_name == style::PYTHON) {
        tab_python = tab;
    }
    else if (style_name == style::RUBY) {
        tab_ruby = tab;
    }
    else if (style_name == style::RUST) {
        tab_rust = tab;
    }
    else if (style_name == style::SHELL) {
        tab_shell = tab;
    }
    else if (style_name == style::TS) {
        tab_ts = tab;
    }
    else {
        tab_text = tab;
    }
}
unsigned Config::tab_width(const std::string& style_name) {
    unsigned res = 4;
    if (style_name == style::BAT) {
        res = tab_bat_width;
    }
    else if (style_name == style::CPP) {
        res = tab_cpp_width;
    }
    else if (style_name == style::CS) {
        res = tab_cs_width;
    }
    else if (style_name == style::GO) {
        res = tab_go_width;
    }
    else if (style_name == style::JAVA) {
        res = tab_java_width;
    }
    else if (style_name == style::JS) {
        res = tab_js_width;
    }
    else if (style_name == style::KOTLIN) {
        res = tab_kotlin_width;
    }
    else if (style_name == style::LUA) {
        res = tab_lua_width;
    }
    else if (style_name == style::MAKEFILE) {
        res = tab_makefile_width;
    }
    else if (style_name == style::MARKUP) {
        res = tab_markup_width;
    }
    else if (style_name == style::PHP) {
        res = tab_php_width;
    }
    else if (style_name == style::PYTHON) {
        res = tab_python_width;
    }
    else if (style_name == style::RUBY) {
        res = tab_ruby_width;
    }
    else if (style_name == style::RUST) {
        res = tab_rust_width;
    }
    else if (style_name == style::SHELL) {
        res = tab_shell_width;
    }
    else if (style_name == style::TS) {
        res = tab_ts_width;
    }
    else {
        res = text_tab_width;
    }
    if (res > limits::TAB_WIDTH_MAX) {
        res = 4;
    }
    return res;
}
void Config::tab_width(const std::string& style_name, unsigned width) {
    if (width == 0 || width > limits::TAB_WIDTH_MAX) {
        return;
    }
    else if (style_name == style::BAT) {
        tab_bat_width = width;
    }
    else if (style_name == style::CPP) {
        tab_cpp_width = width;
    }
    else if (style_name == style::CS) {
        tab_cs_width = width;
    }
    else if (style_name == style::GO) {
        tab_go_width = width;
    }
    else if (style_name == style::JAVA) {
        tab_java_width = width;
    }
    else if (style_name == style::JS) {
        tab_js_width = width;
    }
    else if (style_name == style::KOTLIN) {
        tab_kotlin_width = width;
    }
    else if (style_name == style::LUA) {
        tab_lua_width = width;
    }
    else if (style_name == style::MAKEFILE) {
        tab_makefile_width = width;
    }
    else if (style_name == style::MARKUP) {
        tab_markup_width = width;
    }
    else if (style_name == style::PYTHON) {
        tab_python_width = width;
    }
    else if (style_name == style::RUBY) {
        tab_ruby_width = width;
    }
    else if (style_name == style::RUST) {
        tab_rust_width = width;
    }
    else if (style_name == style::SHELL) {
        tab_shell_width = width;
    }
    else if (style_name == style::TS) {
        tab_ts_width = width;
    }
    else {
        text_tab_width = width;
    }
}
}
#define _STYLE_START_TAG(X) ((X >= 'a' && X <= 'z') || (X >= 'A' && X <= 'Z') || X == '_' || X > 128)
#define _STYLE_VALID_TAG(X) ((X >= 'a' && X <= 'z') || (X >= 'A' && X <= 'Z') || (X >= '0' && X <= '9') || X == '_' || X == '-' || X == '.' || X == ':' || X > 128)
#define _STYLE_BACKSLASH()\
_style->poke(start, style::STYLE_FG);\
c = _text->peek(++start);\
\
if (c != 0) {\
    _style->poke(start, style::STYLE_FG);\
}
#define _STYLE_CHAR()\
_style->poke(start, style::STYLE_STRING);\
if (_text->peek(start + 1) == ascii::BACKSLASH && _text->peek(start + 3) == ascii::SINGLE_QUOTE) {\
    _style->poke(start + 1, style::STYLE_STRING);\
    _style->poke(start + 2, style::STYLE_STRING);\
    _style->poke(start + 3, style::STYLE_STRING);\
    start += 3;\
}\
else if (_text->peek(start + 2) == ascii::SINGLE_QUOTE) {\
    _style->poke(start + 1, style::STYLE_STRING);\
    _style->poke(start + 2, style::STYLE_STRING);\
    start += 2;\
}
#define _STYLE_COMMENT_LINE()\
e = start + _line_comment_size;\
\
for (; e < last; e++) {\
    if (_text->peek(e) == ascii::NEWLINE) {\
        break;\
    }\
}\
\
_style->poke(start, e, style::STYLE_COMMENT);\
start = e;
#define _STYLE_COMMENT_BLOCK()\
e = start + _block_start_size;\
for (; e < last; e++) {\
    c = _text->peek(e);\
    if (c == block_end_c && _text->compare(e, _block_end, _block_end_size)) {\
        e += _block_end_size;\
        break;\
    }\
}\
_style->poke(start, e, style::STYLE_BLOCK_COMMENT);\
start = e - 1;
#define _STYLE_IDENT()\
auto e = start;\
auto l = 0;\
w[0] = c;\
l++;\
e++;\
for (; e < last; e++) {\
    c = _text->peek(e);\
    t = _tokens.get(c);\
\
    if ((t & Token::IDENT2) == 0) {\
        break;\
    }\
    else if (l > MAX_WORD) {\
        break;\
    }\
    else {\
        w[l] = c;\
        l++;\
    }\
}\
w[l] = 0;\
l = style::WORD_GROUP0;\
auto it = _lookup.find(w);\
\
if (it != _lookup.end()) {\
    l = it->second;\
}\
if (l & style::WORD_GROUP1) {\
    if (prag == true) {\
        _style->poke(start, e, style::STYLE_PRAGMA);\
    }\
    else {\
        _style->poke(start, e, style::STYLE_KEYWORD);\
    }\
}\
else if (l & style::WORD_GROUP2) {\
    _style->poke(start, e, style::STYLE_TYPE);\
}\
else if (l & style::WORD_GROUP4) {\
    _style->poke(start, e, style::STYLE_PRAGMA);\
}\
else if (l & style::WORD_GROUP8) {\
    _style->poke(start, e, style::STYLE_VAR);\
}\
else {\
    while (c <= ascii::SPACE && e < last) {\
        if (c == '\n') {\
            prag = false;\
        }\
\
        e++;\
        c = _text->peek(e);\
    }\
\
    if (c == ascii::OPEN_PARENT) {\
        _style->poke(start, e, style::STYLE_FUNCTION);\
    }\
    else {\
        _style->poke(start, e, style::STYLE_FG);\
    }\
}\
start = e - 1;
#define _STYLE_NUM()\
cn  = _text->peek(start + 1);\
hex = (cn == 'X' || cn == 'x');\
bin = (cn == 'b' || cn == 'B');\
oct = (cn == 'o' || cn == 'O');\
e   = start + 1 + hex + bin + oct;\
E = p = 0;\
_style->poke(start, style::STYLE_NUMBER);\
if ((hex && !_hex) || (bin && !_bin) || (oct && !_oct)) {\
}\
else {\
    st = style::STYLE_NUMBER;\
    _style->poke(start + hex + bin + oct, st);\
    \
    if (hex) {\
        for (; e < last; e++) {\
            c = _text->peek(e);\
            t = _tokens.get(c);\
            if ((t & Token::DECIMAL) == 0 && (t & Token::HEX) == 0 && (t & Token::NUM_SEPARATOR) == 0) break;\
            _style->poke(e, st);\
        }\
    }\
    else if (bin) {\
        for (; e < last; e++) {\
            c = _text->peek(e);\
            t = _tokens.get(c);\
            if ((t & Token::DECIMAL) == 0 && (t & Token::NUM_SEPARATOR) == 0) break;\
            else if (c != '0' && c != '1' && (t & Token::NUM_SEPARATOR) == 0) st = style::STYLE_FG;\
            _style->poke(e, st);\
        }\
    }\
    else if (oct) {\
        for (; e < last; e++) {\
            c = _text->peek(e);\
            t = _tokens.get(c);\
            if ((t & Token::DECIMAL) == 0 && (t & Token::NUM_SEPARATOR) == 0) break;\
            else if ((c < '0' || c > '7') && (t & Token::NUM_SEPARATOR) == 0) st = style::STYLE_FG;\
            _style->poke(e, st);\
        }\
    }\
    else {\
        for (; e < last; e++) {\
            c = _text->peek(e);\
            t = _tokens.get(c);\
            if (p && (c == 'E' || c == 'e')) st = style::STYLE_FG;\
            else if (c == 'E' || c == 'e') E++;\
            else if (c == '+' && E == 0) break;\
            else if (c == '+') p++;\
            else if ((t & Token::DECIMAL) == 0 && (t & Token::NUM_SEPARATOR) == 0) break;\
            if (p > 1 || E > 1) st = style::STYLE_FG;\
            _style->poke(e, st);\
        }\
    }\
    start = e - 1;\
}
#define _STYLE_PRAGMA()\
_style->poke(start, style::STYLE_PRAGMA);\
prag = true;
#define _STYLE_STRING()\
stop = c;\
e    = start + 1;\
p    = 0;\
st   = style::STYLE_STRING;\
for (; e < last; e++) {\
    c = _text->peek(e);\
\
    if (p == ascii::BACKSLASH && c == ascii::NEWLINE) {\
        st = style::STYLE_RAW_STRING;\
    }\
    else if (c == ascii::NEWLINE) {\
        break;\
    }\
    else if (c == stop && p != ascii::BACKSLASH) {\
        break;\
    }\
\
    if (c == ascii::BACKSLASH && p == ascii::BACKSLASH) {\
        p = 0;\
    }\
    else if (c == stop && p == ascii::BACKSLASH) {\
        p = 0;\
    }\
    else {\
        p = c;\
    }\
}\
_style->poke(start, e + 1, st);\
start = e;
#define _STYLE_STRING_RAW(RAW_START_SIZE, RAW_END_C, RAW_END, RAW_END_SIZE, RAW_ESCAPE)\
e = start + RAW_START_SIZE;\
for (; e < last; e++) {\
    p = c;\
    c = _text->peek(e);\
\
    if (p == ascii::BACKSLASH && c == RAW_END_C && RAW_ESCAPE == true) {\
    }\
    else if (c == RAW_END_C && _text->compare(e, RAW_END, RAW_END_SIZE)) {\
        e += RAW_END_SIZE;\
        break;\
    }\
}\
_style->poke(start, e, style::STYLE_RAW_STRING);\
start = e - 1;
#define _STYLE_VALUE()\
if (_text->peek(start + 1) == ascii::OPEN_PARENT) {\
    l = 1;\
    e = start + 2;\
    for (; e < last; e++) {\
        c = _text->peek(e);\
\
        if (c == ascii::OPEN_PARENT) {\
            l++;\
        }\
        else if (c == ascii::CLOSE_PARENT) {\
            l--;\
        }\
        else if (c == ascii::NEWLINE) {\
            e++;\
            break;\
        }\
\
        if (l == 0) {\
            e++;\
            break;\
        }\
    }\
    _style->poke(start, style::STYLE_FG);\
    _style->poke(start + 1, style::STYLE_FG);\
    _style->poke(start + 2, e - 1, style::STYLE_VAR);\
    _style->poke(e - 1, style::STYLE_FG);\
    start = e;\
}\
else {\
    e = start + 1;\
    for (; e < last; e++) {\
        c = _text->peek(e);\
        t = _tokens.get(c);\
\
        if ((t & Token::IDENT2) == 0) {\
            break;\
        }\
    }\
\
    _style->poke(start, e, style::STYLE_VAR);\
    start = e;\
}
namespace fle {
Style::Style(const std::string& name) : _name(name) {
    _bin               = false;
    _block_end         = "";
    _block_end_size    = 0;
    _block_start       = "";
    _block_start_size  = 0;
    _hex               = false;
    _line_comment      = "";
    _line_comment_size = 0;
    _oct               = false;
    _pause             = false;
    _single_quote_str  = 0;
    _style             = nullptr;
    _text              = nullptr;
    for (size_t f = 0; f < Style::MAX_RAW; f++) {
        _raw_start[f]      = "";
        _raw_start_size[f] = 0;
        _raw_end[f]        = "";
        _raw_end_size[f]   = 0;
        _raw_escape[f]     = false;
    }
}
void Style::debug() const {
    printf("\nStyle(%s)\n", _name.c_str());
    printf("    _lookup             = %d\n", (int) _lookup.size());
    printf("    _words              = %d\n", (int) _words.size());
    printf("    _custom             = %d\n", (int) _custom.size());
    printf("    _block_start        = %s\n", _block_start);
    printf("    _block_start_size   = %d\n", _block_start_size);
    printf("    _block_end          = %s\n", _block_end);
    printf("    _block_end_size     = %d\n", _block_end_size);
    printf("    _line_comment       = %s\n", _line_comment);
    printf("    _line_comment_size  = %d\n", _line_comment_size);
    printf("    _bin                = %s\n", _bin ? "TRUE" : "FALSE");
    printf("    _hex                = %s\n", _hex ? "TRUE" : "FALSE");
    printf("    _oct                = %s\n", _oct ? "TRUE" : "FALSE");
    printf("\n");
    for (int f = 0; f < (int) Style::MAX_RAW; f++) {
        if (*_raw_start[f] == 0) {
            break;
        }
        printf("    raw(%d)\n", f);
        printf("        _raw_start      = %s\n", _raw_start[f]);
        printf("        _raw_start_size = %d\n", _raw_start_size[f]);
        printf("        _raw_end        = %s\n", _raw_end[f]);
        printf("        _raw_end_size   = %d\n", _raw_end_size[f]);
        printf("        _raw_escape     = %d\n", _raw_escape[f]);
        printf("\n");
    }
    for (int f = 0; f < 256; f++) {
        if (_tokens[f] & Token::NUM_SEPARATOR) printf("    NUM_SEPARATOR[%03d]  = %c\n", f, f);
        if (_tokens[f] & Token::PRAGMA)        printf("    PRAGMA[%03d]         = %c\n", f, f);
    }
    fflush(stdout);
}
bool Style::insert_word(const std::string& word, int word_type) {
    auto res = _lookup.insert({word, word_type});
#ifdef DEBUG
    if (res.second == false) {
        auto it = _lookup.find(word);
        printf("error: inserting %s with type %d failed (found type %d)\n", word.c_str(), word_type, it->second);
        fflush(stdout);
    }
#endif
    return res.second;
}
void Style::make_words() {
    _words.clear();
    for (const auto& it : _lookup) {
        if (it.first.length() > 1) {
            _words.insert(it.first);
        }
    }
    for (const auto& it : _custom) {
        _words.insert(it);
    }
}
Style* Style::MakeFromFile(const gnu::file::File& file) {
    auto ext = string::tolower(file.ext());
    if (ext == "bat" || ext == "cmd") {
        return new StyleBat();
    }
    else if (ext == "cs") {
        return new StyleCS();
    }
    else if (ext == "c" || ext == "cpp" || ext == "cc" || ext == "cxx" || ext == "h" || ext == "H" || ext == "hpp") {
        return new StyleCpp();
    }
    else if (ext == "go") {
        return new StyleGo();
    }
    else if (ext == "java") {
        return new StyleJava();
    }
    else if (ext == "js" || ext == "jsx" || ext == "json") {
        return new StyleJS();
    }
    else if (ext == "kt") {
        return new StyleKotlin();
    }
    else if (ext == "lua" || ext == "p8") {
        return new StyleLua();
    }
    else if (file.name() == "Makefile" || file.name() == "makefile" || file.name() == "GNUmakefile" || file.name() == "makeinclude" || file.name().find(".makefile") != std::string::npos) {
        return new StyleMakefile();
    }
    else if (ext == "html" || ext == "htm" || ext == "xml") {
        return new StyleMarkup();
    }
    else if (ext == "php") {
        return new StylePHP();
    }
    else if (ext == "py") {
        return new StylePython();
    }
    else if (ext == "rb") {
        return new StyleRuby();
    }
    else if (ext == "rs") {
        return new StyleRust();
    }
    else if (ext == "sh" || ext == "bash") {
        return new StyleShell();
    }
    else if (ext == "ts" || ext == "tsx") {
        return new StyleTS();
    }
    else {
        return new Style();
    }
}
Style* Style::MakeFromName(const std::string& name) {
    if (name == style::BAT) {
        return new StyleBat();
    }
    else if (name == style::CPP) {
        return new StyleCpp();
    }
    else if (name == style::CS) {
        return new StyleCS();
    }
    else if (name == style::GO) {
        return new StyleGo();
    }
    else if (name == style::JAVA) {
        return new StyleJava();
    }
    else if (name == style::JS) {
        return new StyleJS();
    }
    else if (name == style::KOTLIN) {
        return new StyleKotlin();
    }
    else if (name == style::LUA) {
        return new StyleLua();
    }
    else if (name == style::MAKEFILE) {
        return new StyleMakefile();
    }
    else if (name == style::MARKUP) {
        return new StyleMarkup();
    }
    else if (name == style::PYTHON) {
        return new StylePython();
    }
    else if (name == style::PHP) {
        return new StylePHP();
    }
    else if (name == style::RUBY) {
        return new StyleRuby();
    }
    else if (name == style::RUST) {
        return new StyleRust();
    }
    else if (name == style::SHELL) {
        return new StyleShell();
    }
    else if (name == style::TS) {
        return new StyleTS();
    }
    else {
        return new Style();
    }
}
int Style::update() {
    Fl::redraw();
    return update(0, _text->length(), 0, nullptr, nullptr, nullptr);
}
int Style::update(int, int, int, const char*, const char*, Editor*) {
    return 0;
}
StyleDef::StyleDef(const std::string& name) : Style(name) {
    _tokens.set('0', '9', Token::DECIMAL | Token::IDENT2);
    _tokens.set('A', 'F', Token::LETTER | Token::IDENT2 | Token::IDENT1 | Token::HEX);
    _tokens.set('G', 'Z', Token::LETTER | Token::IDENT2 | Token::IDENT1);
    _tokens.set('_', Token::IDENT2 | Token::IDENT1);
    _tokens.set('.', Token::PUNCTUATOR | Token::NUM_SEPARATOR);
    _tokens.set('a', 'f', Token::LETTER | Token::IDENT2 | Token::IDENT1 | Token::HEX);
    _tokens.set('g', 'z', Token::LETTER | Token::IDENT2 | Token::IDENT1);
}
int StyleDef::_expand_left(int& start) {
    auto time = gnu::Time::Milli();
    auto s    = (unsigned char) 0;
    auto f    = _text->line_start(start);
    while (f >= 0) {
        s = _style->peek(f);
        if (s != style::STYLE_INIT) {
            start = f + 1;
            break;
        }
        else {
            f--;
        }
    }
    if (s == style::STYLE_BLOCK_COMMENT || s == style::STYLE_RAW_STRING) {
        while (f >= 0) {
            s = _style->peek(f);
            if (s != style::STYLE_BLOCK_COMMENT && s != style::STYLE_RAW_STRING) {
                start = f + 1;
                break;
            }
            else if (f == 1) {
                start = 0;
                break;
            }
            else {
                start = f;
                f--;
            }
        }
    }
    else {
        while (f >= 0) {
            s = _style->peek(f);
            if (s == style::STYLE_BLOCK_COMMENT || s == style::STYLE_RAW_STRING) {
                start = f + 1;
                break;
            }
            else if (_text->peek(f) == '\n') {
                if (f > 0 && _text->peek(f - 1) == '\\') {
                    f--;
                }
                else {
                    start = f + 1;
                    break;
                }
            }
            else if (f == 1) {
                start = 0;
                break;
            }
            else {
                start = f;
                f--;
            }
        }
    }
    time = gnu::Time::Milli() - time;
    return time;
}
int StyleDef::_expand_right(int& end) {
    auto time = gnu::Time::Milli();
    auto f    = _text->line_end(end);
    auto s    = (unsigned char) 0;
    auto last = _text->length();
    while (f < last) {
        s = _style->peek(f);
        if (s != style::STYLE_INIT) {
            end = f - 1;
            break;
        }
        else {
            f++;
        }
    }
    if (s == style::STYLE_BLOCK_COMMENT || s == style::STYLE_RAW_STRING) {
        while (f < last) {
            s = _style->peek(f);
            if (s != style::STYLE_BLOCK_COMMENT && s != style::STYLE_RAW_STRING) {
                end = f;
                break;
            }
            else if (f == last - 1) {
                end = last;
                break;
            }
            else {
                end = f;
                f++;
            }
        }
    }
    else {
        while (f < last) {
            s = _style->peek(f);
            if (s == style::STYLE_BLOCK_COMMENT || s == style::STYLE_RAW_STRING) {
                while (f < last) {
                    f++;
                    s = _style->peek(f);
                    if (s != style::STYLE_BLOCK_COMMENT && s != style::STYLE_RAW_STRING) {
                        break;
                    }
                }
                end = f;
                break;
            }
            else if (_text->peek(f) == '\n') {
                end = f;
                break;
            }
            else if (f == last - 1) {
                end = last;
                break;
            }
            else {
                end = f;
                f++;
            }
        }
    }
    time = gnu::Time::Milli() - time;
    return time;
}
int StyleDef::update(int pos, int inserted_size, int deleted_size, const char*, const char*, Editor* editor) {
    assert(pos >= 0);
    if (_pause == true || pos < 0) {
        return 0;
    }
    auto time  = gnu::Time::Milli();
    auto start = (pos > 0) ? pos - 1 : 0;
    auto end   = pos + ((inserted_size > deleted_size) ? inserted_size : deleted_size);
    if (limits::FORCE_RESTYLING != 0) {
        start = 0;
        end   = _text->length();
    }
#ifdef DEBUG_STYLE
    printf("\nSTYLE_START: pos=%4d, end=%4d, length=%4d\n", pos, end, _text->length());
#endif
    if (start > 0 || end != _text->length()) {
#ifdef DEBUG_STYLE
        auto left_ms  = _expand_left(start);
        auto right_ms = _expand_right(end);
        printf("    start = %7d, time = %4d mS\n", start, left_ms);
        printf("    end   = %7d, time = %4d mS\n", end, right_ms);
        fflush(stdout);
#else
        _expand_left(start);
        _expand_right(end);
#endif
    }
    end = _update(start, end);
    if (end < _text->length() && _text->peek(end) != '\n') {
    #ifdef DEBUG_STYLE
        printf("    start= %7d, end = %7d, char = %c, new_end = %4d\n", start, end, _text->peek(end), _text->line_end(end));
    #endif
        auto start2 = end;
        end         = _text->line_end(end);
        end         = _update(start2, end);
    }
    time = gnu::Time::Milli() - time;
#ifdef DEBUG_STYLE
    printf("STYLE_END: %s(%d => %d) in %d mS\n\n", _name.c_str(), start, end, (int) time);
    fflush(stdout);
#endif
    if (editor != nullptr) {
        editor->view1()->redisplay_range(start, end + 100);
        if (editor->view2() != nullptr) {
            editor->view2()->redisplay_range(start, end + 100);
        }
    }
    return (int) time;
}
int StyleDef::_update(int start, int end) {
    auto bin            = false;
    auto block_end_c    = (unsigned) *_block_end;
    auto block_start_c  = (unsigned) *_block_start;
    auto c              = (unsigned) 0;
    auto cn             = 0;
    auto e              = 0;
    auto E              = 0;
    auto hex            = false;
    auto l              = 0;
    auto last           = _text->length();
    auto line_comment_c = (unsigned) *_line_comment;
    auto oct            = false;
    auto p              = (unsigned) 0;
    auto raw_end_c      = (unsigned) *_raw_end[0];
    auto raw_end_c1     = (unsigned) *_raw_end[1];
    auto raw_end_c2     = (unsigned) *_raw_end[2];
    auto raw_end_c3     = (unsigned) *_raw_end[3];
    auto raw_start_c    = (unsigned) *_raw_start[0];
    auto raw_start_c1   = (unsigned) *_raw_start[1];
    auto raw_start_c2   = (unsigned) *_raw_start[2];
    auto raw_start_c3   = (unsigned) *_raw_start[3];
    auto st             = style::STYLE_FG;
    auto stop           = (unsigned) 0;
    auto t              = (unsigned) 0;
    auto MAX_WORD       = 100;
    auto prag           = false;
    char w[110];
    while (start < end) {
        p = c;
        c = static_cast<unsigned>(_text->peek(start));
        t = static_cast<unsigned>(_tokens.get(c));
        if (c == 0) {
            break;
        }
        else if (c == '\n') {
            prag = false;
            _style->poke(start, style::STYLE_INIT);
        }
        else if (c <= ' ') {
            _style->poke(start, style::STYLE_FG);
        }
        else if (c == raw_start_c && _text->compare(start, _raw_start[0], _raw_start_size[0])) {
            _STYLE_STRING_RAW(_raw_start_size[0], raw_end_c, _raw_end[0], _raw_end_size[0], _raw_escape[0])
        }
        else if (c == raw_start_c1 && _text->compare(start, _raw_start[1], _raw_start_size[1])) {
            _STYLE_STRING_RAW(_raw_start_size[1], raw_end_c1, _raw_end[1], _raw_end_size[1], _raw_escape[1])
        }
        else if (c == raw_start_c2 && _text->compare(start, _raw_start[2], _raw_start_size[2])) {
            _STYLE_STRING_RAW(_raw_start_size[2], raw_end_c2, _raw_end[2], _raw_end_size[2], _raw_escape[2])
        }
        else if (c == raw_start_c3 && _text->compare(start, _raw_start[3], _raw_start_size[3])) {
            _STYLE_STRING_RAW(_raw_start_size[3], raw_end_c3, _raw_end[3], _raw_end_size[3], _raw_escape[3])
        }
        else if (c == block_start_c && _text->compare(start, _block_start, _block_start_size)) {
            _STYLE_COMMENT_BLOCK()
        }
        else if (c == '\\') {
            _STYLE_BACKSLASH()
        }
        else if (c == '\"') {
            _STYLE_STRING()
        }
        else if (c == '\'' && c == _single_quote_str) {
            _STYLE_STRING()
        }
        else if (c == '\'') {
            _STYLE_CHAR()
        }
        else if (c == line_comment_c && _text->compare(start, _line_comment, _line_comment_size)) {
            _STYLE_COMMENT_LINE()
        }
        else if (t & Token::PRAGMA) {
            _STYLE_PRAGMA()
        }
        else if (t & Token::IDENT1) {
            _STYLE_IDENT()
        }
        else if (t & Token::DECIMAL) {
            _STYLE_NUM()
        }
        else if (t & Token::VALUE) {
            _STYLE_VALUE()
        }
        else if (t & Token::PUNCTUATOR) {
            _style->poke(start, style::STYLE_PUNCTUATOR);
        }
        else {
            _style->poke(start, style::STYLE_FG);
        }
        start++;
    }
    return start;
}
}
namespace fle {
StyleBat::StyleBat() : StyleDef(style::BAT) {
    _line_comment      = "rem ";
    _line_comment_size = 4;
    insert_word("AUX", style::WORD_GROUP1);
    insert_word("BREAK", style::WORD_GROUP1);
    insert_word("CALL", style::WORD_GROUP1);
    insert_word("CASE", style::WORD_GROUP1);
    insert_word("CLS", style::WORD_GROUP1);
    insert_word("COM1", style::WORD_GROUP1);
    insert_word("COM2", style::WORD_GROUP1);
    insert_word("COM3", style::WORD_GROUP1);
    insert_word("COM4", style::WORD_GROUP1);
    insert_word("CON", style::WORD_GROUP1);
    insert_word("COPY", style::WORD_GROUP1);
    insert_word("DEFINED", style::WORD_GROUP1);
    insert_word("DEL", style::WORD_GROUP1);
    insert_word("DO", style::WORD_GROUP1);
    insert_word("DONE", style::WORD_GROUP1);
    insert_word("ECHO", style::WORD_GROUP1);
    insert_word("ELIF", style::WORD_GROUP1);
    insert_word("ELSE", style::WORD_GROUP1);
    insert_word("EQU", style::WORD_GROUP1);
    insert_word("ERRORLEVEL", style::WORD_GROUP1);
    insert_word("ESAC", style::WORD_GROUP1);
    insert_word("EXIST", style::WORD_GROUP1);
    insert_word("EXIT", style::WORD_GROUP1);
    insert_word("FI", style::WORD_GROUP1);
    insert_word("FOR", style::WORD_GROUP1);
    insert_word("FUNCTION", style::WORD_GROUP1);
    insert_word("GEQ", style::WORD_GROUP1);
    insert_word("GOTO", style::WORD_GROUP1);
    insert_word("GTR", style::WORD_GROUP1);
    insert_word("IF", style::WORD_GROUP1);
    insert_word("IN", style::WORD_GROUP1);
    insert_word("LEQ", style::WORD_GROUP1);
    insert_word("LOCAL", style::WORD_GROUP1);
    insert_word("LPT1", style::WORD_GROUP1);
    insert_word("LPT2", style::WORD_GROUP1);
    insert_word("LPT3", style::WORD_GROUP1);
    insert_word("LSS", style::WORD_GROUP1);
    insert_word("MD", style::WORD_GROUP1);
    insert_word("MOVE", style::WORD_GROUP1);
    insert_word("NEQ", style::WORD_GROUP1);
    insert_word("NOT", style::WORD_GROUP1);
    insert_word("NUL", style::WORD_GROUP1);
    insert_word("OFF", style::WORD_GROUP1);
    insert_word("ON", style::WORD_GROUP1);
    insert_word("PATH", style::WORD_GROUP1);
    insert_word("PAUSE", style::WORD_GROUP1);
    insert_word("POPD", style::WORD_GROUP1);
    insert_word("PRN", style::WORD_GROUP1);
    insert_word("PROMPT", style::WORD_GROUP1);
    insert_word("PUSHD", style::WORD_GROUP1);
    insert_word("READ", style::WORD_GROUP1);
    insert_word("REN", style::WORD_GROUP1);
    insert_word("RETURN", style::WORD_GROUP1);
    insert_word("SELECT", style::WORD_GROUP1);
    insert_word("SET", style::WORD_GROUP1);
    insert_word("SHIFT", style::WORD_GROUP1);
    insert_word("START", style::WORD_GROUP1);
    insert_word("THEN", style::WORD_GROUP1);
    insert_word("TITLE", style::WORD_GROUP1);
    insert_word("TYPE", style::WORD_GROUP1);
    insert_word("UNTIL", style::WORD_GROUP1);
    insert_word("VER", style::WORD_GROUP1);
    insert_word("VERIFY", style::WORD_GROUP1);
    insert_word("VOL", style::WORD_GROUP1);
    insert_word("WHILE", style::WORD_GROUP1);
    insert_word("aux", style::WORD_GROUP1);
    insert_word("break", style::WORD_GROUP1);
    insert_word("call", style::WORD_GROUP1);
    insert_word("case", style::WORD_GROUP1);
    insert_word("cls", style::WORD_GROUP1);
    insert_word("com1", style::WORD_GROUP1);
    insert_word("com2", style::WORD_GROUP1);
    insert_word("com3", style::WORD_GROUP1);
    insert_word("com4", style::WORD_GROUP1);
    insert_word("con", style::WORD_GROUP1);
    insert_word("copy", style::WORD_GROUP1);
    insert_word("defined", style::WORD_GROUP1);
    insert_word("del", style::WORD_GROUP1);
    insert_word("do", style::WORD_GROUP1);
    insert_word("done", style::WORD_GROUP1);
    insert_word("echo", style::WORD_GROUP1);
    insert_word("elif", style::WORD_GROUP1);
    insert_word("else", style::WORD_GROUP1);
    insert_word("equ", style::WORD_GROUP1);
    insert_word("errorlevel", style::WORD_GROUP1);
    insert_word("esac", style::WORD_GROUP1);
    insert_word("exist", style::WORD_GROUP1);
    insert_word("exit", style::WORD_GROUP1);
    insert_word("fi", style::WORD_GROUP1);
    insert_word("for", style::WORD_GROUP1);
    insert_word("function", style::WORD_GROUP1);
    insert_word("geq", style::WORD_GROUP1);
    insert_word("goto", style::WORD_GROUP1);
    insert_word("gtr", style::WORD_GROUP1);
    insert_word("if", style::WORD_GROUP1);
    insert_word("in", style::WORD_GROUP1);
    insert_word("leq", style::WORD_GROUP1);
    insert_word("local", style::WORD_GROUP1);
    insert_word("lpt1", style::WORD_GROUP1);
    insert_word("lpt2", style::WORD_GROUP1);
    insert_word("lpt3", style::WORD_GROUP1);
    insert_word("lss", style::WORD_GROUP1);
    insert_word("md", style::WORD_GROUP1);
    insert_word("move", style::WORD_GROUP1);
    insert_word("neq", style::WORD_GROUP1);
    insert_word("not", style::WORD_GROUP1);
    insert_word("nul", style::WORD_GROUP1);
    insert_word("off", style::WORD_GROUP1);
    insert_word("on", style::WORD_GROUP1);
    insert_word("path", style::WORD_GROUP1);
    insert_word("pause", style::WORD_GROUP1);
    insert_word("popd", style::WORD_GROUP1);
    insert_word("prn", style::WORD_GROUP1);
    insert_word("prompt", style::WORD_GROUP1);
    insert_word("pushd", style::WORD_GROUP1);
    insert_word("read", style::WORD_GROUP1);
    insert_word("ren", style::WORD_GROUP1);
    insert_word("return", style::WORD_GROUP1);
    insert_word("select", style::WORD_GROUP1);
    insert_word("set", style::WORD_GROUP1);
    insert_word("shift", style::WORD_GROUP1);
    insert_word("start", style::WORD_GROUP1);
    insert_word("then", style::WORD_GROUP1);
    insert_word("title", style::WORD_GROUP1);
    insert_word("type", style::WORD_GROUP1);
    insert_word("until", style::WORD_GROUP1);
    insert_word("ver", style::WORD_GROUP1);
    insert_word("verify", style::WORD_GROUP1);
    insert_word("vol", style::WORD_GROUP1);
    insert_word("while", style::WORD_GROUP1);
    make_words();
}
StyleCpp::StyleCpp() : StyleDef(style::CPP) {
    _line_comment      = "//";
    _line_comment_size = 2;
    _block_start       = "/*";
    _block_start_size  = 2;
    _block_end         = "*/";
    _block_end_size    = 2;
    _raw_start[0]      = "R\"(";
    _raw_start_size[0] = 3;
    _raw_end[0]        = ")\"";
    _raw_end_size[0]   = 2;
    _hex               = true;
    _bin               = true;
    _tokens.set('\'', Token::NUM_SEPARATOR | Token::PUNCTUATOR);
    _tokens.set('#', Token::PRAGMA);
    insert_word("and", style::WORD_GROUP1);
    insert_word("and_eq", style::WORD_GROUP1);
    insert_word("asm", style::WORD_GROUP1);
    insert_word("auto", style::WORD_GROUP1);
    insert_word("bitand", style::WORD_GROUP1);
    insert_word("bitor", style::WORD_GROUP1);
    insert_word("break", style::WORD_GROUP1);
    insert_word("case", style::WORD_GROUP1);
    insert_word("catch", style::WORD_GROUP1);
    insert_word("class", style::WORD_GROUP1);
    insert_word("compl", style::WORD_GROUP1);
    insert_word("concept", style::WORD_GROUP1);
    insert_word("continue", style::WORD_GROUP1);
    insert_word("default", style::WORD_GROUP1);
    insert_word("delete", style::WORD_GROUP1);
    insert_word("do", style::WORD_GROUP1);
    insert_word("else", style::WORD_GROUP1);
    insert_word("enum", style::WORD_GROUP1);
    insert_word("explicit", style::WORD_GROUP1);
    insert_word("final", style::WORD_GROUP1);
    insert_word("for", style::WORD_GROUP1);
    insert_word("friend", style::WORD_GROUP1);
    insert_word("goto", style::WORD_GROUP1);
    insert_word("if", style::WORD_GROUP1);
    insert_word("inline", style::WORD_GROUP1);
    insert_word("mutable", style::WORD_GROUP1);
    insert_word("namespace", style::WORD_GROUP1);
    insert_word("new", style::WORD_GROUP1);
    insert_word("noexcept", style::WORD_GROUP1);
    insert_word("not", style::WORD_GROUP1);
    insert_word("not_eq", style::WORD_GROUP1);
    insert_word("operator", style::WORD_GROUP1);
    insert_word("or", style::WORD_GROUP1);
    insert_word("or_eq", style::WORD_GROUP1);
    insert_word("override", style::WORD_GROUP1);
    insert_word("private", style::WORD_GROUP1);
    insert_word("protected", style::WORD_GROUP1);
    insert_word("public", style::WORD_GROUP1);
    insert_word("register", style::WORD_GROUP1);
    insert_word("requires", style::WORD_GROUP1);
    insert_word("return", style::WORD_GROUP1);
    insert_word("sizeof", style::WORD_GROUP1);
    insert_word("struct", style::WORD_GROUP1);
    insert_word("switch", style::WORD_GROUP1);
    insert_word("template", style::WORD_GROUP1);
    insert_word("this", style::WORD_GROUP1);
    insert_word("throw", style::WORD_GROUP1);
    insert_word("try", style::WORD_GROUP1);
    insert_word("union", style::WORD_GROUP1);
    insert_word("using", style::WORD_GROUP1);
    insert_word("virtual", style::WORD_GROUP1);
    insert_word("volatile", style::WORD_GROUP1);
    insert_word("while", style::WORD_GROUP1);
    insert_word("xor", style::WORD_GROUP1);
    insert_word("xor_eq", style::WORD_GROUP1);
    insert_word("FILE", style::WORD_GROUP2);
    insert_word("NULL", style::WORD_GROUP2);
    insert_word("bool", style::WORD_GROUP2);
    insert_word("char", style::WORD_GROUP2);
    insert_word("char16_t", style::WORD_GROUP2);
    insert_word("char32_t", style::WORD_GROUP2);
    insert_word("char8_t", style::WORD_GROUP2);
    insert_word("const", style::WORD_GROUP2);
    insert_word("double", style::WORD_GROUP2);
    insert_word("extern", style::WORD_GROUP2);
    insert_word("false", style::WORD_GROUP2);
    insert_word("float", style::WORD_GROUP2);
    insert_word("fpos_t", style::WORD_GROUP2);
    insert_word("int", style::WORD_GROUP2);
    insert_word("int16_t", style::WORD_GROUP2);
    insert_word("int32_t", style::WORD_GROUP2);
    insert_word("int64_t", style::WORD_GROUP2);
    insert_word("int8_t", style::WORD_GROUP2);
    insert_word("int_fast16_t", style::WORD_GROUP2);
    insert_word("int_fast32_t", style::WORD_GROUP2);
    insert_word("int_fast64_t", style::WORD_GROUP2);
    insert_word("int_fast8_t", style::WORD_GROUP2);
    insert_word("int_least16_t", style::WORD_GROUP2);
    insert_word("int_least32_t", style::WORD_GROUP2);
    insert_word("int_least64_t", style::WORD_GROUP2);
    insert_word("int_least8_t", style::WORD_GROUP2);
    insert_word("intmax_t", style::WORD_GROUP2);
    insert_word("intptr_t", style::WORD_GROUP2);
    insert_word("long", style::WORD_GROUP2);
    insert_word("nullptr", style::WORD_GROUP2);
    insert_word("off_t", style::WORD_GROUP2);
    insert_word("pid_t", style::WORD_GROUP2);
    insert_word("ptrdiff_t", style::WORD_GROUP2);
    insert_word("short", style::WORD_GROUP2);
    insert_word("sig_atomic_t", style::WORD_GROUP2);
    insert_word("signed", style::WORD_GROUP2);
    insert_word("size_t", style::WORD_GROUP2);
    insert_word("ssize_t", style::WORD_GROUP2);
    insert_word("static", style::WORD_GROUP2);
    insert_word("time_t", style::WORD_GROUP2);
    insert_word("true", style::WORD_GROUP2);
    insert_word("uint16_t", style::WORD_GROUP2);
    insert_word("uint32_t", style::WORD_GROUP2);
    insert_word("uint64_t", style::WORD_GROUP2);
    insert_word("uint8_t", style::WORD_GROUP2);
    insert_word("uint_fast16_t", style::WORD_GROUP2);
    insert_word("uint_fast32_t", style::WORD_GROUP2);
    insert_word("uint_fast64_t", style::WORD_GROUP2);
    insert_word("uint_fast8_t", style::WORD_GROUP2);
    insert_word("uint_least16_t", style::WORD_GROUP2);
    insert_word("uint_least32_t", style::WORD_GROUP2);
    insert_word("uint_least64_t", style::WORD_GROUP2);
    insert_word("uint_least8_t", style::WORD_GROUP2);
    insert_word("uintmax_t", style::WORD_GROUP2);
    insert_word("uintptr_t", style::WORD_GROUP2);
    insert_word("unsigned", style::WORD_GROUP2);
    insert_word("va_list", style::WORD_GROUP2);
    insert_word("void", style::WORD_GROUP2);
    insert_word("wchar_t", style::WORD_GROUP2);
    insert_word("wint_t", style::WORD_GROUP2);
    insert_word("_Pragma", style::WORD_GROUP4);
    insert_word("__DATE__", style::WORD_GROUP4);
    insert_word("__FILE__", style::WORD_GROUP4);
    insert_word("__LINE__", style::WORD_GROUP4);
    insert_word("__TIMESTAMP__", style::WORD_GROUP4);
    insert_word("__TIME__", style::WORD_GROUP4);
    insert_word("__cplusplus", style::WORD_GROUP4);
    insert_word("__func__", style::WORD_GROUP4);
    insert_word("__has_cpp_attribute", style::WORD_GROUP4);
    insert_word("__has_include", style::WORD_GROUP4);
    insert_word("define", style::WORD_GROUP4);
    insert_word("defined", style::WORD_GROUP4);
    insert_word("elif", style::WORD_GROUP4);
    insert_word("elifdef", style::WORD_GROUP4);
    insert_word("elifndef", style::WORD_GROUP4);
    insert_word("endif", style::WORD_GROUP4);
    insert_word("error", style::WORD_GROUP4);
    insert_word("export", style::WORD_GROUP4);
    insert_word("ifdef", style::WORD_GROUP4);
    insert_word("ifndef", style::WORD_GROUP4);
    insert_word("import", style::WORD_GROUP4);
    insert_word("include", style::WORD_GROUP4);
    insert_word("module", style::WORD_GROUP4);
    insert_word("pragma", style::WORD_GROUP4);
    insert_word("typedef", style::WORD_GROUP4);
    insert_word("typeid", style::WORD_GROUP4);
    insert_word("typename", style::WORD_GROUP4);
    insert_word("undef", style::WORD_GROUP4);
    insert_word("alignas", style::WORD_GROUP8);
    insert_word("alignof", style::WORD_GROUP8);
    insert_word("co_await", style::WORD_GROUP8);
    insert_word("co_return", style::WORD_GROUP8);
    insert_word("co_yield", style::WORD_GROUP8);
    insert_word("const_cast", style::WORD_GROUP8);
    insert_word("consteval", style::WORD_GROUP8);
    insert_word("constexpr", style::WORD_GROUP8);
    insert_word("constinit", style::WORD_GROUP8);
    insert_word("decltype", style::WORD_GROUP8);
    insert_word("dynamic_cast", style::WORD_GROUP8);
    insert_word("reinterpret_cast", style::WORD_GROUP8);
    insert_word("static_assert", style::WORD_GROUP8);
    insert_word("static_cast", style::WORD_GROUP8);
    insert_word("thread_local", style::WORD_GROUP8);
    _custom.insert("for (int f = 0; f < 100; f++) {|}");
    _custom.insert("for (const auto& X ; Y) {|}");
    _custom.insert("/** @brief|*|* @param[in] xx  XXX.|*|* @return XXX.|*/");
    _custom.insert("/**|* @file|* @brief|*|* @author|* @copyright|*/");
    make_words();
}
StyleCS::StyleCS() : StyleDef(style::CS) {
    _line_comment      = "//";
    _line_comment_size = 2;
    _block_start       = "/*";
    _block_start_size  = 2;
    _block_end         = "*/";
    _block_end_size    = 2;
    _raw_start[0]      = "\"\"\"";
    _raw_start_size[0] = 3;
    _raw_end[0]        = "\"\"\"";
    _raw_end_size[0]   = 3;
    _hex               = true;
    _bin               = true;
    _tokens.set('_', Token::NUM_SEPARATOR);
    _tokens.set('#', Token::PRAGMA);
    insert_word("abstract", style::WORD_GROUP1);
    insert_word("and", style::WORD_GROUP1);
    insert_word("as", style::WORD_GROUP1);
    insert_word("async", style::WORD_GROUP1);
    insert_word("await", style::WORD_GROUP1);
    insert_word("base", style::WORD_GROUP1);
    insert_word("break", style::WORD_GROUP1);
    insert_word("case", style::WORD_GROUP1);
    insert_word("catch", style::WORD_GROUP1);
    insert_word("checked", style::WORD_GROUP1);
    insert_word("class", style::WORD_GROUP1);
    insert_word("continue", style::WORD_GROUP1);
    insert_word("default", style::WORD_GROUP1);
    insert_word("delegate", style::WORD_GROUP1);
    insert_word("do", style::WORD_GROUP1);
    insert_word("else", style::WORD_GROUP1);
    insert_word("enum", style::WORD_GROUP1);
    insert_word("event", style::WORD_GROUP1);
    insert_word("explicit", style::WORD_GROUP1);
    insert_word("extern", style::WORD_GROUP1);
    insert_word("finally", style::WORD_GROUP1);
    insert_word("fixed", style::WORD_GROUP1);
    insert_word("for", style::WORD_GROUP1);
    insert_word("foreach", style::WORD_GROUP1);
    insert_word("goto", style::WORD_GROUP1);
    insert_word("if", style::WORD_GROUP1);
    insert_word("implicit", style::WORD_GROUP1);
    insert_word("in", style::WORD_GROUP1);
    insert_word("int", style::WORD_GROUP1);
    insert_word("interface", style::WORD_GROUP1);
    insert_word("internal", style::WORD_GROUP1);
    insert_word("is", style::WORD_GROUP1);
    insert_word("lock", style::WORD_GROUP1);
    insert_word("long", style::WORD_GROUP1);
    insert_word("nameof", style::WORD_GROUP1);
    insert_word("namespace", style::WORD_GROUP1);
    insert_word("new", style::WORD_GROUP1);
    insert_word("not", style::WORD_GROUP1);
    insert_word("object", style::WORD_GROUP1);
    insert_word("operator", style::WORD_GROUP1);
    insert_word("or", style::WORD_GROUP1);
    insert_word("out", style::WORD_GROUP1);
    insert_word("override", style::WORD_GROUP1);
    insert_word("params", style::WORD_GROUP1);
    insert_word("private", style::WORD_GROUP1);
    insert_word("protected", style::WORD_GROUP1);
    insert_word("public", style::WORD_GROUP1);
    insert_word("readonly", style::WORD_GROUP1);
    insert_word("ref", style::WORD_GROUP1);
    insert_word("return", style::WORD_GROUP1);
    insert_word("sealed", style::WORD_GROUP1);
    insert_word("sizeof", style::WORD_GROUP1);
    insert_word("stackalloc", style::WORD_GROUP1);
    insert_word("static", style::WORD_GROUP1);
    insert_word("string", style::WORD_GROUP1);
    insert_word("struct", style::WORD_GROUP1);
    insert_word("switch", style::WORD_GROUP1);
    insert_word("this", style::WORD_GROUP1);
    insert_word("throw", style::WORD_GROUP1);
    insert_word("try", style::WORD_GROUP1);
    insert_word("typeof", style::WORD_GROUP1);
    insert_word("unchecked", style::WORD_GROUP1);
    insert_word("unsafe", style::WORD_GROUP1);
    insert_word("using", style::WORD_GROUP1);
    insert_word("var", style::WORD_GROUP1);
    insert_word("virtual", style::WORD_GROUP1);
    insert_word("void", style::WORD_GROUP1);
    insert_word("volatile", style::WORD_GROUP1);
    insert_word("while", style::WORD_GROUP1);
    insert_word("with", style::WORD_GROUP1);
    insert_word("yield", style::WORD_GROUP1);
    insert_word("bool", style::WORD_GROUP2);
    insert_word("byte", style::WORD_GROUP2);
    insert_word("char", style::WORD_GROUP2);
    insert_word("const", style::WORD_GROUP2);
    insert_word("decimal", style::WORD_GROUP2);
    insert_word("double", style::WORD_GROUP2);
    insert_word("false", style::WORD_GROUP2);
    insert_word("float", style::WORD_GROUP2);
    insert_word("nint", style::WORD_GROUP2);
    insert_word("nuint", style::WORD_GROUP2);
    insert_word("null", style::WORD_GROUP2);
    insert_word("sbyte", style::WORD_GROUP2);
    insert_word("short", style::WORD_GROUP2);
    insert_word("string", style::WORD_GROUP2);
    insert_word("true", style::WORD_GROUP2);
    insert_word("uint", style::WORD_GROUP2);
    insert_word("ulong", style::WORD_GROUP2);
    insert_word("ushort", style::WORD_GROUP2);
    insert_word("define", style::WORD_GROUP4);
    insert_word("elif", style::WORD_GROUP4);
    insert_word("endif", style::WORD_GROUP4);
    insert_word("endregion", style::WORD_GROUP4);
    insert_word("error", style::WORD_GROUP4);
    insert_word("line", style::WORD_GROUP4);
    insert_word("nullable", style::WORD_GROUP4);
    insert_word("pragma", style::WORD_GROUP4);
    insert_word("region", style::WORD_GROUP4);
    insert_word("warning", style::WORD_GROUP4);
    make_words();
}
StyleGo::StyleGo() : StyleDef(style::GO) {
    _line_comment      = "//";
    _line_comment_size = 2;
    _block_start       = "/*";
    _block_start_size  = 2;
    _block_end         = "*/";
    _block_end_size    = 2;
    _raw_start[0]      = "`";
    _raw_start_size[0] = 1;
    _raw_end[0]        = "`";
    _raw_end_size[0]   = 1;
    _hex               = true;
    _oct               = true;
    _bin               = true;
    _tokens.set('_', Token::NUM_SEPARATOR | Token::PUNCTUATOR);
    insert_word("break", style::WORD_GROUP1);
    insert_word("case", style::WORD_GROUP1);
    insert_word("chan", style::WORD_GROUP1);
    insert_word("continue", style::WORD_GROUP1);
    insert_word("default", style::WORD_GROUP1);
    insert_word("defer", style::WORD_GROUP1);
    insert_word("else", style::WORD_GROUP1);
    insert_word("fallthrough", style::WORD_GROUP1);
    insert_word("for", style::WORD_GROUP1);
    insert_word("go", style::WORD_GROUP1);
    insert_word("goto", style::WORD_GROUP1);
    insert_word("if", style::WORD_GROUP1);
    insert_word("interface", style::WORD_GROUP1);
    insert_word("map", style::WORD_GROUP1);
    insert_word("range", style::WORD_GROUP1);
    insert_word("return", style::WORD_GROUP1);
    insert_word("select", style::WORD_GROUP1);
    insert_word("struct", style::WORD_GROUP1);
    insert_word("switch", style::WORD_GROUP1);
    insert_word("bool", style::WORD_GROUP2);
    insert_word("byte", style::WORD_GROUP2);
    insert_word("complex128", style::WORD_GROUP2);
    insert_word("complex64", style::WORD_GROUP2);
    insert_word("false", style::WORD_GROUP2);
    insert_word("float32", style::WORD_GROUP2);
    insert_word("float64", style::WORD_GROUP2);
    insert_word("int", style::WORD_GROUP2);
    insert_word("int16", style::WORD_GROUP2);
    insert_word("int32", style::WORD_GROUP2);
    insert_word("int64", style::WORD_GROUP2);
    insert_word("int8", style::WORD_GROUP2);
    insert_word("iota", style::WORD_GROUP2);
    insert_word("nil", style::WORD_GROUP2);
    insert_word("rune", style::WORD_GROUP2);
    insert_word("string", style::WORD_GROUP2);
    insert_word("true", style::WORD_GROUP2);
    insert_word("uint", style::WORD_GROUP2);
    insert_word("uint16", style::WORD_GROUP2);
    insert_word("uint32", style::WORD_GROUP2);
    insert_word("uint64", style::WORD_GROUP2);
    insert_word("uint8", style::WORD_GROUP2);
    insert_word("uintptr", style::WORD_GROUP2);
    insert_word("const", style::WORD_GROUP4);
    insert_word("func", style::WORD_GROUP4);
    insert_word("import", style::WORD_GROUP4);
    insert_word("package", style::WORD_GROUP4);
    insert_word("type", style::WORD_GROUP4);
    insert_word("var", style::WORD_GROUP4);
    insert_word("append", style::WORD_GROUP8);
    insert_word("cap", style::WORD_GROUP8);
    insert_word("clear", style::WORD_GROUP8);
    insert_word("close", style::WORD_GROUP8);
    insert_word("complex", style::WORD_GROUP8);
    insert_word("copy", style::WORD_GROUP8);
    insert_word("delete", style::WORD_GROUP8);
    insert_word("imag", style::WORD_GROUP8);
    insert_word("len", style::WORD_GROUP8);
    insert_word("make", style::WORD_GROUP8);
    insert_word("max", style::WORD_GROUP8);
    insert_word("min", style::WORD_GROUP8);
    insert_word("new", style::WORD_GROUP8);
    insert_word("panic", style::WORD_GROUP8);
    insert_word("print", style::WORD_GROUP8);
    insert_word("println", style::WORD_GROUP8);
    insert_word("real", style::WORD_GROUP8);
    insert_word("recover", style::WORD_GROUP8);
    _custom.insert("err := something()|if err != nil {|    log.Fatal(err)|}");
    make_words();
}
StyleJava::StyleJava() : StyleDef(style::JAVA) {
    _line_comment      = "//";
    _line_comment_size = 2;
    _block_start       = "/*";
    _block_start_size  = 2;
    _block_end         = "*/";
    _block_end_size    = 2;
    _raw_start[0]      = "\"\"\"";
    _raw_start_size[0] = 3;
    _raw_end[0]        = "\"\"\"";
    _raw_end_size[0]   = 3;
    _hex               = true;
    _bin               = true;
    _tokens.set('@', Token::PRAGMA);
    insert_word("abstract", style::WORD_GROUP1);
    insert_word("assert", style::WORD_GROUP1);
    insert_word("break", style::WORD_GROUP1);
    insert_word("case", style::WORD_GROUP1);
    insert_word("catch", style::WORD_GROUP1);
    insert_word("class", style::WORD_GROUP1);
    insert_word("continue", style::WORD_GROUP1);
    insert_word("default", style::WORD_GROUP1);
    insert_word("do", style::WORD_GROUP1);
    insert_word("else", style::WORD_GROUP1);
    insert_word("enum", style::WORD_GROUP1);
    insert_word("extends", style::WORD_GROUP1);
    insert_word("false", style::WORD_GROUP1);
    insert_word("finally", style::WORD_GROUP1);
    insert_word("for", style::WORD_GROUP1);
    insert_word("goto", style::WORD_GROUP1);
    insert_word("if", style::WORD_GROUP1);
    insert_word("implements", style::WORD_GROUP1);
    insert_word("instanceof", style::WORD_GROUP1);
    insert_word("interface", style::WORD_GROUP1);
    insert_word("native", style::WORD_GROUP1);
    insert_word("new", style::WORD_GROUP1);
    insert_word("non-sealed", style::WORD_GROUP1);
    insert_word("null", style::WORD_GROUP1);
    insert_word("permits", style::WORD_GROUP1);
    insert_word("private", style::WORD_GROUP1);
    insert_word("protected", style::WORD_GROUP1);
    insert_word("public", style::WORD_GROUP1);
    insert_word("record", style::WORD_GROUP1);
    insert_word("return", style::WORD_GROUP1);
    insert_word("sealed", style::WORD_GROUP1);
    insert_word("strictfp", style::WORD_GROUP1);
    insert_word("super", style::WORD_GROUP1);
    insert_word("switch", style::WORD_GROUP1);
    insert_word("synchronized", style::WORD_GROUP1);
    insert_word("this", style::WORD_GROUP1);
    insert_word("throw", style::WORD_GROUP1);
    insert_word("throws", style::WORD_GROUP1);
    insert_word("transient", style::WORD_GROUP1);
    insert_word("true", style::WORD_GROUP1);
    insert_word("try", style::WORD_GROUP1);
    insert_word("volatile", style::WORD_GROUP1);
    insert_word("while", style::WORD_GROUP1);
    insert_word("yield", style::WORD_GROUP1);
    insert_word("Iterator", style::WORD_GROUP2);
    insert_word("ArrayList", style::WORD_GROUP2);
    insert_word("AtomicInteger", style::WORD_GROUP2);
    insert_word("AtomicLong", style::WORD_GROUP2);
    insert_word("BigDecimal", style::WORD_GROUP2);
    insert_word("BigInteger", style::WORD_GROUP2);
    insert_word("Byte", style::WORD_GROUP2);
    insert_word("Double", style::WORD_GROUP2);
    insert_word("DoubleAccumulator", style::WORD_GROUP2);
    insert_word("DoubleAdder", style::WORD_GROUP2);
    insert_word("Float", style::WORD_GROUP2);
    insert_word("HashMap", style::WORD_GROUP2);
    insert_word("HashSet", style::WORD_GROUP2);
    insert_word("Integer", style::WORD_GROUP2);
    insert_word("LinkedList", style::WORD_GROUP2);
    insert_word("LocalDate", style::WORD_GROUP2);
    insert_word("Long", style::WORD_GROUP2);
    insert_word("LongAccumulator", style::WORD_GROUP2);
    insert_word("LongAdder", style::WORD_GROUP2);
    insert_word("Matcher", style::WORD_GROUP2);
    insert_word("Pattern", style::WORD_GROUP2);
    insert_word("Short", style::WORD_GROUP2);
    insert_word("String", style::WORD_GROUP2);
    insert_word("Thread", style::WORD_GROUP2);
    insert_word("boolean", style::WORD_GROUP2);
    insert_word("byte", style::WORD_GROUP2);
    insert_word("char", style::WORD_GROUP2);
    insert_word("const", style::WORD_GROUP2);
    insert_word("double", style::WORD_GROUP2);
    insert_word("final", style::WORD_GROUP2);
    insert_word("float", style::WORD_GROUP2);
    insert_word("int", style::WORD_GROUP2);
    insert_word("long", style::WORD_GROUP2);
    insert_word("short", style::WORD_GROUP2);
    insert_word("static", style::WORD_GROUP2);
    insert_word("var", style::WORD_GROUP2);
    insert_word("void", style::WORD_GROUP2);
    insert_word("Deprecated", style::WORD_GROUP4);
    insert_word("Documented", style::WORD_GROUP4);
    insert_word("FunctionalInterface", style::WORD_GROUP4);
    insert_word("Inherited", style::WORD_GROUP4);
    insert_word("Override", style::WORD_GROUP4);
    insert_word("Repeatable", style::WORD_GROUP4);
    insert_word("Retention", style::WORD_GROUP4);
    insert_word("SafeVarargs", style::WORD_GROUP4);
    insert_word("SuppressWarnings", style::WORD_GROUP4);
    insert_word("Target", style::WORD_GROUP4);
    insert_word("import", style::WORD_GROUP4);
    insert_word("package", style::WORD_GROUP4);
    make_words();
}
StyleJS::StyleJS(const std::string& name) : StyleDef(name) {
    _single_quote_str  = '\'';
    _line_comment      = "//";
    _line_comment_size = 2;
    _block_start       = "/*";
    _block_start_size  = 2;
    _block_end         = "*/";
    _block_end_size    = 2;
    _raw_start[0]      = "`";
    _raw_start_size[0] = 1;
    _raw_end[0]        = "`";
    _raw_end_size[0]   = 1;
    _raw_escape[0]     = true;
    _hex               = true;
    _bin               = true;
    insert_word("arguments", style::WORD_GROUP1);
    insert_word("async", style::WORD_GROUP1);
    insert_word("await", style::WORD_GROUP1);
    insert_word("break", style::WORD_GROUP1);
    insert_word("case", style::WORD_GROUP1);
    insert_word("catch", style::WORD_GROUP1);
    insert_word("class", style::WORD_GROUP1);
    insert_word("const", style::WORD_GROUP1);
    insert_word("continue", style::WORD_GROUP1);
    insert_word("debugger", style::WORD_GROUP1);
    insert_word("delete", style::WORD_GROUP1);
    insert_word("do", style::WORD_GROUP1);
    insert_word("else", style::WORD_GROUP1);
    insert_word("extends", style::WORD_GROUP1);
    insert_word("finally", style::WORD_GROUP1);
    insert_word("for", style::WORD_GROUP1);
    insert_word("function", style::WORD_GROUP1);
    insert_word("get", style::WORD_GROUP1);
    insert_word("if", style::WORD_GROUP1);
    insert_word("implements", style::WORD_GROUP1);
    insert_word("in", style::WORD_GROUP1);
    insert_word("instanceof", style::WORD_GROUP1);
    insert_word("interface", style::WORD_GROUP1);
    insert_word("let", style::WORD_GROUP1);
    insert_word("new", style::WORD_GROUP1);
    insert_word("of", style::WORD_GROUP1);
    insert_word("private", style::WORD_GROUP1);
    insert_word("protected", style::WORD_GROUP1);
    insert_word("public", style::WORD_GROUP1);
    insert_word("reject", style::WORD_GROUP1);
    insert_word("resolve", style::WORD_GROUP1);
    insert_word("return", style::WORD_GROUP1);
    insert_word("set", style::WORD_GROUP1);
    insert_word("static", style::WORD_GROUP1);
    insert_word("super", style::WORD_GROUP1);
    insert_word("switch", style::WORD_GROUP1);
    insert_word("this", style::WORD_GROUP1);
    insert_word("throw", style::WORD_GROUP1);
    insert_word("try", style::WORD_GROUP1);
    insert_word("typeof", style::WORD_GROUP1);
    insert_word("var", style::WORD_GROUP1);
    insert_word("void", style::WORD_GROUP1);
    insert_word("while", style::WORD_GROUP1);
    insert_word("with", style::WORD_GROUP1);
    insert_word("yield", style::WORD_GROUP1);
    insert_word("Array", style::WORD_GROUP2);
    insert_word("BigInt64Array", style::WORD_GROUP2);
    insert_word("BigUint64Array", style::WORD_GROUP2);
    insert_word("Boolean", style::WORD_GROUP2);
    insert_word("Date", style::WORD_GROUP2);
    insert_word("Enumerator", style::WORD_GROUP2);
    insert_word("Error", style::WORD_GROUP2);
    insert_word("Float32Array", style::WORD_GROUP2);
    insert_word("Float64Array", style::WORD_GROUP2);
    insert_word("Function", style::WORD_GROUP2);
    insert_word("Generator", style::WORD_GROUP2);
    insert_word("Infinity", style::WORD_GROUP2);
    insert_word("Int16Array", style::WORD_GROUP2);
    insert_word("Map", style::WORD_GROUP2);
    insert_word("Math", style::WORD_GROUP2);
    insert_word("NaN", style::WORD_GROUP2);
    insert_word("Number", style::WORD_GROUP2);
    insert_word("Object", style::WORD_GROUP2);
    insert_word("Promise", style::WORD_GROUP2);
    insert_word("Proxy", style::WORD_GROUP2);
    insert_word("Reflect", style::WORD_GROUP2);
    insert_word("RegExp", style::WORD_GROUP2);
    insert_word("Set", style::WORD_GROUP2);
    insert_word("String", style::WORD_GROUP2);
    insert_word("Symbol", style::WORD_GROUP2);
    insert_word("WeakMap", style::WORD_GROUP2);
    insert_word("WeakSet", style::WORD_GROUP2);
    insert_word("enum", style::WORD_GROUP2);
    insert_word("false", style::WORD_GROUP2);
    insert_word("globalThis", style::WORD_GROUP2);
    insert_word("null", style::WORD_GROUP2);
    insert_word("true", style::WORD_GROUP2);
    insert_word("undefined", style::WORD_GROUP2);
    insert_word("as", style::WORD_GROUP4);
    insert_word("default", style::WORD_GROUP4);
    insert_word("export", style::WORD_GROUP4);
    insert_word("from", style::WORD_GROUP4);
    insert_word("import", style::WORD_GROUP4);
    insert_word("package", style::WORD_GROUP4);
    make_words();
}
StyleKotlin::StyleKotlin() : StyleDef(style::KOTLIN) {
    _line_comment      = "//";
    _line_comment_size = 2;
    _block_start       = "/*";
    _block_start_size  = 2;
    _block_end         = "*/";
    _block_end_size    = 2;
    _raw_start[0]      = "\"\"\"";
    _raw_start_size[0] = 3;
    _raw_end[0]        = "\"\"\"";
    _raw_end_size[0]   = 3;
    _hex               = true;
    _bin               = true;
    _tokens.set('@', Token::PRAGMA);
    insert_word("abstract", style::WORD_GROUP1);
    insert_word("actual", style::WORD_GROUP1);
    insert_word("annotation", style::WORD_GROUP1);
    insert_word("as", style::WORD_GROUP1);
    insert_word("as?", style::WORD_GROUP1);
    insert_word("break", style::WORD_GROUP1);
    insert_word("by", style::WORD_GROUP1);
    insert_word("catch", style::WORD_GROUP1);
    insert_word("class", style::WORD_GROUP1);
    insert_word("companion", style::WORD_GROUP1);
    insert_word("const", style::WORD_GROUP1);
    insert_word("constructor", style::WORD_GROUP1);
    insert_word("continue", style::WORD_GROUP1);
    insert_word("crossinline", style::WORD_GROUP1);
    insert_word("data", style::WORD_GROUP1);
    insert_word("delegate", style::WORD_GROUP1);
    insert_word("do", style::WORD_GROUP1);
    insert_word("dynamic", style::WORD_GROUP1);
    insert_word("else", style::WORD_GROUP1);
    insert_word("enum", style::WORD_GROUP1);
    insert_word("expect", style::WORD_GROUP1);
    insert_word("external", style::WORD_GROUP1);
    insert_word("field", style::WORD_GROUP1);
    insert_word("file", style::WORD_GROUP1);
    insert_word("final", style::WORD_GROUP1);
    insert_word("finally", style::WORD_GROUP1);
    insert_word("for", style::WORD_GROUP1);
    insert_word("fun", style::WORD_GROUP1);
    insert_word("get", style::WORD_GROUP1);
    insert_word("if", style::WORD_GROUP1);
    insert_word("in", style::WORD_GROUP1);
    insert_word("infix", style::WORD_GROUP1);
    insert_word("init", style::WORD_GROUP1);
    insert_word("inline", style::WORD_GROUP1);
    insert_word("inner", style::WORD_GROUP1);
    insert_word("interface", style::WORD_GROUP1);
    insert_word("internal", style::WORD_GROUP1);
    insert_word("is", style::WORD_GROUP1);
    insert_word("lateinit", style::WORD_GROUP1);
    insert_word("noinline", style::WORD_GROUP1);
    insert_word("object", style::WORD_GROUP1);
    insert_word("open", style::WORD_GROUP1);
    insert_word("operator", style::WORD_GROUP1);
    insert_word("out", style::WORD_GROUP1);
    insert_word("override", style::WORD_GROUP1);
    insert_word("param", style::WORD_GROUP1);
    insert_word("private", style::WORD_GROUP1);
    insert_word("property", style::WORD_GROUP1);
    insert_word("protected", style::WORD_GROUP1);
    insert_word("public", style::WORD_GROUP1);
    insert_word("receiver", style::WORD_GROUP1);
    insert_word("reified", style::WORD_GROUP1);
    insert_word("return", style::WORD_GROUP1);
    insert_word("sealed", style::WORD_GROUP1);
    insert_word("set", style::WORD_GROUP1);
    insert_word("setparam", style::WORD_GROUP1);
    insert_word("super", style::WORD_GROUP1);
    insert_word("suspend", style::WORD_GROUP1);
    insert_word("tailrec", style::WORD_GROUP1);
    insert_word("this", style::WORD_GROUP1);
    insert_word("throw", style::WORD_GROUP1);
    insert_word("try", style::WORD_GROUP1);
    insert_word("typealias", style::WORD_GROUP1);
    insert_word("typeof", style::WORD_GROUP1);
    insert_word("val", style::WORD_GROUP1);
    insert_word("value", style::WORD_GROUP1);
    insert_word("var", style::WORD_GROUP1);
    insert_word("vararg", style::WORD_GROUP1);
    insert_word("when", style::WORD_GROUP1);
    insert_word("where", style::WORD_GROUP1);
    insert_word("while", style::WORD_GROUP1);
    insert_word("Any", style::WORD_GROUP2);
    insert_word("Array", style::WORD_GROUP2);
    insert_word("ArrayList", style::WORD_GROUP2);
    insert_word("Boolean", style::WORD_GROUP2);
    insert_word("BooleanArrray", style::WORD_GROUP2);
    insert_word("Byte", style::WORD_GROUP2);
    insert_word("ByteArray", style::WORD_GROUP2);
    insert_word("Char", style::WORD_GROUP2);
    insert_word("CharArray", style::WORD_GROUP2);
    insert_word("Double", style::WORD_GROUP2);
    insert_word("DoubleArray", style::WORD_GROUP2);
    insert_word("Enum", style::WORD_GROUP2);
    insert_word("Float", style::WORD_GROUP2);
    insert_word("FloatArray", style::WORD_GROUP2);
    insert_word("Function", style::WORD_GROUP2);
    insert_word("HashMap", style::WORD_GROUP2);
    insert_word("HashSet", style::WORD_GROUP2);
    insert_word("Int", style::WORD_GROUP2);
    insert_word("IntArray", style::WORD_GROUP2);
    insert_word("LinkedList", style::WORD_GROUP2);
    insert_word("List", style::WORD_GROUP2);
    insert_word("LocalDate", style::WORD_GROUP2);
    insert_word("Long", style::WORD_GROUP2);
    insert_word("LongArray", style::WORD_GROUP2);
    insert_word("Map", style::WORD_GROUP2);
    insert_word("Matcher", style::WORD_GROUP2);
    insert_word("Nothing", style::WORD_GROUP2);
    insert_word("Pattern", style::WORD_GROUP2);
    insert_word("Set", style::WORD_GROUP2);
    insert_word("Short", style::WORD_GROUP2);
    insert_word("ShortArray", style::WORD_GROUP2);
    insert_word("String", style::WORD_GROUP2);
    insert_word("Thread", style::WORD_GROUP2);
    insert_word("Unit", style::WORD_GROUP2);
    insert_word("false", style::WORD_GROUP2);
    insert_word("null", style::WORD_GROUP2);
    insert_word("true", style::WORD_GROUP2);
    insert_word("Deprecated", style::WORD_GROUP4);
    insert_word("Documented", style::WORD_GROUP4);
    insert_word("FunctionalInterface", style::WORD_GROUP4);
    insert_word("Inherited", style::WORD_GROUP4);
    insert_word("Override", style::WORD_GROUP4);
    insert_word("Repeatable", style::WORD_GROUP4);
    insert_word("Retention", style::WORD_GROUP4);
    insert_word("SafeVarargs", style::WORD_GROUP4);
    insert_word("Strictfp", style::WORD_GROUP4);
    insert_word("SuppressWarnings", style::WORD_GROUP4);
    insert_word("Synchronized", style::WORD_GROUP4);
    insert_word("Target", style::WORD_GROUP4);
    insert_word("Throwable", style::WORD_GROUP4);
    insert_word("Throws", style::WORD_GROUP4);
    insert_word("Transient", style::WORD_GROUP4);
    insert_word("Volatile", style::WORD_GROUP4);
    insert_word("import", style::WORD_GROUP4);
    insert_word("package", style::WORD_GROUP4);
    insert_word("arrayListOf", style::WORD_GROUP8);
    insert_word("compareTo", style::WORD_GROUP8);
    insert_word("equals", style::WORD_GROUP8);
    insert_word("hashCode", style::WORD_GROUP8);
    insert_word("hashMapOf", style::WORD_GROUP8);
    insert_word("hashSetOf", style::WORD_GROUP8);
    insert_word("listOf", style::WORD_GROUP8);
    insert_word("mapOf", style::WORD_GROUP8);
    insert_word("mutableListOf", style::WORD_GROUP8);
    insert_word("mutableMapOf", style::WORD_GROUP8);
    insert_word("mutableSetOf", style::WORD_GROUP8);
    insert_word("println", style::WORD_GROUP8);
    insert_word("setOf", style::WORD_GROUP8);
    insert_word("toString", style::WORD_GROUP8);
}
StyleLua::StyleLua() : StyleDef(style::LUA) {
    _single_quote_str  = '\'';
    _line_comment      = "--";
    _line_comment_size = 2;
    _block_start       = "--[[";
    _block_start_size  = 4;
    _block_end         = "]]";
    _block_end_size    = 2;
    _raw_start[0]      = "[[";
    _raw_start_size[0] = 2;
    _raw_end[0]        = "]]";
    _raw_end_size[0]   = 2;
    _hex               = true;
    insert_word("and", style::WORD_GROUP1);
    insert_word("assert", style::WORD_GROUP1);
    insert_word("break", style::WORD_GROUP1);
    insert_word("collectgarbage", style::WORD_GROUP1);
    insert_word("defer", style::WORD_GROUP1);
    insert_word("do", style::WORD_GROUP1);
    insert_word("dofile", style::WORD_GROUP1);
    insert_word("else", style::WORD_GROUP1);
    insert_word("elseif", style::WORD_GROUP1);
    insert_word("end", style::WORD_GROUP1);
    insert_word("error", style::WORD_GROUP1);
    insert_word("for", style::WORD_GROUP1);
    insert_word("function", style::WORD_GROUP1);
    insert_word("getmetatable", style::WORD_GROUP1);
    insert_word("goto", style::WORD_GROUP1);
    insert_word("if", style::WORD_GROUP1);
    insert_word("in", style::WORD_GROUP1);
    insert_word("ipairs", style::WORD_GROUP1);
    insert_word("load", style::WORD_GROUP1);
    insert_word("loadfile", style::WORD_GROUP1);
    insert_word("local", style::WORD_GROUP1);
    insert_word("next", style::WORD_GROUP1);
    insert_word("not", style::WORD_GROUP1);
    insert_word("or", style::WORD_GROUP1);
    insert_word("pairs", style::WORD_GROUP1);
    insert_word("pcall", style::WORD_GROUP1);
    insert_word("print", style::WORD_GROUP1);
    insert_word("rawequal", style::WORD_GROUP1);
    insert_word("rawget", style::WORD_GROUP1);
    insert_word("rawlen", style::WORD_GROUP1);
    insert_word("rawset", style::WORD_GROUP1);
    insert_word("repeat", style::WORD_GROUP1);
    insert_word("return", style::WORD_GROUP1);
    insert_word("select", style::WORD_GROUP1);
    insert_word("setmetatable", style::WORD_GROUP1);
    insert_word("then", style::WORD_GROUP1);
    insert_word("tonumber", style::WORD_GROUP1);
    insert_word("tostring", style::WORD_GROUP1);
    insert_word("type", style::WORD_GROUP1);
    insert_word("until", style::WORD_GROUP1);
    insert_word("while", style::WORD_GROUP1);
    insert_word("xpcall", style::WORD_GROUP1);
    insert_word("coroutine", style::WORD_GROUP2);
    insert_word("debug", style::WORD_GROUP2);
    insert_word("false", style::WORD_GROUP2);
    insert_word("file", style::WORD_GROUP2);
    insert_word("io", style::WORD_GROUP2);
    insert_word("math", style::WORD_GROUP2);
    insert_word("nil", style::WORD_GROUP2);
    insert_word("os", style::WORD_GROUP2);
    insert_word("string", style::WORD_GROUP2);
    insert_word("table", style::WORD_GROUP2);
    insert_word("true", style::WORD_GROUP2);
    insert_word("require", style::WORD_GROUP4);
    _custom.insert("for f = 1, 100 do|end");
    _custom.insert("for index, value in ipairs(t) do|end");
    _custom.insert("for key, value in pairs(t) do|end");
    make_words();
}
StyleMakefile::StyleMakefile() : StyleDef(style::MAKEFILE) {
    _single_quote_str  = '\'';
    _line_comment      = "#";
    _line_comment_size = 1;
    _raw_start[0]      = "";
    _raw_start_size[0] = 0;
    _raw_end[0]        = "";
    _raw_end_size[0]   = 0;
    _tokens.set('$', Token::VALUE | Token::PUNCTUATOR);
    insert_word("cd", style::WORD_GROUP1);
    insert_word("chmod", style::WORD_GROUP1);
    insert_word("define", style::WORD_GROUP1);
    insert_word("done", style::WORD_GROUP1);
    insert_word("else", style::WORD_GROUP1);
    insert_word("endef", style::WORD_GROUP1);
    insert_word("endif", style::WORD_GROUP1);
    insert_word("fi", style::WORD_GROUP1);
    insert_word("for", style::WORD_GROUP1);
    insert_word("if", style::WORD_GROUP1);
    insert_word("ifdef", style::WORD_GROUP1);
    insert_word("ifeq", style::WORD_GROUP1);
    insert_word("ifndef", style::WORD_GROUP1);
    insert_word("ifneq", style::WORD_GROUP1);
    insert_word("touch", style::WORD_GROUP1);
    insert_word("undefine", style::WORD_GROUP1);
    insert_word("CURDIR", style::WORD_GROUP2);
    insert_word("DEFAULT", style::WORD_GROUP2);
    insert_word("DELETE_ON_ERROR", style::WORD_GROUP2);
    insert_word("EXPORT_ALL_VARIABLES", style::WORD_GROUP2);
    insert_word("GNUMAKEFLAGS", style::WORD_GROUP2);
    insert_word("IGNORE", style::WORD_GROUP2);
    insert_word("INTERMEDIATE", style::WORD_GROUP2);
    insert_word("LOWORD_RESOLUTION_TIME", style::WORD_GROUP2);
    insert_word("MAKE", style::WORD_GROUP2);
    insert_word("MAKECMDGOALS", style::WORD_GROUP2);
    insert_word("MAKEFILES", style::WORD_GROUP2);
    insert_word("MAKEFLAGS", style::WORD_GROUP2);
    insert_word("MAKELEVEL", style::WORD_GROUP2);
    insert_word("MAKE_HOST", style::WORD_GROUP2);
    insert_word("MAKE_VERSION", style::WORD_GROUP2);
    insert_word("NOTPARALLEL", style::WORD_GROUP2);
    insert_word("ONESHELL", style::WORD_GROUP2);
    insert_word("PHONY", style::WORD_GROUP2);
    insert_word("POSIX", style::WORD_GROUP2);
    insert_word("PRECIOUS", style::WORD_GROUP2);
    insert_word("SECONDARY", style::WORD_GROUP2);
    insert_word("SECONDEXPANSION", style::WORD_GROUP2);
    insert_word("SHELL", style::WORD_GROUP2);
    insert_word("SILENT", style::WORD_GROUP2);
    insert_word("SUFFIXES", style::WORD_GROUP2);
    insert_word("VPATH", style::WORD_GROUP2);
    insert_word("all", style::WORD_GROUP4);
    insert_word("clean", style::WORD_GROUP4);
    insert_word("depend", style::WORD_GROUP4);
    insert_word("distclean", style::WORD_GROUP4);
    insert_word("export", style::WORD_GROUP4);
    insert_word("include", style::WORD_GROUP4);
    insert_word("install", style::WORD_GROUP4);
    insert_word("makeinclude", style::WORD_GROUP4);
    insert_word("private", style::WORD_GROUP4);
    insert_word("unexport", style::WORD_GROUP4);
    insert_word("uninstall", style::WORD_GROUP4);
    insert_word("vpath", style::WORD_GROUP4);
    make_words();
}
StylePHP::StylePHP() : StyleDef(style::PHP) {
    _single_quote_str  = '\'';
    _line_comment      = "//";
    _line_comment_size = 2;
    _block_start       = "/*";
    _block_start_size  = 2;
    _block_end         = "*/";
    _block_end_size    = 2;
    _raw_start[0]      = "<<HEREDOC";
    _raw_start_size[0] = 9;
    _raw_end[0]        = "HEREDOC";
    _raw_end_size[0]   = 7;
    _raw_start[0]      = "<<END";
    _raw_start_size[0] = 5;
    _raw_end[0]        = "END";
    _raw_end_size[0]   = 3;
    _hex               = true;
    _bin               = true;
    _oct               = true;
    _tokens.set('$', Token::VALUE);
    insert_word("__halt_compiler", style::WORD_GROUP1);
    insert_word("abstract", style::WORD_GROUP1);
    insert_word("and", style::WORD_GROUP1);
    insert_word("array", style::WORD_GROUP1);
    insert_word("as", style::WORD_GROUP1);
    insert_word("break", style::WORD_GROUP1);
    insert_word("callable", style::WORD_GROUP1);
    insert_word("case", style::WORD_GROUP1);
    insert_word("catch", style::WORD_GROUP1);
    insert_word("class", style::WORD_GROUP1);
    insert_word("clone", style::WORD_GROUP1);
    insert_word("const", style::WORD_GROUP1);
    insert_word("continue", style::WORD_GROUP1);
    insert_word("declare", style::WORD_GROUP1);
    insert_word("default", style::WORD_GROUP1);
    insert_word("die", style::WORD_GROUP1);
    insert_word("do", style::WORD_GROUP1);
    insert_word("echo", style::WORD_GROUP1);
    insert_word("else", style::WORD_GROUP1);
    insert_word("elseif", style::WORD_GROUP1);
    insert_word("empty", style::WORD_GROUP1);
    insert_word("enddeclare", style::WORD_GROUP1);
    insert_word("endfor", style::WORD_GROUP1);
    insert_word("endforeach", style::WORD_GROUP1);
    insert_word("endif", style::WORD_GROUP1);
    insert_word("endswitch", style::WORD_GROUP1);
    insert_word("endwhile", style::WORD_GROUP1);
    insert_word("eval", style::WORD_GROUP1);
    insert_word("exit", style::WORD_GROUP1);
    insert_word("extends", style::WORD_GROUP1);
    insert_word("final", style::WORD_GROUP1);
    insert_word("finally", style::WORD_GROUP1);
    insert_word("fn", style::WORD_GROUP1);
    insert_word("for", style::WORD_GROUP1);
    insert_word("foreach", style::WORD_GROUP1);
    insert_word("from", style::WORD_GROUP1);
    insert_word("function", style::WORD_GROUP1);
    insert_word("global", style::WORD_GROUP1);
    insert_word("goto", style::WORD_GROUP1);
    insert_word("if", style::WORD_GROUP1);
    insert_word("implements", style::WORD_GROUP1);
    insert_word("include", style::WORD_GROUP1);
    insert_word("include_once", style::WORD_GROUP1);
    insert_word("instanceof", style::WORD_GROUP1);
    insert_word("insteadof", style::WORD_GROUP1);
    insert_word("interface", style::WORD_GROUP1);
    insert_word("isset", style::WORD_GROUP1);
    insert_word("list", style::WORD_GROUP1);
    insert_word("match", style::WORD_GROUP1);
    insert_word("namespace", style::WORD_GROUP1);
    insert_word("new", style::WORD_GROUP1);
    insert_word("or", style::WORD_GROUP1);
    insert_word("print", style::WORD_GROUP1);
    insert_word("private", style::WORD_GROUP1);
    insert_word("protected", style::WORD_GROUP1);
    insert_word("public", style::WORD_GROUP1);
    insert_word("readonly", style::WORD_GROUP1);
    insert_word("require", style::WORD_GROUP1);
    insert_word("require_once", style::WORD_GROUP1);
    insert_word("return", style::WORD_GROUP1);
    insert_word("static", style::WORD_GROUP1);
    insert_word("switch", style::WORD_GROUP1);
    insert_word("throw", style::WORD_GROUP1);
    insert_word("trait", style::WORD_GROUP1);
    insert_word("try", style::WORD_GROUP1);
    insert_word("unset", style::WORD_GROUP1);
    insert_word("use", style::WORD_GROUP1);
    insert_word("var", style::WORD_GROUP1);
    insert_word("while", style::WORD_GROUP1);
    insert_word("xor", style::WORD_GROUP1);
    insert_word("yield", style::WORD_GROUP1);
    insert_word("FALSE", style::WORD_GROUP2);
    insert_word("NAN", style::WORD_GROUP2);
    insert_word("NULL", style::WORD_GROUP2);
    insert_word("PHP_FLOAT_MAX", style::WORD_GROUP2);
    insert_word("PHP_INT_MAX", style::WORD_GROUP2);
    insert_word("PHP_INT_MIN", style::WORD_GROUP2);
    insert_word("PHP_INT_SIZE", style::WORD_GROUP2);
    insert_word("TRUE", style::WORD_GROUP2);
    insert_word("bool", style::WORD_GROUP2);
    insert_word("false", style::WORD_GROUP2);
    insert_word("float", style::WORD_GROUP2);
    insert_word("int", style::WORD_GROUP2);
    insert_word("null", style::WORD_GROUP2);
    insert_word("object", style::WORD_GROUP2);
    insert_word("string", style::WORD_GROUP2);
    insert_word("true", style::WORD_GROUP2);
    insert_word("__CLASS__", style::WORD_GROUP4);
    insert_word("__DIR__", style::WORD_GROUP4);
    insert_word("__FILE__", style::WORD_GROUP4);
    insert_word("__FUNCTION__", style::WORD_GROUP4);
    insert_word("__LINE__", style::WORD_GROUP4);
    insert_word("__METHOD__", style::WORD_GROUP4);
    insert_word("__NAMESPACE__", style::WORD_GROUP4);
    insert_word("__TRAIT__", style::WORD_GROUP4);
    make_words();
}
StylePython::StylePython() : StyleDef(style::PYTHON) {
    _single_quote_str  = '\'';
    _line_comment      = "#";
    _line_comment_size = 1;
    _block_start       = "'''";
    _block_start_size  = 3;
    _block_end         = "'''";
    _block_end_size    = 3;
    _raw_start[0]      = "\"\"\"";
    _raw_start_size[0] = 3;
    _raw_end[0]        = "\"\"\"";
    _raw_end_size[0]   = 3;
    _raw_start[1]      = "'''";
    _raw_start_size[1] = 3;
    _raw_end[1]        = "'''";
    _raw_end_size[1]   = 3;
    insert_word("and", style::WORD_GROUP1);
    insert_word("as", style::WORD_GROUP1);
    insert_word("assert", style::WORD_GROUP1);
    insert_word("async", style::WORD_GROUP1);
    insert_word("await", style::WORD_GROUP1);
    insert_word("break", style::WORD_GROUP1);
    insert_word("class", style::WORD_GROUP1);
    insert_word("continue", style::WORD_GROUP1);
    insert_word("def", style::WORD_GROUP1);
    insert_word("del", style::WORD_GROUP1);
    insert_word("elif", style::WORD_GROUP1);
    insert_word("else", style::WORD_GROUP1);
    insert_word("except", style::WORD_GROUP1);
    insert_word("finally", style::WORD_GROUP1);
    insert_word("for", style::WORD_GROUP1);
    insert_word("from", style::WORD_GROUP1);
    insert_word("global", style::WORD_GROUP1);
    insert_word("if", style::WORD_GROUP1);
    insert_word("import", style::WORD_GROUP1);
    insert_word("in", style::WORD_GROUP1);
    insert_word("is", style::WORD_GROUP1);
    insert_word("lambda", style::WORD_GROUP1);
    insert_word("nonlocal", style::WORD_GROUP1);
    insert_word("not", style::WORD_GROUP1);
    insert_word("or", style::WORD_GROUP1);
    insert_word("pass", style::WORD_GROUP1);
    insert_word("raise", style::WORD_GROUP1);
    insert_word("return", style::WORD_GROUP1);
    insert_word("try", style::WORD_GROUP1);
    insert_word("while", style::WORD_GROUP1);
    insert_word("with", style::WORD_GROUP1);
    insert_word("yield", style::WORD_GROUP1);
    insert_word("Ellipsis", style::WORD_GROUP2);
    insert_word("False", style::WORD_GROUP2);
    insert_word("None", style::WORD_GROUP2);
    insert_word("True", style::WORD_GROUP2);
    insert_word("bool", style::WORD_GROUP2);
    insert_word("bytearray", style::WORD_GROUP2);
    insert_word("bytes", style::WORD_GROUP2);
    insert_word("classmethod", style::WORD_GROUP2);
    insert_word("cls", style::WORD_GROUP2);
    insert_word("complex", style::WORD_GROUP2);
    insert_word("dict", style::WORD_GROUP2);
    insert_word("enumerate", style::WORD_GROUP2);
    insert_word("filter", style::WORD_GROUP2);
    insert_word("float", style::WORD_GROUP2);
    insert_word("frozenset", style::WORD_GROUP2);
    insert_word("int", style::WORD_GROUP2);
    insert_word("list", style::WORD_GROUP2);
    insert_word("map", style::WORD_GROUP2);
    insert_word("memoryview", style::WORD_GROUP2);
    insert_word("object", style::WORD_GROUP2);
    insert_word("property", style::WORD_GROUP2);
    insert_word("range", style::WORD_GROUP2);
    insert_word("reversed", style::WORD_GROUP2);
    insert_word("self", style::WORD_GROUP2);
    insert_word("set", style::WORD_GROUP2);
    insert_word("slice", style::WORD_GROUP2);
    insert_word("staticmethod", style::WORD_GROUP2);
    insert_word("str", style::WORD_GROUP2);
    insert_word("super", style::WORD_GROUP2);
    insert_word("tuple", style::WORD_GROUP2);
    insert_word("type", style::WORD_GROUP2);
    insert_word("zip", style::WORD_GROUP2);
    insert_word("__bases__", style::WORD_GROUP4);
    insert_word("__builtin__", style::WORD_GROUP4);
    insert_word("__class__", style::WORD_GROUP4);
    insert_word("__debug__", style::WORD_GROUP4);
    insert_word("__dict__", style::WORD_GROUP4);
    insert_word("__doc__", style::WORD_GROUP4);
    insert_word("__file__", style::WORD_GROUP4);
    insert_word("__import__", style::WORD_GROUP4);
    insert_word("__members__", style::WORD_GROUP4);
    insert_word("__methods__", style::WORD_GROUP4);
    insert_word("__name__", style::WORD_GROUP4);
    insert_word("__self__", style::WORD_GROUP4);
    make_words();
}
StyleRuby::StyleRuby() : StyleDef(style::RUBY) {
    _single_quote_str  = '\'';
    _line_comment      = "#";
    _line_comment_size = 1;
    _block_start       = "=begin";
    _block_start_size  = 6;
    _block_end         = "=end";
    _block_end_size    = 4;
    _raw_start[0]      = "%q(";
    _raw_start_size[0] = 3;
    _raw_end[0]        = ")";
    _raw_end_size[0]   = 1;
    _raw_start[1]      = "%Q(";
    _raw_start_size[1] = 3;
    _raw_end[1]        = ")";
    _raw_end_size[1]   = 1;
    _raw_start[2]      = "<<HEREDOC";
    _raw_start_size[2] = 9;
    _raw_end[2]        = "HEREDOC";
    _raw_end_size[2]   = 7;
    _hex               = true;
    _bin               = true;
    _oct               = true;
    _tokens.set('@', Token::VALUE);
    _tokens.set('_', Token::IDENT2 | Token::IDENT1 | Token::NUM_SEPARATOR);
    insert_word("alias", style::WORD_GROUP1);
    insert_word("and", style::WORD_GROUP1);
    insert_word("begin", style::WORD_GROUP1);
    insert_word("break", style::WORD_GROUP1);
    insert_word("case", style::WORD_GROUP1);
    insert_word("class", style::WORD_GROUP1);
    insert_word("def", style::WORD_GROUP1);
    insert_word("defined?", style::WORD_GROUP1);
    insert_word("do", style::WORD_GROUP1);
    insert_word("else", style::WORD_GROUP1);
    insert_word("elsif", style::WORD_GROUP1);
    insert_word("end", style::WORD_GROUP1);
    insert_word("ensure", style::WORD_GROUP1);
    insert_word("for", style::WORD_GROUP1);
    insert_word("if", style::WORD_GROUP1);
    insert_word("in", style::WORD_GROUP1);
    insert_word("module", style::WORD_GROUP1);
    insert_word("next", style::WORD_GROUP1);
    insert_word("not", style::WORD_GROUP1);
    insert_word("or", style::WORD_GROUP1);
    insert_word("private", style::WORD_GROUP1);
    insert_word("protected", style::WORD_GROUP1);
    insert_word("public", style::WORD_GROUP1);
    insert_word("raise", style::WORD_GROUP1);
    insert_word("redo", style::WORD_GROUP1);
    insert_word("rescue", style::WORD_GROUP1);
    insert_word("retry", style::WORD_GROUP1);
    insert_word("return", style::WORD_GROUP1);
    insert_word("super", style::WORD_GROUP1);
    insert_word("then", style::WORD_GROUP1);
    insert_word("undef", style::WORD_GROUP1);
    insert_word("unless", style::WORD_GROUP1);
    insert_word("until", style::WORD_GROUP1);
    insert_word("when", style::WORD_GROUP1);
    insert_word("while", style::WORD_GROUP1);
    insert_word("yield", style::WORD_GROUP1);
    insert_word("ARGV", style::WORD_GROUP2);
    insert_word("ArgumentError", style::WORD_GROUP2);
    insert_word("Array", style::WORD_GROUP2);
    insert_word("Bignum", style::WORD_GROUP2);
    insert_word("Class", style::WORD_GROUP2);
    insert_word("Comparable", style::WORD_GROUP2);
    insert_word("EOFError", style::WORD_GROUP2);
    insert_word("Encoding", style::WORD_GROUP2);
    insert_word("Enumerable", style::WORD_GROUP2);
    insert_word("Enumerator", style::WORD_GROUP2);
    insert_word("Errno", style::WORD_GROUP2);
    insert_word("Exception", style::WORD_GROUP2);
    insert_word("FALSE", style::WORD_GROUP2);
    insert_word("FalseClass", style::WORD_GROUP2);
    insert_word("Fiber", style::WORD_GROUP2);
    insert_word("File", style::WORD_GROUP2);
    insert_word("Fixnum", style::WORD_GROUP2);
    insert_word("Float", style::WORD_GROUP2);
    insert_word("FloatDomainError", style::WORD_GROUP2);
    insert_word("GC", style::WORD_GROUP2);
    insert_word("IO", style::WORD_GROUP2);
    insert_word("IOError", style::WORD_GROUP2);
    insert_word("IndexError", style::WORD_GROUP2);
    insert_word("Integer", style::WORD_GROUP2);
    insert_word("LoadError", style::WORD_GROUP2);
    insert_word("LocalJumpError", style::WORD_GROUP2);
    insert_word("Marshal", style::WORD_GROUP2);
    insert_word("Math", style::WORD_GROUP2);
    insert_word("Method", style::WORD_GROUP2);
    insert_word("Module", style::WORD_GROUP2);
    insert_word("NameError", style::WORD_GROUP2);
    insert_word("NilClass", style::WORD_GROUP2);
    insert_word("NoMemoryError", style::WORD_GROUP2);
    insert_word("NoMethodError", style::WORD_GROUP2);
    insert_word("NotImplementedError", style::WORD_GROUP2);
    insert_word("Numeric", style::WORD_GROUP2);
    insert_word("Object", style::WORD_GROUP2);
    insert_word("Range", style::WORD_GROUP2);
    insert_word("RangeError", style::WORD_GROUP2);
    insert_word("Regexp", style::WORD_GROUP2);
    insert_word("RegexpError", style::WORD_GROUP2);
    insert_word("RubyVM", style::WORD_GROUP2);
    insert_word("RuntimeError", style::WORD_GROUP2);
    insert_word("STDERR", style::WORD_GROUP2);
    insert_word("STDIN", style::WORD_GROUP2);
    insert_word("STDOUT", style::WORD_GROUP2);
    insert_word("ScriptError", style::WORD_GROUP2);
    insert_word("SecurityError", style::WORD_GROUP2);
    insert_word("StandardError", style::WORD_GROUP2);
    insert_word("String", style::WORD_GROUP2);
    insert_word("Struct", style::WORD_GROUP2);
    insert_word("Symbol", style::WORD_GROUP2);
    insert_word("SyntaxError", style::WORD_GROUP2);
    insert_word("SystemCallError", style::WORD_GROUP2);
    insert_word("SystemStackError", style::WORD_GROUP2);
    insert_word("TRUE", style::WORD_GROUP2);
    insert_word("Thread", style::WORD_GROUP2);
    insert_word("ThreadError", style::WORD_GROUP2);
    insert_word("Time", style::WORD_GROUP2);
    insert_word("TrueClass", style::WORD_GROUP2);
    insert_word("TypeError", style::WORD_GROUP2);
    insert_word("ZeroDivisionError", style::WORD_GROUP2);
    insert_word("false", style::WORD_GROUP2);
    insert_word("nil", style::WORD_GROUP2);
    insert_word("self", style::WORD_GROUP2);
    insert_word("true", style::WORD_GROUP2);
    insert_word("BEGIN", style::WORD_GROUP4);
    insert_word("END", style::WORD_GROUP4);
    insert_word("PLATFORM", style::WORD_GROUP4);
    insert_word("__ENCODING__", style::WORD_GROUP4);
    insert_word("__FILE__", style::WORD_GROUP4);
    insert_word("__LINE__", style::WORD_GROUP4);
    make_words();
}
StyleRust::StyleRust() : StyleDef(style::RUST) {
    _line_comment      = "//";
    _line_comment_size = 2;
    _block_start       = "/*";
    _block_start_size  = 2;
    _block_end         = "*/";
    _block_end_size    = 2;
    _raw_start[0]      = "r#\"";
    _raw_start_size[0] = 3;
    _raw_end[0]        = "\"#";
    _raw_end_size[0]   = 2;
    _raw_start[1]      = "r\"";
    _raw_start_size[1] = 2;
    _raw_end[1]        = "\"";
    _raw_end_size[1]   = 1;
    _raw_start[2]      = "b\"";
    _raw_start_size[2] = 2;
    _raw_end[2]        = "\"";
    _raw_end_size[2]   = 1;
    _raw_start[3]      = "br\"";
    _raw_start_size[3] = 3;
    _raw_end[3]        = "\"";
    _raw_end_size[3]   = 1;
    _tokens.set('_', Token::IDENT2 | Token::IDENT1 | Token::NUM_SEPARATOR);
    _tokens.set('#', Token::PRAGMA);
    insert_word("abstract", style::WORD_GROUP1);
    insert_word("alignof", style::WORD_GROUP1);
    insert_word("as", style::WORD_GROUP1);
    insert_word("async", style::WORD_GROUP1);
    insert_word("await", style::WORD_GROUP1);
    insert_word("become", style::WORD_GROUP1);
    insert_word("box", style::WORD_GROUP1);
    insert_word("break", style::WORD_GROUP1);
    insert_word("const", style::WORD_GROUP1);
    insert_word("continue", style::WORD_GROUP1);
    insert_word("crate", style::WORD_GROUP1);
    insert_word("default", style::WORD_GROUP1);
    insert_word("do", style::WORD_GROUP1);
    insert_word("dyn", style::WORD_GROUP1);
    insert_word("else", style::WORD_GROUP1);
    insert_word("enum", style::WORD_GROUP1);
    insert_word("extern", style::WORD_GROUP1);
    insert_word("final", style::WORD_GROUP1);
    insert_word("for", style::WORD_GROUP1);
    insert_word("if", style::WORD_GROUP1);
    insert_word("impl", style::WORD_GROUP1);
    insert_word("in", style::WORD_GROUP1);
    insert_word("let", style::WORD_GROUP1);
    insert_word("loop", style::WORD_GROUP1);
    insert_word("macro", style::WORD_GROUP1);
    insert_word("match", style::WORD_GROUP1);
    insert_word("mod", style::WORD_GROUP1);
    insert_word("move", style::WORD_GROUP1);
    insert_word("mut", style::WORD_GROUP1);
    insert_word("offsetof", style::WORD_GROUP1);
    insert_word("override", style::WORD_GROUP1);
    insert_word("priv", style::WORD_GROUP1);
    insert_word("proc", style::WORD_GROUP1);
    insert_word("pub", style::WORD_GROUP1);
    insert_word("pure", style::WORD_GROUP1);
    insert_word("ref", style::WORD_GROUP1);
    insert_word("return", style::WORD_GROUP1);
    insert_word("sizeof", style::WORD_GROUP1);
    insert_word("static", style::WORD_GROUP1);
    insert_word("struct", style::WORD_GROUP1);
    insert_word("super", style::WORD_GROUP1);
    insert_word("trait", style::WORD_GROUP1);
    insert_word("try", style::WORD_GROUP1);
    insert_word("typeof", style::WORD_GROUP1);
    insert_word("union", style::WORD_GROUP1);
    insert_word("unsafe", style::WORD_GROUP1);
    insert_word("unsized", style::WORD_GROUP1);
    insert_word("use", style::WORD_GROUP1);
    insert_word("virtual", style::WORD_GROUP1);
    insert_word("where", style::WORD_GROUP1);
    insert_word("while", style::WORD_GROUP1);
    insert_word("yield", style::WORD_GROUP1);
    insert_word("BUFSIZ", style::WORD_GROUP2);
    insert_word("Box", style::WORD_GROUP2);
    insert_word("Cons", style::WORD_GROUP2);
    insert_word("DIGITS", style::WORD_GROUP2);
    insert_word("DIR", style::WORD_GROUP2);
    insert_word("EOF", style::WORD_GROUP2);
    insert_word("EPSILON", style::WORD_GROUP2);
    insert_word("EXIT_FAILURE", style::WORD_GROUP2);
    insert_word("EXIT_SUCCESS", style::WORD_GROUP2);
    insert_word("Err", style::WORD_GROUP2);
    insert_word("FILE", style::WORD_GROUP2);
    insert_word("FILENAME_MAX", style::WORD_GROUP2);
    insert_word("FOPEN_MAX", style::WORD_GROUP2);
    insert_word("F_OK", style::WORD_GROUP2);
    insert_word("Failure", style::WORD_GROUP2);
    insert_word("INFINITY", style::WORD_GROUP2);
    insert_word("L_tmpnam", style::WORD_GROUP2);
    insert_word("MAIN_SEPARATOR", style::WORD_GROUP2);
    insert_word("MANTISSA_DIGITS", style::WORD_GROUP2);
    insert_word("MAX", style::WORD_GROUP2);
    insert_word("MAX_10_EXP", style::WORD_GROUP2);
    insert_word("MAX_EXP", style::WORD_GROUP2);
    insert_word("MIN", style::WORD_GROUP2);
    insert_word("MIN_10_EXP", style::WORD_GROUP2);
    insert_word("MIN_EXP", style::WORD_GROUP2);
    insert_word("MIN_POSITIVE", style::WORD_GROUP2);
    insert_word("NAN", style::WORD_GROUP2);
    insert_word("NEG_INFINITY", style::WORD_GROUP2);
    insert_word("Nil", style::WORD_GROUP2);
    insert_word("None", style::WORD_GROUP2);
    insert_word("ONCE_INIT", style::WORD_GROUP2);
    insert_word("O_APPEND", style::WORD_GROUP2);
    insert_word("O_CREAT", style::WORD_GROUP2);
    insert_word("O_EXCL", style::WORD_GROUP2);
    insert_word("O_RDONLY", style::WORD_GROUP2);
    insert_word("O_RDWR", style::WORD_GROUP2);
    insert_word("O_TRUNC", style::WORD_GROUP2);
    insert_word("O_WRONLY", style::WORD_GROUP2);
    insert_word("Ok", style::WORD_GROUP2);
    insert_word("Option", style::WORD_GROUP2);
    insert_word("Path", style::WORD_GROUP2);
    insert_word("PathBuf", style::WORD_GROUP2);
    insert_word("RADIX", style::WORD_GROUP2);
    insert_word("RAND_MAX", style::WORD_GROUP2);
    insert_word("REPLACEMENT_CHARACTER", style::WORD_GROUP2);
    insert_word("R_OK", style::WORD_GROUP2);
    insert_word("Result", style::WORD_GROUP2);
    insert_word("SEEK_CUR", style::WORD_GROUP2);
    insert_word("SEEK_END", style::WORD_GROUP2);
    insert_word("SEEK_SET", style::WORD_GROUP2);
    insert_word("STDERR_FILENO", style::WORD_GROUP2);
    insert_word("STDIN_FILENO", style::WORD_GROUP2);
    insert_word("STDOUT_FILENO", style::WORD_GROUP2);
    insert_word("S_IEXEC", style::WORD_GROUP2);
    insert_word("S_IFBLK", style::WORD_GROUP2);
    insert_word("S_IFCHR", style::WORD_GROUP2);
    insert_word("S_IFDIR", style::WORD_GROUP2);
    insert_word("S_IFIFO", style::WORD_GROUP2);
    insert_word("S_IFMT", style::WORD_GROUP2);
    insert_word("S_IFREG", style::WORD_GROUP2);
    insert_word("S_IREAD", style::WORD_GROUP2);
    insert_word("S_IRUSR", style::WORD_GROUP2);
    insert_word("S_IRWXU", style::WORD_GROUP2);
    insert_word("S_IWRITE", style::WORD_GROUP2);
    insert_word("S_IWUSR", style::WORD_GROUP2);
    insert_word("S_IXUSR", style::WORD_GROUP2);
    insert_word("Self", style::WORD_GROUP2);
    insert_word("Some", style::WORD_GROUP2);
    insert_word("String", style::WORD_GROUP2);
    insert_word("Success", style::WORD_GROUP2);
    insert_word("TMP_MAX", style::WORD_GROUP2);
    insert_word("UNICODE_VERSION", style::WORD_GROUP2);
    insert_word("UNIX_EPOCH", style::WORD_GROUP2);
    insert_word("Vec", style::WORD_GROUP2);
    insert_word("W_OK", style::WORD_GROUP2);
    insert_word("X_OK", style::WORD_GROUP2);
    insert_word("_IOFBF", style::WORD_GROUP2);
    insert_word("_IOLBF", style::WORD_GROUP2);
    insert_word("_IONBF", style::WORD_GROUP2);
    insert_word("bool", style::WORD_GROUP2);
    insert_word("c_char", style::WORD_GROUP2);
    insert_word("c_double", style::WORD_GROUP2);
    insert_word("c_float", style::WORD_GROUP2);
    insert_word("c_int", style::WORD_GROUP2);
    insert_word("c_long", style::WORD_GROUP2);
    insert_word("c_longlong", style::WORD_GROUP2);
    insert_word("c_schar", style::WORD_GROUP2);
    insert_word("c_short", style::WORD_GROUP2);
    insert_word("c_uchar", style::WORD_GROUP2);
    insert_word("c_uint", style::WORD_GROUP2);
    insert_word("c_ulong", style::WORD_GROUP2);
    insert_word("c_ulonglong", style::WORD_GROUP2);
    insert_word("c_ushort", style::WORD_GROUP2);
    insert_word("c_void", style::WORD_GROUP2);
    insert_word("char", style::WORD_GROUP2);
    insert_word("clock_t", style::WORD_GROUP2);
    insert_word("dev_t", style::WORD_GROUP2);
    insert_word("dirent", style::WORD_GROUP2);
    insert_word("f32", style::WORD_GROUP2);
    insert_word("f64", style::WORD_GROUP2);
    insert_word("false", style::WORD_GROUP2);
    insert_word("fpos_t", style::WORD_GROUP2);
    insert_word("i128", style::WORD_GROUP2);
    insert_word("i16", style::WORD_GROUP2);
    insert_word("i32", style::WORD_GROUP2);
    insert_word("i64", style::WORD_GROUP2);
    insert_word("i8", style::WORD_GROUP2);
    insert_word("ino_t", style::WORD_GROUP2);
    insert_word("intptr_t", style::WORD_GROUP2);
    insert_word("isize", style::WORD_GROUP2);
    insert_word("mode_t", style::WORD_GROUP2);
    insert_word("off_t", style::WORD_GROUP2);
    insert_word("pid_t", style::WORD_GROUP2);
    insert_word("ptrdiff_t", style::WORD_GROUP2);
    insert_word("self", style::WORD_GROUP2);
    insert_word("size_t", style::WORD_GROUP2);
    insert_word("ssize_t", style::WORD_GROUP2);
    insert_word("str", style::WORD_GROUP2);
    insert_word("time_t", style::WORD_GROUP2);
    insert_word("true", style::WORD_GROUP2);
    insert_word("u128", style::WORD_GROUP2);
    insert_word("u16", style::WORD_GROUP2);
    insert_word("u32", style::WORD_GROUP2);
    insert_word("u64", style::WORD_GROUP2);
    insert_word("u8", style::WORD_GROUP2);
    insert_word("uintptr_t", style::WORD_GROUP2);
    insert_word("usize", style::WORD_GROUP2);
    insert_word("Add", style::WORD_GROUP8);
    insert_word("AddAssign", style::WORD_GROUP8);
    insert_word("Alloc", style::WORD_GROUP8);
    insert_word("Any", style::WORD_GROUP8);
    insert_word("AsMut", style::WORD_GROUP8);
    insert_word("AsRef", style::WORD_GROUP8);
    insert_word("AsSlice", style::WORD_GROUP8);
    insert_word("Binary", style::WORD_GROUP8);
    insert_word("BitAnd", style::WORD_GROUP8);
    insert_word("BitAndAssign", style::WORD_GROUP8);
    insert_word("BitOr", style::WORD_GROUP8);
    insert_word("BitOrAssign", style::WORD_GROUP8);
    insert_word("BitXor", style::WORD_GROUP8);
    insert_word("BitXorAssign", style::WORD_GROUP8);
    insert_word("Borrow", style::WORD_GROUP8);
    insert_word("BorrowMut", style::WORD_GROUP8);
    insert_word("BufRead", style::WORD_GROUP8);
    insert_word("BuildHasher", style::WORD_GROUP8);
    insert_word("CharExt", style::WORD_GROUP8);
    insert_word("Clone", style::WORD_GROUP8);
    insert_word("CoerceUnsized", style::WORD_GROUP8);
    insert_word("Copy", style::WORD_GROUP8);
    insert_word("Debug", style::WORD_GROUP8);
    insert_word("Decodable", style::WORD_GROUP8);
    insert_word("Default", style::WORD_GROUP8);
    insert_word("Deref", style::WORD_GROUP8);
    insert_word("DerefMut", style::WORD_GROUP8);
    insert_word("DispatchFromDyn", style::WORD_GROUP8);
    insert_word("Display", style::WORD_GROUP8);
    insert_word("Div", style::WORD_GROUP8);
    insert_word("DivAssign", style::WORD_GROUP8);
    insert_word("DoubleEndedIterator", style::WORD_GROUP8);
    insert_word("Drop", style::WORD_GROUP8);
    insert_word("Encodable", style::WORD_GROUP8);
    insert_word("Eq", style::WORD_GROUP8);
    insert_word("Error", style::WORD_GROUP8);
    insert_word("ExactSizeIterator", style::WORD_GROUP8);
    insert_word("Extend", style::WORD_GROUP8);
    insert_word("FixedSizeArray", style::WORD_GROUP8);
    insert_word("Fn", style::WORD_GROUP8);
    insert_word("FnBox", style::WORD_GROUP8);
    insert_word("FnMut", style::WORD_GROUP8);
    insert_word("FnOnce", style::WORD_GROUP8);
    insert_word("From", style::WORD_GROUP8);
    insert_word("FromIterator", style::WORD_GROUP8);
    insert_word("FromPrimitive", style::WORD_GROUP8);
    insert_word("FromStr", style::WORD_GROUP8);
    insert_word("FusedIterator", style::WORD_GROUP8);
    insert_word("Future", style::WORD_GROUP8);
    insert_word("Generator", style::WORD_GROUP8);
    insert_word("GlobalAlloc", style::WORD_GROUP8);
    insert_word("Hash", style::WORD_GROUP8);
    insert_word("Hasher", style::WORD_GROUP8);
    insert_word("Index", style::WORD_GROUP8);
    insert_word("IndexMut", style::WORD_GROUP8);
    insert_word("Into", style::WORD_GROUP8);
    insert_word("IntoIterator", style::WORD_GROUP8);
    insert_word("Iterator", style::WORD_GROUP8);
    insert_word("IteratorExt", style::WORD_GROUP8);
    insert_word("LowerExp", style::WORD_GROUP8);
    insert_word("LowerHex", style::WORD_GROUP8);
    insert_word("Mul", style::WORD_GROUP8);
    insert_word("MulAssign", style::WORD_GROUP8);
    insert_word("MultiSpan", style::WORD_GROUP8);
    insert_word("MutPtrExt", style::WORD_GROUP8);
    insert_word("Neg", style::WORD_GROUP8);
    insert_word("Not", style::WORD_GROUP8);
    insert_word("Octal", style::WORD_GROUP8);
    insert_word("Ord", style::WORD_GROUP8);
    insert_word("PartialEq", style::WORD_GROUP8);
    insert_word("PartialOrd", style::WORD_GROUP8);
    insert_word("Pattern", style::WORD_GROUP8);
    insert_word("Pointer", style::WORD_GROUP8);
    insert_word("Product", style::WORD_GROUP8);
    insert_word("PtrExt", style::WORD_GROUP8);
    insert_word("Rand", style::WORD_GROUP8);
    insert_word("RangeBounds", style::WORD_GROUP8);
    insert_word("Read", style::WORD_GROUP8);
    insert_word("RefUnwindSafe", style::WORD_GROUP8);
    insert_word("Rem", style::WORD_GROUP8);
    insert_word("RemAssign", style::WORD_GROUP8);
    insert_word("Seek", style::WORD_GROUP8);
    insert_word("Send", style::WORD_GROUP8);
    insert_word("Shl", style::WORD_GROUP8);
    insert_word("ShlAssign", style::WORD_GROUP8);
    insert_word("Shr", style::WORD_GROUP8);
    insert_word("ShrAssign", style::WORD_GROUP8);
    insert_word("Sized", style::WORD_GROUP8);
    insert_word("SliceConcatExt", style::WORD_GROUP8);
    insert_word("SliceExt", style::WORD_GROUP8);
    insert_word("SliceIndex", style::WORD_GROUP8);
    insert_word("Step", style::WORD_GROUP8);
    insert_word("Str", style::WORD_GROUP8);
    insert_word("StrExt", style::WORD_GROUP8);
    insert_word("Sub", style::WORD_GROUP8);
    insert_word("SubAssign", style::WORD_GROUP8);
    insert_word("Sum", style::WORD_GROUP8);
    insert_word("Sync", style::WORD_GROUP8);
    insert_word("TDynBenchFn", style::WORD_GROUP8);
    insert_word("Termination", style::WORD_GROUP8);
    insert_word("ToOwned", style::WORD_GROUP8);
    insert_word("ToSocketAddrs", style::WORD_GROUP8);
    insert_word("ToString", style::WORD_GROUP8);
    insert_word("TrustedLen", style::WORD_GROUP8);
    insert_word("Try", style::WORD_GROUP8);
    insert_word("TryFrom", style::WORD_GROUP8);
    insert_word("TryInto", style::WORD_GROUP8);
    insert_word("Unpin", style::WORD_GROUP8);
    insert_word("Unsize", style::WORD_GROUP8);
    insert_word("UnwindSafe", style::WORD_GROUP8);
    insert_word("UpperExp", style::WORD_GROUP8);
    insert_word("UpperHex", style::WORD_GROUP8);
    insert_word("Write", style::WORD_GROUP8);
    make_words();
}
StyleShell::StyleShell() : StyleDef(style::SHELL) {
    _single_quote_str  = '\'';
    _line_comment      = "#";
    _line_comment_size = 1;
    _raw_start[0]      = "'";
    _raw_start_size[0] = 1;
    _raw_end[0]        = "'";
    _raw_end_size[0]   = 1;
    insert_word("case", style::WORD_GROUP1);
    insert_word("do", style::WORD_GROUP1);
    insert_word("done", style::WORD_GROUP1);
    insert_word("elif", style::WORD_GROUP1);
    insert_word("else", style::WORD_GROUP1);
    insert_word("esac", style::WORD_GROUP1);
    insert_word("eval", style::WORD_GROUP1);
    insert_word("exit", style::WORD_GROUP1);
    insert_word("fi", style::WORD_GROUP1);
    insert_word("for", style::WORD_GROUP1);
    insert_word("function", style::WORD_GROUP1);
    insert_word("if", style::WORD_GROUP1);
    insert_word("in", style::WORD_GROUP1);
    insert_word("local", style::WORD_GROUP1);
    insert_word("read", style::WORD_GROUP1);
    insert_word("return", style::WORD_GROUP1);
    insert_word("select", style::WORD_GROUP1);
    insert_word("shift", style::WORD_GROUP1);
    insert_word("then", style::WORD_GROUP1);
    insert_word("until", style::WORD_GROUP1);
    insert_word("while", style::WORD_GROUP1);
    insert_word("awk", style::WORD_GROUP2);
    insert_word("base64", style::WORD_GROUP4);
    insert_word("basename", style::WORD_GROUP4);
    insert_word("bash", style::WORD_GROUP4);
    insert_word("cat", style::WORD_GROUP4);
    insert_word("cd", style::WORD_GROUP4);
    insert_word("chcon", style::WORD_GROUP4);
    insert_word("chgrp", style::WORD_GROUP4);
    insert_word("chmod", style::WORD_GROUP4);
    insert_word("chown", style::WORD_GROUP4);
    insert_word("chroot", style::WORD_GROUP4);
    insert_word("cksum", style::WORD_GROUP4);
    insert_word("comm", style::WORD_GROUP4);
    insert_word("cp", style::WORD_GROUP4);
    insert_word("csplit", style::WORD_GROUP4);
    insert_word("cut", style::WORD_GROUP4);
    insert_word("dash", style::WORD_GROUP4);
    insert_word("date", style::WORD_GROUP4);
    insert_word("dd", style::WORD_GROUP4);
    insert_word("df", style::WORD_GROUP4);
    insert_word("dir", style::WORD_GROUP4);
    insert_word("dircolors", style::WORD_GROUP4);
    insert_word("dirname", style::WORD_GROUP4);
    insert_word("du", style::WORD_GROUP4);
    insert_word("echo", style::WORD_GROUP4);
    insert_word("env", style::WORD_GROUP4);
    insert_word("expand", style::WORD_GROUP4);
    insert_word("export", style::WORD_GROUP4);
    insert_word("expr", style::WORD_GROUP4);
    insert_word("factor", style::WORD_GROUP4);
    insert_word("false", style::WORD_GROUP4);
    insert_word("find", style::WORD_GROUP4);
    insert_word("fmt", style::WORD_GROUP4);
    insert_word("fold", style::WORD_GROUP4);
    insert_word("grep", style::WORD_GROUP4);
    insert_word("head", style::WORD_GROUP4);
    insert_word("hostid", style::WORD_GROUP4);
    insert_word("id", style::WORD_GROUP4);
    insert_word("install", style::WORD_GROUP4);
    insert_word("join", style::WORD_GROUP4);
    insert_word("kill", style::WORD_GROUP4);
    insert_word("killall", style::WORD_GROUP4);
    insert_word("less", style::WORD_GROUP4);
    insert_word("let", style::WORD_GROUP4);
    insert_word("link", style::WORD_GROUP4);
    insert_word("ln", style::WORD_GROUP4);
    insert_word("logname", style::WORD_GROUP4);
    insert_word("ls", style::WORD_GROUP4);
    insert_word("make", style::WORD_GROUP4);
    insert_word("md5sum", style::WORD_GROUP4);
    insert_word("mkdir", style::WORD_GROUP4);
    insert_word("mkfifo", style::WORD_GROUP4);
    insert_word("mknod", style::WORD_GROUP4);
    insert_word("mktemp", style::WORD_GROUP4);
    insert_word("mv", style::WORD_GROUP4);
    insert_word("nice", style::WORD_GROUP4);
    insert_word("nl", style::WORD_GROUP4);
    insert_word("nohup", style::WORD_GROUP4);
    insert_word("nproc", style::WORD_GROUP4);
    insert_word("numfmt", style::WORD_GROUP4);
    insert_word("od", style::WORD_GROUP4);
    insert_word("paste", style::WORD_GROUP4);
    insert_word("pathchk", style::WORD_GROUP4);
    insert_word("pinky", style::WORD_GROUP4);
    insert_word("pkill", style::WORD_GROUP4);
    insert_word("pr", style::WORD_GROUP4);
    insert_word("printenv", style::WORD_GROUP4);
    insert_word("printf", style::WORD_GROUP4);
    insert_word("ptx", style::WORD_GROUP4);
    insert_word("pwd", style::WORD_GROUP4);
    insert_word("readlink", style::WORD_GROUP4);
    insert_word("realpath", style::WORD_GROUP4);
    insert_word("rm", style::WORD_GROUP4);
    insert_word("rmdir", style::WORD_GROUP4);
    insert_word("runcon", style::WORD_GROUP4);
    insert_word("sed", style::WORD_GROUP4);
    insert_word("seq", style::WORD_GROUP4);
    insert_word("set", style::WORD_GROUP4);
    insert_word("sh", style::WORD_GROUP4);
    insert_word("sha1", style::WORD_GROUP4);
    insert_word("sha224", style::WORD_GROUP4);
    insert_word("sha256", style::WORD_GROUP4);
    insert_word("sha384", style::WORD_GROUP4);
    insert_word("sha512", style::WORD_GROUP4);
    insert_word("shred", style::WORD_GROUP4);
    insert_word("shuf", style::WORD_GROUP4);
    insert_word("sleep", style::WORD_GROUP4);
    insert_word("sort", style::WORD_GROUP4);
    insert_word("split", style::WORD_GROUP4);
    insert_word("stat", style::WORD_GROUP4);
    insert_word("stdbuf", style::WORD_GROUP4);
    insert_word("stty", style::WORD_GROUP4);
    insert_word("sum", style::WORD_GROUP4);
    insert_word("sync", style::WORD_GROUP4);
    insert_word("tac", style::WORD_GROUP4);
    insert_word("tail", style::WORD_GROUP4);
    insert_word("tar", style::WORD_GROUP4);
    insert_word("tee", style::WORD_GROUP4);
    insert_word("test", style::WORD_GROUP4);
    insert_word("time", style::WORD_GROUP4);
    insert_word("timeout", style::WORD_GROUP4);
    insert_word("touch", style::WORD_GROUP4);
    insert_word("tr", style::WORD_GROUP4);
    insert_word("true", style::WORD_GROUP4);
    insert_word("truncate", style::WORD_GROUP4);
    insert_word("tsort", style::WORD_GROUP4);
    insert_word("tty", style::WORD_GROUP4);
    insert_word("umask", style::WORD_GROUP4);
    insert_word("uname", style::WORD_GROUP4);
    insert_word("unexpand", style::WORD_GROUP4);
    insert_word("uniq", style::WORD_GROUP4);
    insert_word("unlink", style::WORD_GROUP4);
    insert_word("unset", style::WORD_GROUP4);
    insert_word("users", style::WORD_GROUP4);
    insert_word("vdir", style::WORD_GROUP4);
    insert_word("wc", style::WORD_GROUP4);
    insert_word("who", style::WORD_GROUP4);
    insert_word("whoami", style::WORD_GROUP4);
    insert_word("yes", style::WORD_GROUP4);
    make_words();
}
StyleTS::StyleTS() : StyleJS(style::TS) {
    _tokens.set('_', Token::IDENT2 | Token::IDENT1 | Token::NUM_SEPARATOR);
    insert_word("abstract", style::WORD_GROUP1);
    insert_word("constructor", style::WORD_GROUP1);
    insert_word("declare", style::WORD_GROUP1);
    insert_word("goto", style::WORD_GROUP1);
    insert_word("readonly", style::WORD_GROUP1);
    insert_word("type", style::WORD_GROUP1);
    insert_word("any", style::WORD_GROUP2);
    insert_word("bigint", style::WORD_GROUP2);
    insert_word("boolean", style::WORD_GROUP2);
    insert_word("never", style::WORD_GROUP2);
    insert_word("number", style::WORD_GROUP2);
    insert_word("object", style::WORD_GROUP2);
    insert_word("string", style::WORD_GROUP2);
    insert_word("symbol", style::WORD_GROUP2);
    insert_word("unknown", style::WORD_GROUP2);
    insert_word("module", style::WORD_GROUP4);
    insert_word("namespace", style::WORD_GROUP4);
    make_words();
}
}
namespace fle {
StyleMarkup::StyleMarkup() : StyleDef(style::MARKUP) {
    _block_start       = "<!--";
    _block_start_size  = 4;
    _block_end         = "-->";
    _block_end_size    = 3;
    _raw_start[0]      = "<![CDATA[";
    _raw_start_size[0] = 9;
    _raw_end[0]        = "]]>";
    _raw_end_size[0]   = 3;
}
void StyleMarkup::_tag(int& start, int& end, int last, bool term) {
    auto e           = 0;
    auto c           = (unsigned) 0;
    auto p           = (unsigned) 0;
    auto s           = style::STYLE_FG;
    auto glob        = false;
    auto raw_end_c   = (unsigned) *_raw_end[0];
    auto raw_start_c = (unsigned) *_raw_start[0];
    _style->poke(start, style::STYLE_FG);
    if (_text->peek(start + 1) == '/') {
        _style->poke(++start, style::STYLE_FG);
    }
    while (start < end) {
        c = _text->peek(++start);
        _style->poke(start, style::STYLE_FG);
        if (_STYLE_START_TAG(c) == true) {
            while (start < end) {
                if (s == style::STYLE_FG) {
                    s = style::STYLE_KEYWORD;
                    glob = (term == false) ? _text->compare_lowercase(start, "script", 6) || _text->compare_lowercase(start, "style", 5) : false;
                }
                _style->poke(start, s);
                c = _text->peek(++start);
                if (_STYLE_VALID_TAG(c) == false) {
                    start--;
                    break;
                }
            }
            s = style::STYLE_TYPE;
        }
        else if (c == '"' || c == '\'') {
            auto term = c;
            _style->poke(start, style::STYLE_STRING);
            while (start < end) {
                c = _text->peek(++start);
                _style->poke(start, style::STYLE_STRING);
                if (c == term) {
                    break;
                }
            }
        }
        else if (c == '>') {
            _style->poke(start, style::STYLE_FG);
            if (glob == true) {
                while (start < end) {
                    c = _text->peek(++start);
                    if (c == raw_start_c && _text->compare(start, _raw_start[0], _raw_start_size[0])) {
                        _STYLE_STRING_RAW(_raw_start_size[0], raw_end_c, _raw_end[0], _raw_end_size[0], _raw_escape[0])
                        start++;
                    }
                    if (_text->peek(start) == '<' && _text->peek(start + 1) == '/') {
                        start--;
                        break;
                    }
                    _style->poke(start, style::STYLE_FG);
                }
            }
            break;
        }
        else {
            _style->poke(start, style::STYLE_FG);
        }
    }
}
int StyleMarkup::update(int, int, int, const char*, const char*, Editor*) {
    auto len = _text->length();
#ifdef DEBUG_STYLE
    printf("\nSTYLE_START: length=%4d\n", len);
#endif
    auto time  = gnu::Time::Milli();
    _update(0, len);
    time = gnu::Time::Milli() - time;
#ifdef DEBUG_STYLE
    printf("STYLE_END: %s in %d mS\n\n", _name.c_str(), (int) time);
    fflush(stdout);
#endif
    return time;
}
int StyleMarkup::_update(int start, int end) {
    auto block_end_c   = (unsigned) *_block_end;
    auto block_start_c = (unsigned) *_block_start;
    auto c             = (unsigned) 0;
    auto e             = 0;
    auto last          = _text->length();
    auto raw_end_c     = (unsigned) *_raw_end[0];
    auto raw_start_c   = (unsigned) *_raw_start[0];
    auto p             = (unsigned) 0;
    while (start < end) {
        c = _text->peek(start);
        if (c == raw_start_c && _text->compare(start, _raw_start[0], _raw_start_size[0])) {
            _STYLE_STRING_RAW(_raw_start_size[0], raw_end_c, _raw_end[0], _raw_end_size[0], _raw_escape[0])
        }
        else if (c == block_start_c && _text->compare(start, _block_start, _block_start_size)) {
            _STYLE_COMMENT_BLOCK()
        }
        else if (c == '<' && _STYLE_START_TAG(_text->peek(start + 1)) == true) {
            _tag(start, end, last, false);
        }
        else if (c == '<' && _text->peek(start + 1) == '/') {
            _tag(start, end, last, true);
        }
        else {
            _style->poke(start, style::STYLE_FG);
        }
        start++;
    }
    return start;
}
}
#include <algorithm>
#include <climits>
namespace fle {
static bool _textbuffer_pair(char c, char& e, bool& forward) {
    forward = true;
    switch(c) {
    case '[':
        e = ']';
        break;
    case '{':
        e = '}';
        break;
    case '(':
        e = ')';
        break;
    case '<':
        e = '>';
        break;
    case ']':
        e = '[';
        forward = false;
        break;
    case '}':
        e = '{';
        forward = false;
        break;
    case ')':
        e = '(';
        forward = false;
        break;
    case '>':
        e = '<';
        forward = false;
        break;
    default:
        return false;
    }
    return true;
}
BufferController::BufferController(TextBuffer* buffer, int timeout, bool start_group_lock) {
    _buffer  = buffer;
    _running = false;
    _stopped = false;
    _time    = gnu::Time::Milli();
    _timeout = timeout;
    _wc      = nullptr;
    if (_buffer->_undo != nullptr && start_group_lock == true) {
        _buffer->_undo->group_lock();
    }
}
void BufferController::check_timeout() {
    auto ed = _buffer->_editor;
    if (_running == true) {
        return;
    }
    else if (_timeout != 0 && gnu::Time::Milli() - _time <= _timeout) {
        return;
    }
    _wc      = new flw::WaitCursor();
    _running = true;
    if (ed != nullptr) {
        ed->style().pause(true);
    }
#ifdef DEBUG_STYLE
    ::printf("BufferController::check_timeout: (ON)\n");
    ::printf("    timeout            = %d mS\n", (int) _timeout);
    ::printf("    time               = %d mS\n", (int) (gnu::Time::Milli() - _time));
    ::printf("    _count_changes     = %d\n", (int) _buffer->count_changes());
    fflush(stdout);
#endif
}
void BufferController::stop() {
    auto ed = _buffer->_editor;
    if (_stopped == false) {
        _stopped = true;
        if (_running == true) {
            _running = false;
            if (ed != nullptr) {
                ed->style().pause(false);
                ed->style_resize_buffer();
                ed->style().update();
            }
        }
        if (_buffer->_undo != nullptr && _buffer->_undo->is_group_locked() == true) {
            if (_buffer->count_changes() > 0) {
                _buffer->_undo->group_unlock_and_add();
            }
            else {
                _buffer->_undo->group_unlock();
            }
        }
        _time = gnu::Time::Milli() - _time;
    }
    delete _wc;
    _wc = nullptr;
}
int TextBuffer::TIMEOUT_LONG  = 200;
int TextBuffer::TIMEOUT_SHORT =  50;
int TextBuffer::TIMEOUT_UNDO  = 100;
TextBuffer::TextBuffer(Editor* editor, Config& config) : Fl_Text_Buffer(4'096, 8'192), _config(config) {
    _count_changes = 0;
    _dirty         = false;
    _editor        = editor;
    _fdelkey       = FDelKey::NIL;
    _fundo         = FUndoMode::NONE;
    _hack_undo     = 0;
    _pause_undo    = false;
    _style_text    = false;
    _undo          = nullptr;
    _word          = Token::MakeWord();
    undo_set_mode_using_config();
}
void TextBuffer::break_undo_append() {
    if (_undo != nullptr) {
        _undo->break_append();
    }
}
TextBuffer::~TextBuffer() {
    delete _undo;
}
CursorPos TextBuffer::case_for_selection(FCase fcase) {
    _count_changes = 0;
    auto cursor = _editor->cursor(false);
    if (cursor.text_has_selection() == false) {
        return CursorPos();
    }
    auto text = text_range(cursor.start, cursor.end);
    auto len  = strlen(text);
    auto buf  = gnu::file::allocate(nullptr, len * 4 + 1);
    if (fcase == FCase::LOWER) {
        fl_utf_tolower(reinterpret_cast<const unsigned char*>(text), len, buf);
    }
    else {
        fl_utf_toupper(reinterpret_cast<const unsigned char*>(text), len, buf);
    }
    if (strcmp(text, buf) == 0) {
        free(text);
        free(buf);
        return CursorPos();
    }
    replace_selection(buf);
    free(text);
    free(buf);
    cursor.set_drag();
    return cursor;
}
void TextBuffer::CallbackUndo(
    const int   pos,
    const int   inserted_size,
    const int   deleted_size,
    const int   restyled_size,
    const char* deleted_text,
    void*       text_buffer
    ) {
    (void) restyled_size;
    assert(pos >= 0);
    auto buffer = static_cast<TextBuffer*>(text_buffer);
    auto editor = buffer->_editor;
    auto added  = undo::STATUS::INIT;
    buffer->_style_text = false;
    if (inserted_size == 0 && deleted_size == 0) {
        return;
    }
    char* inserted_text = nullptr;
    if (inserted_size > 0) {
        inserted_text = buffer->text_range(pos, pos + inserted_size);
    }
    if (inserted_size == deleted_size && memcmp(inserted_text, deleted_text, inserted_size) == 0) {
        free(inserted_text);
        return;
    }
    buffer->_style_text = true;
    if (buffer->_undo != nullptr) {
        if (buffer->_pause_undo == false) {
            if (buffer->_hack_undo == 2) {
                buffer->_undo->group_lock();
                buffer->_hack_undo = 1;
            }
            else if (buffer->_hack_undo == 1) {
                buffer->_undo->group_unlock();
                buffer->_hack_undo = 0;
            }
            if (editor != nullptr) {
                added = buffer->_undo->add(buffer->_fdelkey, editor->text_has_selection(), pos, inserted_text, inserted_size, deleted_text, deleted_size);
            }
            else {
                added = buffer->_undo->add(buffer->_fdelkey, buffer->has_selection(), pos, inserted_text, inserted_size, deleted_text, deleted_size);
            }
        }
    }
    buffer->_has_selection = false;
    buffer->clear_key();
    buffer->_count_changes++;
    if (editor != nullptr) {
        if (inserted_size != deleted_size) {
            editor->bookmarks().update(pos, inserted_size, deleted_size);
        }
        if (added == undo::STATUS::REMOVED) {
            buffer->undo_check_save_point();
        }
        else {
            buffer->set_dirty(true);
        }
    }
    free(inserted_text);
}
std::string TextBuffer::checksum_calc(const char* text) const {
    if (text != nullptr) {
        auto res = string::rainbow_hex(text, strlen(text));
        return res;
    }
    else {
        auto t = this->text();
        assert((int) strlen(t) == length());
        auto res = string::rainbow_hex(t, length());
        free(t);
        return res;
    }
}
CursorPos TextBuffer::comment_block(const std::string& block_start, const std::string& block_end) {
    _count_changes = 0;
    if (block_start == "" || block_end == "") {
        return CursorPos();
    }
    auto cursor = _editor->cursor(false);
    if (cursor.text_has_selection() == false) {
        return CursorPos();
    }
    auto len    = cursor.len();
    auto adjust = 0;
    if (_undo != nullptr) {
        _undo->group_lock();
        _undo->add_custom1(gnu::str::format("%d %d %d", cursor.pos1, cursor.start, cursor.end));
    }
    _editor->style().pause(true);
    if (len >= (int) block_start.length() + (int) block_end.length() &&
        compare(cursor.start, block_start.c_str(), block_start.length()) == true &&
        compare(cursor.end - block_end.length(), block_end.c_str(), block_end.length()) == true) {
        remove(cursor.end - block_end.length(), cursor.end);
        remove(cursor.start, cursor.start + block_start.length());
        cursor.pos1  -= (cursor.pos1 == cursor.end) ? (block_start.length() + block_end.length()) : 0;
        adjust = -1;
    }
    else if (cursor.start >= (int) block_start.length() &&
        cursor.end <= length() - (int) block_end.length() &&
        compare(cursor.start - block_start.length(), block_start.c_str(), block_start.length()) == true &&
        compare(cursor.end, block_end.c_str(), block_end.length()) == true) {
        remove(cursor.end, cursor.end + block_end.length());
        remove(cursor.start - block_start.length(), cursor.start);
        cursor.pos1  -= block_start.length();
        adjust = -1;
    }
    else {
        insert(cursor.start, block_start.c_str());
        insert(cursor.end + block_start.length(), block_end.c_str());
        cursor.pos1  += block_start.length();
        adjust = 1;
    }
    selection_position(&cursor.start, &cursor.end);
    if (_undo != nullptr) {
        _undo->add_custom1(gnu::str::format("%d %d %d", cursor.pos1, cursor.start, cursor.end));
        _undo->group_unlock_and_add();
    }
    _editor->style().pause(false);
    _editor->style().update();
    if (cursor.pos2 > cursor.start) {
        cursor.pos2 += (adjust < 0) ? -block_start.length() : block_start.length();
    }
    if (cursor.pos2 > cursor.end) {
        cursor.pos2 += (adjust < 0) ? -block_end.length() : block_end.length();
    }
    cursor.set_drag();
    return cursor;
}
CursorPos TextBuffer::comment_line(const std::string& line_comment) {
    _count_changes = 0;
    auto start2 = 0;
    auto end2   = 0;
    auto cursor = _editor->cursor(false);
    if (cursor.text_has_selection() == true) {
        get_selection(start2, end2, true);
    }
    else {
        get_line_range(cursor.pos1, start2, end2);
    }
    auto line    = get_line(start2);
    auto rx      = gnu::pcre8::PCRE(gnu::str::format("^\\s*(%s)", line_comment.c_str()));
    auto matches = rx.exec(line);
    if (matches.size() == 2) {
        return _find_replace_regex_all(&rx, "", start2, end2, FRegexType::REPLACE, FSelection::NO, true);
    }
    else {
        rx.compile("(^\\s*)(\\S+)");
        return _find_replace_regex_all(&rx, line_comment, start2, end2, FRegexType::INSERT, FSelection::NO, true);
    }
}
bool TextBuffer::cut_or_copy_line(int pos, FCopy fcopy) {
    if (selected() != 0) {
        return false;
    }
    auto text  = (char*) nullptr;
    auto start = 0;
    auto end   = 0;
    get_line_range_with_nl(pos, start, end);
    if (start == end) {
        end++;
    }
    text = text_range(start, end);
    if (fcopy == FCopy::CUT_LINE) {
        remove(start, end);
    }
    if (text != nullptr) {
        Fl::copy(text, strlen(text), 2);
        free(text);
    }
    return true;
}
void TextBuffer::debug() const {
#ifdef DEBUG
    auto end   = 0;
    auto start = 0;
    auto sel   = const_cast<TextBuffer*>(this)->selection_position(&start, &end);
    ::printf("\nTextBuffer:\n");
    ::printf("    selected           = %9d\n", sel);
    ::printf("    start              = %9d\n", start);
    ::printf("    end                = %9d\n", end);
    ::printf("    length             = %9d\n", mLength);
    ::printf("    mGapStart          = %9d\n", mGapStart);
    ::printf("    mGapEnd            = %9d\n", mGapEnd);
    ::printf("    count_changes      = %9d\n", (int) _count_changes);
    ::printf("    fdelkey            = %9d\n", (int) _fdelkey);
    ::printf("    has_selection      = %9d\n", (int) _has_selection);
    ::printf("    dirty              = %9s\n", _dirty ? "TRUE" : "FALSE");
    ::printf("    pause_undo         = %9s\n", _pause_undo ? "TRUE" : "FALSE");
    ::printf("    checksum           = %s\n", _checksum.c_str());
    ::printf("    checksum_calc      = %s\n", checksum_calc().c_str());
    fflush(stdout);
#endif
}
int TextBuffer::delete_indent(int pos, FTab ftab, unsigned tab_width) {
    _count_changes = 0;
    if (ftab != FTab::SOFT || selected() != 0) {
        return 0;
    }
    int start = 0;
    int end   = 0;
    int align = 0;
    get_line_range(pos, start, end);
    if (pos == start) {
        return 0;
    }
    for (int f = pos - 1; f >= start; f--) {
        auto c = peek(f);
        if (c > ' ' || (f == pos - 1 && c == '\t')) {
            return 0;
        }
    }
    align = (pos - start) % tab_width;
    if (align == 1) {
        return 0;
    }
    align = tab_width - align;
    remove(pos - align, pos);
    return 1;
}
int TextBuffer::delete_text_left(int pos, FDelText del) {
    _count_changes = 0;
    if (del == FDelText::LINE) {
        auto start = line_start(pos);
        remove(start, pos);
        return 1;
    }
    else if (del == FDelText::WORD && selected() == 0) {
        auto start = get_word_start(pos - 1);
        if (start != -1 && start < pos) {
            remove(start, pos);
            return 1;
        }
    }
    return 0;
}
int TextBuffer::delete_text_right(int pos, FDelText del) {
    _count_changes = 0;
    if (del == FDelText::LINE) {
        auto end = line_end(pos);
        remove(pos, end);
        return 1;
    }
    else if (del == FDelText::WORD && selected() == 0) {
        auto end = get_word_end(pos);
        if (end != -1 && pos < end) {
            remove(pos, end);
            return 1;
        }
    }
    return 0;
}
CursorPos TextBuffer::duplicate_text() {
    _count_changes = 0;
    auto cursor = _editor->cursor(false);
    auto pos1   = cursor.pos1;
    auto tmp    = cursor;
    if (cursor.text_has_selection() == false) {
        get_line_range_with_nl(cursor.pos1, tmp.start, tmp.end);
        if (tmp.len() == 0) {
            insert(tmp.end, "\n");
            cursor.pos1++;
            return cursor;
        }
        auto text = text_range(tmp.start, tmp.end);
        if (text == nullptr) {
            return cursor;
        }
        auto len = tmp.len();
        if (text[len - 1] != '\n') {
            insert(tmp.end, "\n");
            tmp.end++;
        }
        if (_undo != nullptr) {
            snprintf(_buf, 256, "%d", pos1);
            _undo->prepare_custom2(_buf);
        }
        insert(tmp.end, text);
        free(text);
        cursor.pos1 += len;
        return cursor;
    }
    else {
        auto text = text_range(tmp.start, tmp.end);
        if (text == nullptr) {
            return cursor;
        }
        auto len = tmp.len();
        insert(tmp.end, text);
        free(text);
        if (tmp.pos1 > tmp.start) {
            tmp.pos1 = tmp.end + len;
        }
        else {
            tmp.pos1 = tmp.end;
        }
        tmp.start  = tmp.end;
        tmp.end += len;
        tmp.set_drag();
        return tmp;
    }
}
size_t TextBuffer::find_lines(
    std::string                 filename,
    std::string                 find,
    gnu::pcre8::PCRE*           re,
    FTrim                       ftrim,
    std::vector<std::string>&   out) {
    if (find == "" && re == nullptr) {
        return 0;
    }
    auto count = (size_t) 0;
    for (auto f = 0; f < length();) {
        auto line = gnu::str::grab(line_text(f));
        auto col  = -1;
        if (re == nullptr) {
            auto found = strstr(line.c_str(), find.c_str());
            col = (found != nullptr) ? static_cast<int>(static_cast<std::ptrdiff_t>(found - line.c_str())) : -1;
        }
        else {
            auto matches = re->exec(line);
            if (matches.size() > 0) {
                col = matches.back().start();
            }
        }
        if (col >= 0) {
            if (out.size() < limits::OUTPUT_LINES_VAL) {
                std::string s;
                if (ftrim == FTrim::YES) {
                    auto trimmed = line;
                    gnu::str::trim(trimmed);
                    if (filename != "") {
                        s = gnu::str::format("%s: %6d - %4d| %s", filename.c_str(), count + 1, col + 1, trimmed.c_str());
                    }
                    else {
                        s = gnu::str::format("%6d - %4d| %s", count + 1, col + 1, trimmed.c_str());
                    }
                }
                else if (filename != "") {
                    s = gnu::str::format("%s: %6d - %4d| %s", filename.c_str(), count + 1, col + 1, line.c_str());
                }
                else  {
                    s = gnu::str::format("%6d - %4d| %s", count + 1, col + 1, line.c_str());
                }
                if (s.length() > fle::limits::OUTPUT_LINE_LENGTH_VAL) {
                    s.resize(fle::limits::OUTPUT_LINE_LENGTH_VAL);
                    s += "|";
                }
                out.push_back(s);
            }
            else {
                out.push_back("Error: max number of lines has been reached!");
                break;
            }
        }
        count++;
        f += line.length();
        f++;
    }
    return count;
}
CursorPos TextBuffer::find_replace(
    std::string     find,
    const char*     replace,
    FSearchDir      fsearchdir,
    FCaseCompare    fcasecompare,
    FWordCompare    fwordcompare,
    FNlTab          fnltab
    ) {
    _count_changes = 0;
    auto replace2 = gnu::str::to_string(replace);
    find     = (fnltab == FNlTab::YES || fnltab == FNlTab::FIND) ? string::fnltab(find) : find;
    replace2 = (fnltab == FNlTab::YES || fnltab == FNlTab::REPLACE) ? string::fnltab(replace2) : replace2;
    auto cursor      = _editor->cursor(false);
    auto find_pos    = 0;
    auto find_len    = (int) find.length();
    auto replace_len = (int) replace2.length();
    auto found       = false;
    auto start       = 0;
    auto end         = 0;
    auto type        = (fwordcompare == FWordCompare::YES) ? _token(find) : Token::NIL;
    auto loop        = 0;
    auto sel         = selection_position(&start, &end) != 0;
    if (find == "" || find_len > length() || (fwordcompare == FWordCompare::YES && type != Token::LETTER)) {
        return CursorPos();
    }
    if (replace != nullptr && sel == true) {
        if (fwordcompare == FWordCompare::NO || is_word(start, start + find_len, type) == true) {
            auto text = get_selection_text();
            if ((fcasecompare == FCaseCompare::YES && fl_utf_strcasecmp(text.c_str(), find.c_str()) == 0) ||
                (fcasecompare == FCaseCompare::NO && fl_utf_strncasecmp(text.c_str(), find.c_str(), find.length()) == 0)) {
                _has_selection = true;
                replace_selection(replace2.c_str());
                cursor.pos1 = start + ((fsearchdir == FSearchDir::FORWARD) ? replace_len : 0);
                sel         = false;
                if (start < cursor.pos2) {
                    cursor.pos2 += replace_len - (end - start);
                }
            }
        }
    }
    while (found == false && loop < 2) {
        if (loop == 0) {
            if (fsearchdir == FSearchDir::FORWARD && sel == true && cursor.pos1 < end) {
                cursor.pos1 = end;
            }
            else if (fsearchdir == FSearchDir::BACKWARD && sel == true && cursor.pos1 == end) {
                cursor.pos1 = start - find_len;
            }
            else if (fsearchdir == FSearchDir::BACKWARD && sel == false) {
                cursor.pos1 -= find_len;
            }
        }
        else if (loop == 1) {
            cursor.pos1 = (fsearchdir == FSearchDir::FORWARD) ? 0 : length() - 1;
        }
        if (fsearchdir == FSearchDir::FORWARD) {
            while (found == false && search_forward(cursor.pos1, find.c_str(), &find_pos, fcasecompare == FCaseCompare::YES) != 0) {
                found = (fwordcompare == FWordCompare::NO || is_word(find_pos, find_pos + find_len, type) == true);
                if (found == false) {
                    cursor.pos1 = find_pos + find_len;
                }
            }
        }
        else if (fsearchdir == FSearchDir::BACKWARD) {
            while (found == false && cursor.pos1 >= 0 && search_backward(cursor.pos1, find.c_str(), &find_pos, fcasecompare == FCaseCompare::YES) != 0) {
                found = (fwordcompare == FWordCompare::NO || is_word(find_pos, find_pos + find_len, type) == true);
                if (found == false) {
                    cursor.pos1 = find_pos - find_len;
                }
            }
        }
        else {
            assert(false);
        }
        loop++;
    }
    if (found == false) {
        return CursorPos();
    }
    cursor.pos1  = find_pos + find.length();
    cursor.start = find_pos;
    cursor.end   = find_pos + find.length();
    cursor.set_drag();
    return cursor;
}
CursorPos TextBuffer::find_replace_all(
    std::string     find,
    std::string     replace,
    FSelection      fselection,
    FCaseCompare    fcase,
    FWordCompare    fword,
    FNlTab          fnltab) {
    _count_changes = 0;
    find    = (fnltab == FNlTab::YES || fnltab == FNlTab::FIND) ? string::fnltab(find) : find;
    replace = (fnltab == FNlTab::YES || fnltab == FNlTab::REPLACE) ? string::fnltab(replace) : replace;
    auto cursor     = _editor->cursor(true);
    auto ctrl       = BufferController(this, TextBuffer::TIMEOUT_LONG, true);
    auto type       = (fword == FWordCompare::YES) ? _token(find) : Token::NIL;
    auto inside_sel = false;
    auto pos        = 0;
    if (find == "") {
        return CursorPos();
    }
    else if (static_cast<int>(find.length()) > length()) {
        return CursorPos();
    }
    else if (fword == FWordCompare::YES && type != Token::LETTER) {
        return CursorPos();
    }
    if (fselection == FSelection::YES) {
        if (cursor.text_has_selection() == false) {
            return CursorPos();
        }
        pos        = cursor.start;
        inside_sel = true;
    }
    if (_undo != nullptr) {
        if (cursor.text_has_selection() == true) {
            _undo->prepare_custom1(gnu::str::format("%d %d %d", cursor.pos1, cursor.start, cursor.end));
        }
        else {
            _undo->prepare_custom1(gnu::str::format("%d -1 -1", cursor.pos1));
        }
    }
    while (search_forward(pos, find.c_str(), &pos, fcase == FCaseCompare::YES) != 0) {
        auto do_replace = true;
        if (inside_sel == true && (pos + (int) find.length()) > cursor.end) {
            break;
        }
        if (fword == FWordCompare::YES && type != Token::NIL) {
            int word_end = pos + (int) find.length();
            if (inside_sel == false || word_end <= cursor.end) {
                int pt = peek_token(pos - 1);
                int nt = peek_token(pos + find.length());
                if (pt == type || nt == type) {
                    do_replace = false;
                }
            }
        }
        if (do_replace == true) {
            auto move = replace.length() - find.length();
            if (pos < cursor.pos1) {
                cursor.pos1 += move;
            }
            if (pos < cursor.pos2) {
                cursor.pos2 += move;
            }
            if (cursor.text_has_selection() == true) {
                if (pos < cursor.start) {
                    cursor.start += move;
                }
                if (pos < cursor.end) {
                    cursor.end += move;
                }
            }
            assert(pos <= length() && pos + (int) find.length() <= length());
            this->replace(pos, pos + find.length(), replace.c_str());
            pos += replace.length();
        }
        else {
            pos += find.length();
        }
        ctrl.check_timeout();
    }
    if (_undo != nullptr) {
        _undo->clear_custom1();
        if (_count_changes == 0) {
            return CursorPos();
        }
        else if (cursor.text_has_selection() == true) {
            _undo->add_custom1(gnu::str::format("%d %d %d", cursor.pos1, cursor.start, cursor.end));
        }
        else {
            _undo->add_custom1(gnu::str::format("%d -1 -1", cursor.pos1));
        }
    }
    else if (_count_changes == 0) {
        return CursorPos();
    }
    cursor.set_drag();
    return cursor;
}
CursorPos TextBuffer::find_replace_regex(const std::string& find, const char* replace, FNlTab fnltab) {
    _count_changes = 0;
    auto rx = gnu::pcre8::PCRE();
    if (rx.compile(find, true) != "") {
        _editor->statusbar_set_message(rx.err());
        return CursorPos();
    }
    rx.notempty(true);
    auto replace2 = (fnltab == FNlTab::YES || fnltab == FNlTab::REPLACE) ? string::fnltab(gnu::str::to_string(replace)) : gnu::str::to_string(replace);
    auto pos      = _editor->cursor_insert_position();
    auto START    = pos;
    auto STOP     = INT_MAX;
    auto line_s   = 0;
    auto line_e   = 0;
    auto sel      = false;
    auto sel_e    = 0;
    auto sel_s    = 0;
    auto sel_c    = 0;
    auto use_cap  = gnu::pcre8::PCRE::Find("\\$\\d", replace2);
    if (selection_position(&sel_s, &sel_e) != 0) {
        sel = true;
        sel_c = sel_e - sel_s;
    }
    get_line_range(pos, line_s, line_e);
    auto line    = get_range(line_s, line_e);
    auto line_i  = sel_s - line_s;
    auto line_c  = (int) line.length();
    if (sel == true && line_i < line_c && replace != nullptr) {
        auto matches = rx.notbol(line_i > 0).exec(line.c_str() + line_i);
        auto sub     = std::string();
        if (matches.size() > 0 && sel_c == matches.front().count()) {
            if (use_cap == true) {
                sub = gnu::pcre8::Match::ReplaceDollar(matches, replace2);
                replace_selection(sub.c_str());
            }
            else {
                replace_selection(replace2.c_str());
            }
            get_line_range(line_s, line_s, line_e);
            line   = get_range(line_s, line_e);
            line_i = line_i + (int) ((use_cap == true) ? sub.length() : replace2.length());
            line_c = (int) line.length();
        }
        else {
            line_i = sel_e - line_s;
        }
    }
    else {
        line_i = pos - line_s;
    }
    while (true) {
        if (line_i < line_c) {
            auto matches = rx.notbol(line_i > 0).exec(line.c_str() + line_i);
            if (matches.size() > 0) {
                auto res  = _editor->cursor(false);
                res.pos1  = line_s + line_i + matches.front().end();
                res.start = line_s + line_i + matches.front().start();
                res.end   = res.pos1;
                res.set_drag();
                return res;
            }
            line_i = line_c;
        }
        else {
            pos = line_e + 1;
            if (pos >= STOP) {
                break;
            }
            else if (pos >= length()) {
                pos = 0;
                if (STOP == START) {
                    break;
                }
                STOP = START;
            }
            get_line_range(pos, line_s, line_e);
            line   = get_range(line_s, line_e);
            line_i = 0;
            line_c = (int) line.length();
        }
    }
    return CursorPos();
}
CursorPos TextBuffer::_find_replace_regex_all(
    gnu::pcre8::PCRE*   rx,
    std::string         replace,
    int                 from,
    int                 to,
    FRegexType          fregextype,
    FSelection          fselection,
    bool                last) {
    _count_changes = 0;
    if (to == 0) {
        to = length();
    }
    auto cursor  = _editor->cursor(true);
    auto ctrl    = BufferController(this, TextBuffer::TIMEOUT_LONG, true);
    auto pos1    = from;
    auto start   = 0;
    auto end     = 0;
    auto use_cap = gnu::pcre8::PCRE::Find("\\$\\d", replace);
    if (fselection == FSelection::YES) {
        from = cursor.start;
        to   = cursor.end;
        pos1 = from;
    }
    if (from == -1 || to == -1 || rx->is_compiled() == false || (fregextype != FRegexType::REPLACE && replace == "")) {
        return CursorPos();
    }
    if (_undo != nullptr) {
        if (cursor.text_has_selection() == true) {
            _undo->prepare_custom1(gnu::str::format("%d %d %d", cursor.pos1, cursor.start, cursor.end));
        }
        else {
            _undo->prepare_custom1(gnu::str::format("%d -1 -1", cursor.pos1));
        }
    }
    while (pos1 < to) {
        auto notbol = false;
        auto noteol = false;
        get_line_range(pos1, start, end);
        if (fselection == FSelection::YES) {
            if (start < cursor.start) {
                notbol = true;
                start  = cursor.start;
            }
            if (end > cursor.end) {
                end    = cursor.end;
                noteol = true;
            }
        }
        auto line    = text_range(start, end);
        auto len     = strlen(line);
        auto lend    = line + len;
        auto org     = line;
        auto matches = rx->notbol(notbol).noteol(noteol).exec(line);
        while (matches.size() > 0) {
            auto rs   = (last == true) ? matches.back().start() : matches.front().start();
            auto re   = (last == true) ? matches.back().end() : matches.front().end();
            auto add  = 0;
            auto pos2 = 0;
            notbol    = true;
            if (fregextype == FRegexType::REPLACE) {
                auto sub = std::string();
                if (use_cap == true) {
                    sub = gnu::pcre8::Match::ReplaceDollar(matches, replace);
                    this->replace(start + rs, start + re, sub.c_str());
                    add = static_cast<int>(sub.length()) - (re - rs);
                }
                else {
                    this->replace(start + rs, start + re, replace.c_str());
                    add = static_cast<int>(replace.length()) - (re - rs);
                }
                assert(start + add <= length());
                pos2 = start + rs;
            }
            else {
                add = static_cast<int>(replace.length());
                if (fregextype == FRegexType::APPEND) {
                    assert(start + re <= length());
                    this->insert(start + re, replace.c_str());
                    pos2 = start + rs;
                }
                else if (fregextype == FRegexType::INSERT) {
                    assert(start + rs <= length());
                    this->insert(start + rs, replace.c_str());
                    pos2 = start + rs - 1;
                }
            }
            auto adjust = 0;
            if (fregextype == FRegexType::APPEND) {
                adjust = re - rs;
            }
            if (pos2 + adjust < cursor.pos1) {
                cursor.pos1 += add;
            }
            if (pos2 + adjust < cursor.pos2) {
                cursor.pos2 += add;
            }
            if (cursor.text_has_selection() == true) {
                if (pos2 < cursor.start) {
                    cursor.start += add;
                }
                if (pos2 < cursor.end) {
                    cursor.end += add;
                }
            }
            if (re == 0) {
                re = 1;
            }
            to    += add;
            start += re + add;
            end   += add;
            line   = line + re;
            if (line > lend) {
                break;
            }
            matches = rx->notbol(notbol).noteol(noteol).exec(line);
        }
        free(org);
        pos1 = end + 1;
        ctrl.check_timeout();
        if (noteol == true) {
            break;
        }
    }
    if (_undo != nullptr) {
        if (_count_changes == 0) {
            _undo->clear_custom1();
            return cursor;
        }
        else if (cursor.text_has_selection() == true) {
            _undo->add_custom1(gnu::str::format("%d %d %d", cursor.pos1, cursor.start, cursor.end));
        }
        else {
            _undo->add_custom1(gnu::str::format("%d -1 -1", cursor.pos1));
        }
    }
    else if (_count_changes == 0) {
        return cursor;
    }
    cursor.set_drag();
    return cursor;
}
CursorPos TextBuffer::find_replace_regex_all(gnu::pcre8::PCRE* regex, std::string replace, FSelection fselection, FNlTab fnltab) {
    assert(regex);
    _count_changes = 0;
    replace = (fnltab == FNlTab::YES || fnltab == FNlTab::REPLACE) ? string::fnltab(replace) : replace;
    auto cursor = _editor->cursor(false);
    if (fselection == FSelection::YES) {
        if (cursor.text_has_selection() == false) {
            return cursor;
        }
        return _find_replace_regex_all(regex, replace, cursor.start, cursor.end, FRegexType::REPLACE, FSelection::YES);
    }
    else {
        return _find_replace_regex_all(regex, replace, 0, length(), FRegexType::REPLACE, FSelection::NO);
    }
}
gnu::file::Buf TextBuffer::get(FLineEnding flineending, FTrim ftrim, FChecksum fchecksum) {
    auto text1 = gnu::file::Buf::Grab(text());
    auto text2 = text1.insert_cr(flineending == FLineEnding::WINDOWS, ftrim == FTrim::YES);
    if (fchecksum == FChecksum::YES) {
        checksum_set(text1.c_str());
    }
    if (text2.c_str() == nullptr) {
        return text1;
    }
    return text2;
}
std::string TextBuffer::get_first(int pos) const {
    auto start = 0;
    auto end   = 0;
    get_line_range(pos, start, end);
    return get_range(start, pos);
}
std::string TextBuffer::get_indent(int pos) const {
    std::string res;
    for (auto c : get_first(pos)) {
        if (c == ' ' || c == '\t') {
            res += c;
        }
        else {
            break;
        }
    }
    return res;
}
std::string TextBuffer::get_letters_to_left(int pos) const {
    auto f = pos;
    auto t = 0;
    do {
        f--;
        t = _word.get(peek(f));
    } while (t &  Token::LETTER);
    if (f < pos - 1) {
        return gnu::str::grab(text_range(f + 1, pos));
    }
    return "";
}
void TextBuffer::get_line_range(int pos, int& start, int& end) const {
    start = line_start(pos);
    end   = line_end(pos);
}
void TextBuffer::get_line_range_with_nl(int pos, int& start, int& end) const {
    start = line_start(pos);
    end   = line_end(pos);
    if (peek(end - 1) != '\n') {
        end++;
    }
}
std::string TextBuffer::get_range(int start, int end) const {
    return gnu::str::grab(text_range(start, end));
}
bool TextBuffer::get_selection(int& start, int& end, bool expand) {
    if (selection_position(&start, &end) == 0) {
        return false;
    }
    if (expand == true) {
        start = line_start(start);
        if (peek(end - 1) != '\n') {
            end = line_end(end) + 1;
        }
    }
    return true;
}
int TextBuffer::get_word_end(int pos) const {
    auto type = peek_token(pos);
    if (type ==  Token::NIL) {
        return -1;
    }
    auto stop = pos;
    for (auto f = pos + 1; f <= length(); f++) {
        auto t = peek_token(f);
        stop = f;
        if ((type & t) == 0) {
            break;
        }
    }
    return stop;
}
int TextBuffer::get_word_start(int pos) const {
    auto type = peek_token(pos);
    if (type ==  Token::NIL) {
        return -1;
    }
    auto start = pos;
    for (auto f = pos - 1; f >= 0; f--) {
        auto t = peek_token(f);
        if ((type & t) == 0) {
            break;
        }
        start = f;
    }
    return start;
}
bool TextBuffer::has_multiline_selection() {
    int s, e;
    return selection_position(&s, &e) != 0 && (line_end(s) < e || line_start(e) > s);
}
int TextBuffer::home(int pos) {
    auto line = line_text(pos);
    if (*line == 0) {
        free(line);
        return -1;
    }
    auto start   = line_start(pos);
    auto re      = gnu::pcre8::PCRE("^(\\s*)");
    auto end     = 0;
    auto matches = re.exec(line);
    if (matches.size() == 2) {
        end = matches.back().end();
    }
    free(line);
    if (end < 0) {
        return start;
    }
    else if (pos == start || pos != start + end) {
        return start + end;
    }
    else {
        return start;
    }
}
CursorPos TextBuffer::indent(FIndent findent) {
    _count_changes = 0;
    if (_config.pref_indentation != true || selected() != 0) {
        return CursorPos();
    }
    auto cursor  = _editor->cursor(false);
    auto re      = gnu::pcre8::PCRE("^(\\s+)");
    auto line    = line_text(cursor.pos1);
    auto start   = line_start(cursor.pos1);
    auto end     = line_end(cursor.pos1);
    auto matches = re.exec(line);
    if (matches.size() == 2) {
        auto text = matches.back().word();
        if (cursor.pos1 == end) {
            text = "\n" + text;
            insert(cursor.pos1, text.c_str());
            cursor.pos1 += text.length();
        }
        else if (findent == FIndent::ADDLINE) {
            if (_undo != nullptr) {
                _undo->group_lock();
                _undo->prepare_custom1(gnu::str::format("%d -1 -1", cursor.pos1));
            }
            text += "\n";
            insert(end + 1, text.c_str());
            cursor.pos1 = end + text.length();
            if (_undo != nullptr) {
                _undo->add_custom1(gnu::str::format("%d -1 -1", cursor.pos1));
                _undo->group_unlock();
            }
        }
        else {
            auto len = cursor.pos1 - start;
            if (len < (int) text.length()) {
                text = text.substr(0, len);
            }
            text = "\n" + text;
            insert(cursor.pos1, text.c_str());
            cursor.pos1 += text.length();
        }
    }
    else if (findent == FIndent::ADDLINE) {
        if (_undo != nullptr) {
            _undo->group_lock();
            _undo->prepare_custom1(gnu::str::format("%d -1 -1", cursor.pos1));
        }
        insert(end + 1, "\n");
        cursor.pos1 = end + 1;
        if (_undo != nullptr) {
            _undo->add_custom1(gnu::str::format("%d -1 -1", cursor.pos1));
            _undo->group_unlock();
        }
    }
    else {
        cursor.pos1 = -1;
    }
    free(line);
    cursor.pos2 = -1;
    return cursor;
}
CursorPos TextBuffer::insert_tab(CursorPos cursor, FTab ftab, unsigned tab_width) {
    if (tab_width > limits::TAB_WIDTH_MAX) {
        return cursor;
    }
    if (cursor.text_has_selection() == true) {
        remove_selection();
        cursor.pos1 -= ((cursor.pos1 == cursor.end) ? cursor.end - cursor.start : 0);
        cursor.clear_selection();
    }
    _count_changes = 0;
    if (ftab == FTab::SOFT) {
        auto line  = line_text(cursor.pos1);
        auto start = line_start(cursor.pos1);
        line[cursor.pos1 - start] = 0;
        auto ulen = strlen(line) - gnu::str::utf_len(line);
        auto size = tab_width - ((cursor.pos1 - start - ulen) % tab_width);
        free(line);
        insert(cursor.pos1, strings::SOFT_TABS[size]);
        cursor.pos1 = cursor.pos1 + size;
        cursor.pos2 = -1;
        return cursor;
    }
    else {
        insert(cursor.pos1, "\t");
        cursor.pos1 += 1;
        cursor.pos2 = -1;
        return cursor;
    }
}
CursorPos TextBuffer::insert_tab_multiline(CursorPos cursor, FMoveH fmoveh, FTab ftab, unsigned tab_width) {
    if (tab_width > limits::TAB_WIDTH_MAX) {
        return cursor;
    }
    auto ctrl  = BufferController(this, TextBuffer::TIMEOUT_SHORT, true);
    auto tabs  = (ftab == FTab::HARD) ? "\t" : strings::SOFT_TABS[tab_width];
    auto tabl  = static_cast<int>(strlen(tabs));
    auto re    = gnu::pcre8::PCRE(gnu::str::format("^( {1,%u}|\t)", tab_width));
    auto start = 0;
    auto end   = 0;
    _count_changes = 0;
    get_selection(start, end, true);
    if (_undo != nullptr) {
        _undo->prepare_custom1(gnu::str::format("%d %d %d", cursor.pos1, cursor.start, cursor.end));
    }
    for (auto f = start; f < end; ) {
        auto line = line_text(f);
        auto len  = strlen(line);
        if (len > 0) {
            auto add = 0;
            if (fmoveh == FMoveH::LEFT) {
                auto matches = re.exec(line);
                if (matches.size() > 1) {
                    auto rs = matches.back().start();
                    auto re = matches.back().end();
                    remove(f + rs, f + re);
                    add = -(re - rs);
                }
            }
            else {
                insert(f, tabs);
                add = tabl;
            }
            if (cursor.pos1 + add >= f) {
                cursor.pos1 += add;
            }
            if (cursor.pos2 + add >= f) {
                cursor.pos2 += add;
            }
            end += add;
            f   += add;
        }
        f += len;
        f += 1;
        free(line);
        ctrl.check_timeout();
    }
    selection_position(&start, &end);
    if (_undo != nullptr) {
        _undo->add_custom1(gnu::str::format("%d %d %d", cursor.pos1, start, end));
    }
    cursor.start = start;
    cursor.end = end;
    cursor.set_drag();
    return cursor;
}
bool TextBuffer::is_word(int start, int end, int word_type) {
    if (word_type == Token::NIL) {
        return true;
    }
    auto pt = peek_token(start - 1);
    auto nt = peek_token(end);
    if (pt == word_type || nt == word_type) {
        return false;
    }
    else {
        return true;
    }
}
CursorPos TextBuffer::move_line(FMoveV move) {
    _count_changes = 0;
    auto cursor  = _editor->cursor(false);
    auto start    = -1;
    auto end      = -1;
    auto start2   = 0;
    auto end2     = 0;
    auto start3   = 0;
    auto end3     = 0;
    auto len3     = 0;
    auto text     = std::string();
    auto selected = (bool) selection_position(&start, &end);
    if (selected == true) {
        get_selection(start2, end2, true);
    }
    else {
        get_line_range(cursor.pos1, start2, end2);
    }
    if (move == FMoveV::UP && start2 < 1) {
        return CursorPos();
    }
    else if (move == FMoveV::DOWN && end2 >= length() - 1) {
        return CursorPos();
    }
    if (_undo != nullptr) {
        _undo->group_lock();
        _undo->prepare_custom1(gnu::str::format("%d %d %d", cursor.pos1, cursor.start, cursor.end));
    }
    if (selected == true) {
        text = get_range(start2, end2);
        if (move == FMoveV::UP) {
            get_line_range(start2 - 1, start3, end3);
            remove(start2, end2);
            if (text.empty() == false && text.back() != '\n') {
                text += "\n";
            }
            insert(start3, text.c_str());
            len3 = -(end3 - start3 + 1);
        }
        else {
            remove(start2, end2);
            get_line_range(start2, start3, end3);
            if (peek(end3) != 10) {
                insert(end3 + 1, "\n");
            }
            insert(end3 + 1, text.c_str());
            len3 = end3 - start3 + 1;
        }
        cursor.pos1 += len3;
        start       += len3;
        end         += len3;
    }
    else {
        text = get_range(start2, end2 + 1);
        if (move == FMoveV::UP) {
            get_line_range(start2 - 1, start3, end3);
            remove(start2, end2 + 1);
            if (text.empty() == false && text.back() != '\n') {
                text += "\n";
            }
            insert(start3, text.c_str());
            len3  = -(end3 - start3 + 1);
        }
        else {
            remove(start2, end2 + 1);
            get_line_range(start2, start3, end3);
            if (peek(end3) != 10) {
                insert(end3 + 1, "\n");
            }
            insert(end3 + 1, text.c_str());
            len3 = end3 - start3 + 1;
        }
        cursor.pos1 += len3;
    }
    if (_undo != nullptr) {
        _undo->add_custom1(gnu::str::format("%d %d %d", cursor.pos1, start, end));
        _undo->group_unlock_and_add();
    }
    cursor.start = start;
    cursor.end = end;
    cursor.set_drag();
    return cursor;
}
int TextBuffer::peek_token(int pos) const {
    return _word.get(peek(pos));
}
CursorPos TextBuffer::select_color() {
    auto  cursor  = _editor->cursor(false);
    auto& style   = _editor->style_buffer();
    auto  color   = style.peek(cursor.pos1);
    auto  start   = -1;
    auto  end     = -1;
    if (color == 0) {
        return cursor;
    }
    for (auto f = cursor.pos1; f < length(); f++) {
        auto s = style.peek(f);
        if (s != color) {
            break;
        }
        end = f;
    }
    for (auto f = cursor.pos1; f > 0; f--) {
        auto s = style.peek(f);
        if (s != color) {
            break;
        }
        start = f;
    }
    if (start >= 0 && end > start) {
        cursor.start = start;
        cursor.end   = end + 1;
        cursor.set_drag();
    }
    return cursor;
}
CursorPos TextBuffer::select_line(bool exclude_newline) {
    auto cursor = _editor->cursor(false);
    auto start  = 0;
    auto end    = 0;
    get_line_range_with_nl(cursor.pos1, start, end);
    if (exclude_newline == true && end > start && peek(end - 1) == '\n') {
        end--;
    }
    if (start > end) {
        return CursorPos();
    }
    cursor.start = start;
    if (start == end) {
        cursor.pos1 = start + 1;
        cursor.end  = start + 1;
    }
    else {
        cursor.end = end;
    }
    cursor.set_drag();
    return cursor;
}
CursorPos TextBuffer::select_pair(bool move_cursor, bool& found) {
    found = false;
    auto  cursor  = _editor->cursor(false);
    auto  c       = peek(cursor.pos1);
    auto  count   = 0;
    auto  e       = (char) 0;
    auto  end     = 0;
    auto  forward = false;
    auto& style   = _editor->style_buffer();
    auto  s       = style.peek(cursor.pos1);
    if (s >= style::STYLE_STRING && s <= style::STYLE_BLOCK_COMMENT) {
        return cursor;
    }
    _count_changes = 0;
    _textbuffer_pair(c, e, forward);
    if (e == 0) {
        c = peek(cursor.pos1 - 1);
        _textbuffer_pair(c, e, forward);
        if (forward == true) {
            count++;
        }
    }
    else {
        end = 1;
    }
    if (e == 0) {
        return cursor;
    }
    if (forward == true) {
        for (auto f = cursor.pos1; f < length(); f++) {
            auto c2 = peek(f);
            s = style.peek(f);
            if (s >= style::STYLE_STRING && s <= style::STYLE_BLOCK_COMMENT) {
            }
            else if (c2 == c) {
                count++;
            }
            else if (c2 == e) {
                count--;
                if (count == 0) {
                    cursor.start = cursor.pos1;
                    cursor.end = f + end;
                    if (move_cursor == true) {
                        cursor.pos1 = cursor.end;
                    }
                    cursor.set_drag();
                    found = true;
                    return cursor;
                }
            }
        }
    }
    else {
        for (auto f = cursor.pos1; f > 0; f--) {
            auto c2 = peek(f);
            s = style.peek(f);
            if (s >= style::STYLE_STRING && s <= style::STYLE_BLOCK_COMMENT) {
            }
            else if (c2 == c) {
                count++;
            }
            else if (c2 == e) {
                count--;
                if (count == 0) {
                    cursor.start = f + end;
                    cursor.end = cursor.pos1;
                    if (move_cursor == true) {
                        cursor.pos1 = cursor.start;
                    }
                    cursor.set_drag();
                    found = true;
                    return cursor;
                }
            }
        }
    }
    return cursor;
}
CursorPos TextBuffer::select_word() {
    auto cursor = _editor->cursor(false);
    auto start  = get_word_start(cursor.pos1);
    auto end    = get_word_end(cursor.pos1);
    if (start == -1 || end == -1 || peek(start) == '\n' || start >= end) {
        return CursorPos();
    }
    cursor.pos1  = end;
    cursor.start = start;
    cursor.end   = end;
    cursor.set_drag();
    return cursor;
}
void TextBuffer::set(const char* text, FChecksum fchecksum) {
    _pause_undo = true;
    if (_undo != nullptr) {
        _undo->clear();
        this->text(text);
    }
    else {
        this->text(text);
    }
    _pause_undo = false;
    _dirty      = false;
    if (fchecksum == FChecksum::YES) {
        checksum_set(text);
    }
    else {
        _checksum = "";
    }
}
void TextBuffer::set_dirty(bool value, bool force_send) {
    if (value != _dirty || force_send == true) {
        _dirty = value;
        _config.send_message(message::TEXT_CHANGED, "", "", _editor);
    }
}
CursorPos TextBuffer::redo(FUndoRange fundocount, CursorPos cursor) {
    if (_undo == nullptr) {
        return cursor;
    }
    auto node = _undo->redo();
    auto c    = 0;
    _count_changes = 0;
    if (node.is_null() == true) {
        return cursor;
    }
    else if (fundocount == FUndoRange::SAVEPOINT && _checksum == "") {
        return cursor;
    }
    auto ctrl = BufferController(this, TextBuffer::TIMEOUT_UNDO, false);
    auto last = undo::Event();
    _pause_undo = true;
    while (node.is_null() == false) {
        last     = node;
        int pos  = node.pos();
        int len1 = node.len1();
        int len2 = node.len2();
        if (node.is_insert() == true) {
            c++;
            insert(node.pos(), node.c_str1());
            if (pos < cursor.pos1) {
                cursor.pos1 += len1;
            }
            if (pos < cursor.pos2) {
                cursor.pos2 += len1;
            }
        }
        else if (node.is_delete() == true) {
            c++;
            remove(node.pos(), node.pos() + len1);
            if (pos < cursor.pos1) {
                cursor.pos1 -= len1;
            }
            if (pos < cursor.pos2) {
                cursor.pos2 -= len1;
            }
        }
        else if (node.is_replace() == true) {
            c++;
            remove(node.pos(), node.pos() + len1);
            insert(node.pos(), node.c_str2());
            if (pos < cursor.pos1) {
                cursor.pos1 -= len1;
                cursor.pos1 += len2;
            }
            if (pos < cursor.pos2) {
                cursor.pos2 -= len1;
                cursor.pos2 += len2;
            }
        }
        auto p = _undo->peek_redo();
        if (p.is_null() == false && (p.group() == node.group() || fundocount == FUndoRange::ALL || (fundocount == FUndoRange::SAVEPOINT && undo_check_save_point() == false))) {
            node = _undo->redo();
        }
        else {
            node = undo::Event();
        }
        ctrl.check_timeout();
    }
    ctrl.stop();
    undo_cursor_move_to_statusbar_row(cursor, last, false);
    _pause_undo = false;
    _count_changes = c;
    return cursor;
}
CursorPos TextBuffer::sort(FSort order) {
    _count_changes = 0;
    auto cursor = _editor->cursor(false);
    auto start2 = 0;
    auto end2   = 0;
    if (cursor.text_has_selection() == false) {
        return CursorPos();
    }
    get_selection(start2, end2, true);
    auto text  = text_range(start2, end2);
    auto len   = strlen(text);
    auto lines = gnu::str::split(text, "\n");
    if (text[len - 1] == '\n') {
        lines.pop_back();
    }
    if (lines.size() < 2) {
        free(text);
        return CursorPos();
    }
    std::sort(lines.begin(), lines.end());
    if (order == FSort::DESCENDING) {
        std::reverse(lines.begin(), lines.end());
    }
    auto sorted = std::string();
    sorted.reserve(len);
    for (const auto& s : lines) {
        sorted += s;
        sorted += "\n";
    }
    if (text[len - 1] != '\n' && sorted != "") {
        sorted.pop_back();
    }
    if (sorted == text) {
        free(text);
        return CursorPos();
    }
    if (_undo != nullptr) {
        _undo->group_lock();
        _undo->add_custom1(gnu::str::format("%d %d %d", cursor.pos1, cursor.start, cursor.end));
    }
    replace(start2, end2, sorted.c_str());
    if (_undo != nullptr) {
        _undo->prepare_custom1(gnu::str::format("%d %d %d", start2, start2, end2));
        _undo->group_unlock_and_add();
    }
    free(text);
    cursor.pos1  = (cursor.pos1 == cursor.start) ? start2 : end2;
    cursor.start = start2;
    cursor.end   = end2;
    cursor.set_drag();
    return cursor;
}
int TextBuffer::_token(const std::string& string) const {
    auto type = Token::NIL;
    for (auto c : string) {
        auto t = _word.get(c);
        if (type == Token::NIL) {
            type = t;
        }
        else if (t != type) {
            type = Token::NIL;
            break;
        }
    }
    return type;
}
CursorPos TextBuffer::undo(FUndoRange fundocount, CursorPos cursor) {
    if (_undo == nullptr) {
        return cursor;
    }
    auto node  = _undo->undo();
    auto c     = 0;
    _count_changes = 0;
    if (node.is_null() == true) {
        return cursor;
    }
    else if (fundocount == FUndoRange::SAVEPOINT && _checksum == "") {
        return cursor;
    }
    auto ctrl = BufferController(this, TextBuffer::TIMEOUT_UNDO, false);
    auto last = undo::Event();
    _pause_undo = true;
    while (node.is_null() == false) {
        last     = node;
        int pos  = node.pos();
        int len1 = node.len1();
        int len2 = node.len2();
        if (node.is_insert() == true) {
            c++;
            remove(pos, pos + len1);
            if (pos < cursor.pos1) {
                cursor.pos1 -= len1;
            }
            if (pos < cursor.pos2) {
                cursor.pos2 -= len1;
            }
        }
        else if (node.is_delete() == true) {
            c++;
            insert(node.pos(), node.c_str1());
            if (pos < cursor.pos1) {
                cursor.pos1 += len1;
            }
            if (pos < cursor.pos2) {
                cursor.pos2 += len1;
            }
        }
        else if (node.is_replace() == true) {
            c++;
            remove(node.pos(), node.pos() + len2);
            insert(node.pos(), node.c_str1());
            if (pos < cursor.pos1) {
                cursor.pos1 -= len2;
                cursor.pos1 += len1;
            }
            if (pos < cursor.pos2) {
                cursor.pos2 -= len2;
                cursor.pos2 += len1;
            }
        }
        auto p = _undo->peek_undo();
        if (p.is_null() == false && (p.group() == node.group() || fundocount == FUndoRange::ALL || (fundocount == FUndoRange::SAVEPOINT && undo_check_save_point() == false))) {
            node = _undo->undo();
        }
        else {
            node = undo::Event();
        }
        ctrl.check_timeout();
    }
    ctrl.stop();
    undo_cursor_move_to_statusbar_row(cursor, last, true);
    _pause_undo = false;
    _count_changes = c;
    return cursor;
}
bool TextBuffer::undo_check_save_point() {
    if (undo_is_at_save_point() == false) {
        return false;
    }
    set_dirty(false);
    return true;
}
void TextBuffer::undo_cursor_move_to_statusbar_row(CursorPos& cursor, const undo::Event& node, bool undo) {
    if (node.is_null() == true) {
        return;
    }
    int pos[3]  = { -1, -1, -1 };
    int pos2[3] = { -1, -1, -1 };
    if (node.is_custom1() == true) {
        node.str1_toint(pos);
    }
    else if (undo == true) {
        if (node.is_backspace() == true) {
            pos[0] = node.pos() + node.len1();
            if (node.is_selected() == true) {
                pos[1] = node.pos();
                pos[2] = pos[0];
            }
        }
        else if (node.is_insert() == true) {
            pos[0] = node.pos();
            if (node.is_selected() == true) {
                pos[2] = node.pos();
                pos[1] = node.pos() - node.len1();
            }
            else if (node.is_custom2() == true) {
                if (node.str2_toint(pos2) > 0) {
                    pos[0] = pos2[0];
                }
            }
        }
        else {
            pos[0] = node.pos();
            if (node.is_selected() == true) {
                pos[1] = node.pos();
                pos[2] = node.pos() + node.len1();
            }
        }
    }
    else {
        if (node.is_delete() == true) {
            pos[0] = node.pos();
            if (node.is_selected() == true) {
                pos[1] = node.pos();
                pos[2] = pos[0];
            }
        }
        else if (node.is_replace() == true) {
            pos[0] = node.pos() + node.len2();
            if (node.is_selected() == true) {
                pos[1] = node.pos();
                pos[2] = node.pos() + node.len2();
            }
        }
        else {
            pos[0] = node.pos() + node.len1();
            if (node.is_selected() == true) {
                pos[1] = node.pos();
                pos[2] = node.pos() + node.len1();
            }
            else if (node.is_custom2() == true) {
                if (node.str2_toint(pos2) > 0) {
                    pos[0] = pos2[0] + node.len1();
                }
            }
        }
    }
    if (pos[2] > pos[1]) {
        cursor.pos1  = pos[2];
        cursor.start = pos[1];
        cursor.end   = pos[2];
        cursor.drag  = pos[1];
    }
    else {
        cursor.pos1  = pos[0];
        cursor.start = -1;
        cursor.end   = -1;
        cursor.drag  = 0;
    }
}
bool TextBuffer::undo_is_at_save_point() const {
    if (_undo == nullptr || _undo->is_at_save_point() == false) {
        return false;
    }
    else if (checksum_calc() != _checksum) {
        return false;
    }
    return true;
}
bool TextBuffer::undo_is_before_save_point() {
    if (_undo == nullptr) {
        return false;
    }
    return _undo->is_before_save_point();
}
void TextBuffer::undo_set_mode_using_config() {
    if (_config.pref_undo == _fundo) {
        return;
    }
    _fundo = _config.pref_undo;
    if (_undo != nullptr) {
        delete _undo;
        _undo = nullptr;
    }
    canUndo(0);
    if (_fundo == FUndoMode::NONE) {
    }
    else if (_fundo == FUndoMode::FLTK) {
        canUndo(1);
    }
    else if (_fundo == FUndoMode::FLE_V1 && _config.pref_undo_buffer == true) {
        _undo = new undo::Undo(new undo::BufferStore());
    }
    else if (_fundo == FUndoMode::FLE_V1 && _config.pref_undo_buffer == false) {
        _undo = new undo::Undo(new undo::VectorStore());
    }
    else if (_fundo == FUndoMode::FLE_V2 && _config.pref_undo_buffer == true) {
        _undo = new undo::Undo(new undo::BufferStore(), FUndoModeFle::TIME);
    }
    else if (_fundo == FUndoMode::FLE_V2 && _config.pref_undo_buffer == false) {
        _undo = new undo::Undo(new undo::VectorStore(), FUndoModeFle::TIME);
    }
    else if (_fundo == FUndoMode::FLE_V3 && _config.pref_undo_buffer == true) {
        _undo = new undo::Undo(new undo::BufferStore(), FUndoModeFle::HARD, 13);
    }
    else if (_fundo == FUndoMode::FLE_V3 && _config.pref_undo_buffer == false) {
        _undo = new undo::Undo(new undo::VectorStore(), FUndoModeFle::HARD, 13);
    }
    else {
        assert(false);
    }
}
}
#include <assert.h>
namespace fle {
namespace undo {
ssize_t Event::_capacity() const {
    auto ret = sizeof(Event);
    if (_str1.capacity() > 15) {
        ret += _str1.capacity() - 15;
    }
    if (_str2.capacity() > 15) {
        ret += _str2.capacity() - 15;
    }
    return ret;
}
void Event::debug(ssize_t buffer_pos, int count) const {
#ifdef DEBUG
    char flags[50];
    char Str1[50];
    char Str2[50];
    sprintf(flags, "|%c%c%c%c%c%c%c| %04x", is_insert() ? 'I' : '_', is_delete() ? 'D' : '_',
        is_replace() ? 'R' : '_', is_backspace() ? 'B' : '_', is_selected() ? 'S' : '_',
        is_custom1() ? 'C' : '_', is_custom2() ? 'c' : '_', _group);
    strncpy(Str1, _str1.c_str(), 25);
    strncpy(Str2, _str2.c_str(), 25);
    Str1[25] = 0;
    Str2[25] = 0;
    auto t = reinterpret_cast<unsigned char*>(Str1);
    while (*t) {
        if (*t < 32 || *t > 126) *t = '.';
        t++;
    }
    t = reinterpret_cast<unsigned char*>(Str2);
    while (*t) {
        if (*t < 32 || *t > 126) *t = '.';
        t++;
    }
    if ((count - 1) % 40 == 0) {
        printf("----------------------------------------------------------------------\n");
        printf("%8s %6s %15s %9s %9s %s\n", "BUFPOS", "COUNT", "FLAGS      GRP ", "POS", "LEN1", "STR1");
        printf("----------------------------------------------------------------------\n");
    }
    if (len2() > 0) {
        int l = (int) (25 - strlen(Str1));
        printf("%8d %6d %15s %9d %9d |%s| %*s %9d |%s|\n", (int) buffer_pos, count, _flag == 0 ? "|________| XXXX" : flags, _pos, len1(), Str1, l, "", len2(), Str2);
    }
    else {
        printf("%8d %6d %15s %9d %9d |%s|\n", (int) buffer_pos, count, _flag == 0 ? "|________| XXXX" : flags, _pos, len1(), Str1);
    }
    fflush(stdout);
#else
    (void) buffer_pos;
    (void) count;
#endif
}
bool BufferStore::_buffer_decrease() {
    auto new_bcap = _bcap;
    if (_bend > 2'097'152) {
        while (new_bcap > _bend + 2'097'152) {
            new_bcap -= 2'097'152;
        }
    }
    else {
        while (new_bcap > _bend * 2) {
            new_bcap *= 0.5;
        }
    }
    if (new_bcap < 4'096) {
        new_bcap = 4'096;
    }
    if (new_bcap >= _bcap) {
        return false;
    }
    assert(new_bcap > _bend);
    _bcap = new_bcap;
    _buf  = gnu::file::allocate(_buf, _bcap + 1);
    return true;
}
bool BufferStore::_buffer_increase(ssize_t requested_bcap) {
    if (requested_bcap <= _bcap) {
        return false;
    }
    auto new_bcap = _bcap;
    if (requested_bcap > 2'097'152) {
        while (requested_bcap > new_bcap) {
            new_bcap += 2'097'152;
        }
    }
    else {
        while (requested_bcap > new_bcap) {
            new_bcap *= 2;
        }
    }
    if (new_bcap == _bcap) {
        return false;
    }
    _bcap = new_bcap;
    _buf  = gnu::file::allocate(_buf, _bcap + 1);
    return true;
}
void BufferStore::clear() {
    free(_buf);
    _bcap = 4'096;
    _buf  = gnu::file::allocate(nullptr, _bcap + 1);
    _bcur = -1;
    _bend = -1;
    _move = MOVE::END;
}
ssize_t BufferStore::debug(bool all) const {
#ifdef DEBUG
    ssize_t cursor1 = 0;
    ssize_t count   = 0;
    printf("\nEvent:\n");
    while (cursor1 < _bend) {
        count++;
        if (all == true) {
            get_node(cursor1).debug(cursor1, count);
        }
        go_right(cursor1);
    }
    printf("\nBufferStore:\n");
    printf("    count_all          = %8d\n", (int) count);
    printf("    bcap               = %8lld\n", (long long int) _bcap);
    printf("    bcur               = %8lld\n", (long long int) _bcur);
    printf("    bend               = %8lld\n", (long long int) _bend);
    printf("    move               = %8d\n", (int) _move);
    fflush(stdout);
    return count;
#else
    (void) all;
    return 0;
#endif
}
const Event BufferStore::get_node(ssize_t cursor) const {
    if (cursor < 0 || cursor >= _bend) {
        return Event();
    }
    auto b     = static_cast<const char*>(_buf + cursor);
    auto flag  = (uint8_t) 0;
    auto group = (uint16_t) 0;
    auto pos   = (int32_t) 0;
    auto str1  = (const char*) nullptr;
    auto str2  = (const char*) nullptr;
    flag = *b;
    b++;
    memcpy(&group, b, sizeof(group));
    b += sizeof(group);
    memcpy(&pos, b, sizeof(pos));
    b += sizeof(pos);
    str1 = b;
    b    = b + strlen(str1) + 1;
    str2 = b;
    b    = b + strlen(str2) + 1;
    return Event(flag, group, pos, str1, str2);
}
bool BufferStore::go_left() {
    if (_move == MOVE::RIGHT) {
        _move = MOVE::LEFT;
        return true;
    }
    else if (go_left(_bcur) == true) {
        _move = MOVE::LEFT;
        return true;
    }
    else {
        _move = MOVE::END;
        return false;
    }
}
bool BufferStore::go_left(ssize_t& cursor) const {
    if (cursor > 8) {
        auto b    = _buf;
        auto size = (uint32_t) 0;
        b += (cursor - sizeof(size));
        memcpy(&size, b, sizeof(size));
        cursor -= size;
        if (cursor >= 0) {
            return true;
        }
    }
    cursor = -1;
    return false;
}
bool BufferStore::go_right() {
    if (_move == MOVE::LEFT) {
        _move = MOVE::RIGHT;
        return true;
    }
    else if (go_right(_bcur) == true && _bcur < _bend) {
        _move = MOVE::RIGHT;
        return true;
    }
    else {
        _move = MOVE::END;
        _bcur = _bend;
        return false;
    }
}
bool BufferStore::go_right(ssize_t& cursor) const {
    if (cursor < 0 && _bend > 0) {
        cursor = 0;
        return true;
    }
    else if (cursor >= 0 && cursor < _bend) {
        auto b = _buf + cursor;
        b += Event::NumberSize();
        b += strlen(b);
        b++;
        b += strlen(b);
        b++;
        b += sizeof(uint32_t);
        cursor = static_cast<ssize_t>(static_cast<std::ptrdiff_t>(b - _buf));
        return true;
    }
    else {
        return false;
    }
}
void BufferStore::go_right_before_cut() {
    if (_move == MOVE::RIGHT) {
        go_right(_bcur);
        _move = MOVE::END;
    }
}
void BufferStore::invalidate_group_counter_at_cursor() {
    if (_bcur < 0 || _bcur >= _bend) {
        return;
    }
    auto b     = static_cast<char*>(_buf + _bcur);
    auto group = (uint16_t) 0;
    b++;
    memcpy(&group, b, sizeof(group));
    group += 32768;
    memcpy(b, &group, sizeof(group));
}
const Event BufferStore::peek_left() const {
    auto cursor1 = _bcur;
    if (go_left(cursor1) == true) {
        return get_node(cursor1);
    }
    else {
        return Event();
    }
}
const Event BufferStore::peek_right() const {
    auto cursor1 = _bcur;
    if (go_right(cursor1) == true) {
        return get_node(cursor1);
    }
    else {
        return Event();
    }
}
void BufferStore::pop() {
    if (go_left(_bcur) == true) {
        _bend = _bcur;
    }
    _move = MOVE::END;
}
void BufferStore::set_node(const Event& node) {
    if (_bcur < 0) {
        _bcur = 0;
    }
    auto size = static_cast<uint32_t>(node.size() + sizeof(uint32_t));
    auto inc  = _buffer_increase(_bcur + size);
    auto b    = static_cast<char*>(_buf + _bcur);
    *b = node.flag();
    b++;
    auto group = node.group();
    memcpy(b, &group, sizeof(group));
    b += sizeof(group);
    auto pos = node.pos();
    memcpy(b, &pos, sizeof(pos));
    b += sizeof(pos);
    auto l = node.len1() + 1;
    memcpy(b, node.c_str1(), l);
    b += l;
    l = node.len2() + 1;
    memcpy(b, node.c_str2(), l);
    b += l;
    auto old_end = _bend;
    memcpy(b, &size, sizeof(size));
    _bcur += size;
    _bend  = _bcur;
    _move  = MOVE::END;
    if (inc == false && _bcur < old_end) {
        _buffer_decrease();
    }
}
ssize_t VectorStore::capacity() const {
    ssize_t ret = 0;
    for (const auto& n : _events) {
        ret += n._capacity();
    }
    auto diff = _events.capacity() - _events.size();
    ret += diff * sizeof(Event);
    return ret;
}
void VectorStore::clear() {
    _events.clear();
    _cur  = -1;
    _move = MOVE::END;
}
ssize_t VectorStore::debug(bool all) const {
#ifdef DEBUG
    ssize_t cursor1 = 0;
    ssize_t count   = 0;
    printf("\nEvent:\n");
    while (cursor1 < static_cast<ssize_t>(_events.size())) {
        count++;
        if (all == true) {
            get_node(cursor1).debug(cursor1, count);
        }
        go_right(cursor1);
    }
    printf("\nVectorStore:\n");
    printf("    count_all          = %10u\n", (unsigned) count);
    printf("    memory             = %10u\n", (unsigned) capacity());
    printf("    size               = %10u\n", (unsigned) _events.size());
    printf("    capacity           = %10u\n", (unsigned) _events.capacity());
    printf("    cur                = %10d\n", (int) _cur);
    printf("    move               = %10d\n", (int) _move);
    fflush(stdout);
    return count;
#else
    (void) all;
    return 0;
#endif
}
const Event VectorStore::get_node(ssize_t cursor) const {
    if (cursor < 0 || cursor >= static_cast<ssize_t>(_events.size())) {
        return Event();
    }
    return _events[cursor];
}
bool VectorStore::go_left() {
    if (_move == MOVE::RIGHT) {
        _move = MOVE::LEFT;
        return true;
    }
    else if (go_left(_cur) == true) {
        _move = MOVE::LEFT;
        return true;
    }
    else {
        _move = MOVE::END;
        return false;
    }
}
bool VectorStore::go_left(ssize_t& cursor) const {
    if (cursor > 0) {
        cursor--;
        return true;
    }
    cursor = -1;
    return false;
}
bool VectorStore::go_right() {
    if (_move == MOVE::LEFT) {
        _move = MOVE::RIGHT;
        return true;
    }
    else if (go_right(_cur) == true && _cur < static_cast<ssize_t>(_events.size())) {
        _move = MOVE::RIGHT;
        return true;
    }
    else {
        _move = MOVE::END;
        _cur  = _events.size();
        return false;
    }
}
bool VectorStore::go_right(ssize_t& cursor) const {
    if (cursor < 0 && _events.size() > 0) {
        cursor = 0;
        return true;
    }
    else if (cursor >= 0 && cursor < static_cast<ssize_t>(_events.size())) {
        cursor++;
        return true;
    }
    else {
        return false;
    }
}
void VectorStore::go_right_before_cut() {
    if (_move == MOVE::RIGHT) {
        go_right(_cur);
        _move = MOVE::END;
    }
}
void VectorStore::invalidate_group_counter_at_cursor() {
    if (_cur < 0 || _cur >= static_cast<ssize_t>(_events.size())) {
        return;
    }
    _events[_cur]._group += 32768;
}
const Event VectorStore::peek_left() const {
    auto cursor1 = _cur;
    if (go_left(cursor1) == true) {
        return get_node(cursor1);
    }
    else {
        return Event();
    }
}
const Event VectorStore::peek_right() const {
    auto cursor1 = _cur;
    if (go_right(cursor1) == true) {
        return get_node(cursor1);
    }
    else {
        return Event();
    }
}
void VectorStore::pop() {
    if (go_left(_cur) == true) {
        _events.pop_back();
    }
    _move = MOVE::END;
}
void VectorStore::set_node(const Event& node) {
    if (_cur < 0) {
        _cur = 0;
    }
    assert(_cur <= static_cast<ssize_t>(_events.size()));
    if (_events.size() == 0 || _cur == static_cast<ssize_t>(_events.size())) {
        _events.push_back(node);
    }
    else {
        _events[_cur] = node;
        _events.resize(_cur + 1);
        if (_events.capacity() > 4'096 && _events.capacity() - _events.size() > _events.size() * 3) {
            _events.shrink_to_fit();
        }
    }
    _move = MOVE::END;
    _cur  = _events.size();
}
Undo::Undo(Store* store, FUndoModeFle fundoappend, size_t break_at, double break_time) {
    _tokens.set(' ', Token::PUNCTUATOR);
    _tokens.set('\t', Token::PUNCTUATOR);
    _tokens.set('_', Token::LETTER);
    _tokens.set('0', '9', Token::LETTER);
    _tokens.set(128, 191, Token::LETTER);
    _tokens.set(194, 244, Token::LETTER);
    _store       = store;
    _fundoappend = fundoappend;
    _break_at    = break_at;
    _break_time  = break_time;
    clear();
}
STATUS Undo::add(const FDelKey delkey, const bool selection, const int pos, const char* inserted_text, const int inserted_len, const char* deleted_text, const int deleted_len) {
    auto flag   = (uint8_t) 0;
    auto type   = (uint16_t) Token::NIL;
    auto added  = STATUS::INIT;
    auto append = true;
    auto time   = gnu::Time::Clock();
    auto diff   = time - _time;
    if (_store->cursor() < _save_point) {
        _save_point = -1;
    }
    if (_break > 0 || _append_len >= _break_at) {
        append = false;
    }
    else {
        if (_fundoappend == FUndoModeFle::TYPE) {
            if (inserted_text != nullptr) {
                type = _tokens.get_last(inserted_text, inserted_len);
            }
            else if (deleted_text != nullptr) {
                type = _tokens.get_last(deleted_text, deleted_len);
            }
            if (type == Token::NIL || (type & _prev_type) == 0) {
                append = false;
            }
        }
        else if (_fundoappend == FUndoModeFle::TIME && diff > _break_time) {
            append = false;
        }
    }
    if (selection == true) {
        flag |= static_cast<uint8_t>(EVENT::SELECTED);
    }
    if (deleted_len > 0 && inserted_len > 0) {
        flag |= static_cast<uint8_t>(EVENT::REPLACE);
        added = _add(nullptr, flag, pos, deleted_text, inserted_text);
    }
    else if (deleted_len > 0) {
        auto last = peek_undo();
        flag |= static_cast<uint8_t>(EVENT::ERASED);
        if (delkey == FDelKey::BACKSPACE) {
            flag |= static_cast<uint8_t>(EVENT::BACKSPACE);
        }
        if (last.is_null() == false && append == true) {
            if (delkey == FDelKey::DEL && pos == last.pos()) {
                added = _add(&last, flag, pos, deleted_text);
                goto EXIT;
            }
            else if (delkey == FDelKey::BACKSPACE && pos + deleted_len == last.pos()) {
                added = _add(&last, flag, pos, deleted_text);
                goto EXIT;
            }
        }
        added = _add(nullptr, flag, pos, deleted_text);
    }
    else if (inserted_len > 0) {
        auto last = peek_undo();
        flag |= static_cast<uint8_t>(EVENT::INSERT);
        if (last.is_null() == false) {
            if (last.is_insert() == true && append == true && pos == last.pos() + last.len1()) {
                added = _add(&last, flag, pos, inserted_text);
                goto EXIT;
            }
            else if (last.is_replace() == true && append == true && pos == last.pos() + last.len2()) {
                added = _add(&last, flag, pos, inserted_text);
                goto EXIT;
            }
            else if (last.is_delete() == true && pos == last.pos() && selection == true) {
                added = _add(&last, flag, pos, inserted_text);
                goto EXIT;
            }
        }
        if (_custom2 != "") {
            flag |= static_cast<uint8_t>(EVENT::CUSTOM2);
            added = _add(nullptr, flag, pos, inserted_text, _custom2.c_str());
        }
        else {
            added = _add(nullptr, flag, pos, inserted_text);
        }
    }
    group_add();
EXIT:
    _custom2 = "";
    if (_append_len >= _break_at) {
        _append_len = 0;
    }
    else if (_fundoappend == FUndoModeFle::TYPE) {
        _prev_type = type;
    }
    else if (_fundoappend == FUndoModeFle::TIME) {
        _time = time;
    }
    if (added == STATUS::APPENDED) {
        _append_len++;
    }
    else {
        _append_len = 0;
    }
    if (_break > 0) {
        _break--;
    }
    return added;
}
STATUS Undo::_add(Event* last, uint8_t flag, int pos, const char* str1, const char* str2) {
    if (_is_cursor_at_end() == true && last != nullptr) {
        auto added = _append_to_node(last, flag, pos, str1);
        if (added != STATUS::INIT) {
            return added;
        }
    }
    auto node = Event(flag, _group, pos, str1, str2);
    _push_node_to_buf(node);
    return STATUS::ADDED;
}
STATUS Undo::_append_to_node(Event* last, uint8_t flag, int pos, const char* str) {
    if (flag & static_cast<uint8_t>(EVENT::INSERT)) {
        if (last->is_insert() == true) {
            last->append_str1(str);
            _store->go_left();
            _push_node_to_buf(*last);
            return STATUS::APPENDED;
        }
        else if (last->is_replace() == true) {
            last->append_str2(str);
            _store->go_left();
            _push_node_to_buf(*last);
            return STATUS::APPENDED;
        }
        else if (last->is_delete() == true) {
            assert(last->len2() == 0);
            last->flag(static_cast<uint8_t>(EVENT::REPLACE) | static_cast<uint8_t>(EVENT::SELECTED));
            last->str2(str);
            if (last->str1() == last->str2()) {
                _store->pop();
                return STATUS::REMOVED;
            }
            else {
                _store->go_left();
                _push_node_to_buf(*last);
                return STATUS::APPENDED;
            }
        }
    }
    else if (flag & static_cast<uint8_t>(EVENT::ERASED) && last->is_delete() == true) {
        if (flag & static_cast<uint8_t>(EVENT::BACKSPACE)) {
            last->pos(pos);
            last->insert_str1(str);
            _store->go_left();
            _push_node_to_buf(*last);
            return STATUS::APPENDED;
        }
        else {
            last->append_str1(str);
            _store->go_left();
            _push_node_to_buf(*last);
            return STATUS::APPENDED;
        }
    }
    return STATUS::INIT;
}
void Undo::clear() {
    _store->clear();
    _append_len = 0;
    _break      = 0;
    _custom1    = Event();
    _custom2    = "";
    _group      = 0;
    _group_lock = false;
    _prev_type  = 0;
    _save_point = -1;
    _time       = 0.0;
}
ssize_t Undo::debug(bool all) {
#ifdef DEBUG
    auto res = _store->debug(all);
    printf("\nUndo:\n");
    printf("    append_len         = %8d\n", _append_len);
    printf("    fundoappend        = %8d\n", static_cast<int>(_fundoappend));
    printf("    break              = %8d\n", _break);
    printf("    break_at           = %8d\n", (int) _break_at);
    printf("    break_time         = %8.2f\n", _break_time);
    printf("    custom1            = %s\n", _custom1.is_null() ? "    NULL" : "     SET");
    printf("    custom2            = %s\n", _custom2.c_str());
    printf("    group              = %8d\n", _group);
    printf("    group_lock         = %8d\n", _group_lock);
    printf("    prev_type          = %8d\n", _prev_type);
    printf("    save_point         = %8lld\n", (long long int) _save_point);
    printf("    time               = %8.2f\n", _time);
    fflush(stdout);
    return res;
#else
    (void) all;
    return 0;
#endif
}
void Undo::set_save_point() {
    _save_point = _store->cursor();
}
void Undo::_push_node_to_buf(Event node) {
    if (_custom1.is_null() == false) {
        _store->go_right_before_cut();
        _store->set_node(_custom1);
        clear_custom1();
    }
    if (_is_cursor_at_end() == true) {
        _store->set_node(node);
    }
    else {
        _store->go_right_before_cut();
        _store->set_node(node);
    }
}
}
}
#include <FL/Fl_Repeat_Button.H>
#include <FL/Fl_Return_Button.H>
namespace fle {
namespace widgets {
    constexpr static const char*    BUTTON_NL                   = "NL";
    constexpr static const char*    STATUSBAR_LINE_UNIX         = "Unix";
    constexpr static const char*    STATUSBAR_LINE_WIN          = "Windows";
    constexpr static const char*    STATUSBAR_SPACES_TO_TABS    = "Convert to tabs";
    constexpr static const char*    STATUSBAR_TABS_TO_SPACES    = "Convert to spaces";
    constexpr static const char*    STATUSBAR_TAB_DEF_HARD      = "Default/Use tab";
    constexpr static const char*    STATUSBAR_TAB_DEF_SOFT      = "Default/Use spaces";
    constexpr static const char*    STATUSBAR_TAB_DEF_WIDTH1    = "Default/Tab width: 1";
    constexpr static const char*    STATUSBAR_TAB_DEF_WIDTH2    = "Default/Tab width: 2";
    constexpr static const char*    STATUSBAR_TAB_DEF_WIDTH3    = "Default/Tab width: 3";
    constexpr static const char*    STATUSBAR_TAB_DEF_WIDTH4    = "Default/Tab width: 4";
    constexpr static const char*    STATUSBAR_TAB_DEF_WIDTH5    = "Default/Tab width: 5";
    constexpr static const char*    STATUSBAR_TAB_DEF_WIDTH6    = "Default/Tab width: 6";
    constexpr static const char*    STATUSBAR_TAB_DEF_WIDTH7    = "Default/Tab width: 7";
    constexpr static const char*    STATUSBAR_TAB_DEF_WIDTH8    = "Default/Tab width: 8";
    constexpr static const char*    STATUSBAR_TAB_HARD          = "Use tab";
    constexpr static const char*    STATUSBAR_TAB_SOFT          = "Use spaces";
    constexpr static const char*    STATUSBAR_TAB_WIDTH1        = "Tab width: 1";
    constexpr static const char*    STATUSBAR_TAB_WIDTH2        = "Tab width: 2";
    constexpr static const char*    STATUSBAR_TAB_WIDTH3        = "Tab width: 3";
    constexpr static const char*    STATUSBAR_TAB_WIDTH4        = "Tab width: 4";
    constexpr static const char*    STATUSBAR_TAB_WIDTH5        = "Tab width: 5";
    constexpr static const char*    STATUSBAR_TAB_WIDTH6        = "Tab width: 6";
    constexpr static const char*    STATUSBAR_TAB_WIDTH7        = "Tab width: 7";
    constexpr static const char*    STATUSBAR_TAB_WIDTH8        = "Tab width: 8";
    constexpr static const char*    TOOLTIP_BINARY_FILE         = "You can load binary files with contents converted to hexadecimal.\nDue to increased memory usage max file size is 425MB.\nOr converted to some kind of text.\nIt will be opened as a unsaved unnamed document.";
    constexpr static const char*    TOOLTIP_FIND_CASE           = "Use case sensitive search (not for regex).";
    constexpr static const char*    TOOLTIP_FIND_JUMP           = "Jump between find and replace input field with alt+1/2.";
    constexpr static const char*    TOOLTIP_FIND_NL             = "Replace all \\n\\r\\t with actual ascii value in find string.";
    constexpr static const char*    TOOLTIP_FIND_REGEX          = "Use regular expression (PCRE) for search string.";
    constexpr static const char*    TOOLTIP_FIND_SELECTION      = "Replace only in selection.\nOnly valid for 'Replace all'!";
    constexpr static const char*    TOOLTIP_FIND_WORD           = "Find whole words only when searching (not for regex).";
    constexpr static const char*    TOOLTIP_REPLACE_NL          = "Replace all \\n\\r\\t with actual ascii value in replace string.";
    constexpr static const char*    TOOLTIP_REPLACE_REGEX       = "Enter replace text.\n"
                                                                  "\n"
                                                                  "Captures can be used for regular expression.\n"
                                                                  "Use $1 to $9.\n"
                                                                  "Example: search for \"(\\w+)\\s+(\\w+)\".\n"
                                                                  "And replace with \"$2 $1\" to swap two words.\n";
    constexpr static const char*    TOOLTIP_TEST_REGEX          = "Test if string can be compiled by pcre engine.";
}
class _AutoCompleteBrowser : public flw::ScrollBrowser {
    std::string                 _selected;
    std::string                 _input;
public:
    _AutoCompleteBrowser(int X, int Y, int W, int H) : flw::ScrollBrowser(X, Y, W, H) {
        callback(_AutoCompleteBrowser::Callback2, this);
    }
    static void Callback2(Fl_Widget*, void* o) {
        auto self = static_cast<_AutoCompleteBrowser*>(o);
        if (Fl::event_clicks() > 0) {
            Fl::event_clicks(0);
            if (self->value() > 0) {
                self->_selected = self->text(self->value());
                self->parent()->do_callback();
            }
        }
    }
    int handle(int event) override {
        if (event == FL_KEYDOWN) {
            auto key = Fl::event_key();
            if (key == FL_BackSpace) {
                if (_input.size() > 0) {
                    _input.pop_back();
                    find_word();
                }
                return 1;
            }
            else if (key == FL_Enter) {
                if (value() > 0) {
                    _selected = text(value());
                }
                parent()->do_callback();
                return 1;
            }
            else if (key == FL_Escape) {
                parent()->do_callback();
                return 1;
            }
            else if (key == FL_Left || key == FL_Right) {
                return 1;
            }
            else if (key == FL_Up || key == FL_Down) {
                return flw::ScrollBrowser::handle(event);
            }
            else {
                auto text = Fl::event_text();
                if (*text != 0) {
                    auto first = static_cast<unsigned char>(*text);
                    if (first >= 32) {
                        auto old = _input;
                        _input += text;
                        if (find_word() == false) {
                            _input = old;
                        }
                    }
                    return 1;
                }
            }
        }
        return flw::ScrollBrowser::handle(event);
    }
    bool find_word() {
        for (auto f = 1; f <= size(); f++) {
            auto w = std::string(text(f));
            if (w.find(_input) == 0) {
                value(f);
                topline((f > 1) ? f - 1 : 1);
                return true;
            }
        }
        return false;
    }
    int populate(const fle::StringSet& words, std::string word) {
        clear();
        _selected = "";
        _input = "";
        for (const auto& w : words) {
            if (word.size() == 0) {
                add(w.c_str());
            }
            else if (w.find(word) == 0) {
                add(w.c_str());
                if (_input == "") {
                    _input = word;
                }
            }
        }
        if (size() > 0) {
            value(1);
            topline(1);
        }
        return size();
    }
    std::string selected() {
        return _selected;
    }
};
AutoComplete::AutoComplete(const std::string& event) : Fl_Group(0, 0, 10, 10) {
    end();
    _event    = event;
    _word_pos = 0;
    _browser  = new _AutoCompleteBrowser(0, 0, 10, 10);
    _browser->box(FL_BORDER_BOX);
    add(_browser);
    resizable(_browser);
}
int AutoComplete::handle(int event) {
    if (event == FL_LEAVE) {
        do_callback();
        hide();
    }
    else if (event == FL_UNFOCUS && Fl::focus() != _browser) {
        do_callback();
        hide();
    }
    return Fl_Group::handle(event);
}
int AutoComplete::populate(Fl_Fontsize fontsize, const std::set<std::string>& words, const std::string& word, int word_pos) {
    auto browser = static_cast<_AutoCompleteBrowser*>(_browser);
    _word        = word;
    _word_pos    = word_pos;
    browser->update_pref(flw::PREF_FIXED_FONT, fontsize);
    return browser->populate(words, word);
}
void AutoComplete::popup(int X, int Y, int W, int H) {
    Fl_Group::resize(X, Y, W, H);
    _browser->resize(X, Y, W, H);
    Fl_Group::show();
}
std::string AutoComplete::selected() const {
    return static_cast<_AutoCompleteBrowser*>(_browser)->selected();
}
FindBar::FindBar(Config& config) :
Fl_Group(0, 0, 0, 0, ""),
_config(config) {
    end();
    clip_children(1);
    box(FL_FLAT_BOX);
    _findreplace = new FindReplace(_config);
    _statusbar   = new StatusBar(_config);
    add(_findreplace);
    add(_statusbar);
    FindBar::hide();
}
int FindBar::height() const {
    int res = 0;
    if (_config.pref_statusbar == true) {
        res += _statusbar->height();
    }
    if (_findreplace->visible() != 0) {
        res += FindReplace::Height();
        res += 1;
    }
    return res;
}
void FindBar::hide() {
    if (_config.pref_statusbar == false) {
        _statusbar->hide();
    }
    _findreplace->hide();
}
void FindBar::resize(int X, int Y, int W, int H) {
    Fl_Group::resize(X, Y, W, H);
    if (_findreplace->visible() != 0) {
        _findreplace->resize(X + 2, Y + 2, W - 4, FindReplace::Height());
    }
    if (_statusbar->visible() != 0) {
        _statusbar->resize(X + 2, Y + H - _statusbar->height(), W - 4, _statusbar->height());
    }
}
void FindBar::show() {
    if (_config.pref_statusbar == true) {
        _statusbar->show();
    }
    _findreplace->show();
}
void FindBar::update_pref() {
    _findreplace->update_pref();
    _statusbar->update_pref();
    if (_config.pref_statusbar == true) {
        _statusbar->show();
    }
    else  {
        _statusbar->hide();
    }
}
bool FindBar::visible() const {
    return _statusbar->visible() != 0 || _findreplace->visible() != 0;
}
FRegex FindDialog::REGEX = FRegex::NO;
FTrim  FindDialog::TRIM  = FTrim::NO;
FindDialog::FindDialog(const std::string& label, const std::vector<std::string>& find_list) :
Fl_Double_Window(0, 0, 10, 10) {
    end();
    _cancel  = new Fl_Button(0, 0, 0, 0, "&Cancel");
    _find    = new flw::InputMenu(0, 0, 0, 0, "Find");
    _grid    = new flw::GridGroup(0, 0, w(), h());
    _help    = new Fl_Button(0, 0, 0, 0, "&Help");
    _ok      = new Fl_Button(0, 0, 0, 0, "&Find");
    _regex   = new Fl_Check_Button(0, 0, 0, 0, "Rege&x");
    _test    = new Fl_Button(0, 0, 0, 0, "&Test");
    _trim    = new Fl_Check_Button(0, 0, 0, 0, "&Trim");
    _ret     = false;
    _run     = false;
    _grid->add(_find,     10,   1,  -1,   4, _find->input());
    _grid->add(_regex,    10,   6,  15,   4);
    _grid->add(_trim,     25,   6,  15,   4);
    _grid->add(_help,      1,   -5,  16,   4);
    _grid->add(_test,    -51,  -5,  16,   4);
    _grid->add(_cancel,  -34,  -5,  16,   4);
    _grid->add(_ok,      -17,  -5,  16,   4);
    add(_grid);
    _cancel->callback(FindDialog::Callback, this);
    _find->align(FL_ALIGN_LEFT);
    _find->callback(FindDialog::Callback, this);
    _find->values(find_list);
    _find->take_focus();
    _find->tooltip("Enter search string or regular expression.");
    _find->update_pref(flw::PREF_FIXED_FONT, flw::PREF_FONTSIZE);
    _help->callback(FindDialog::Callback, this);
    _ok->callback(FindDialog::Callback, this);
    _ok->tooltip("Search for text from all lines in current text.");
    _regex->callback(FindDialog::Callback, this);
    _regex->tooltip(widgets::TOOLTIP_FIND_REGEX);
    _regex->value(FindDialog::REGEX == FRegex::YES);
    _test->tooltip(widgets::TOOLTIP_TEST_REGEX);
    _test->callback(FindDialog::Callback, this);
    _trim->tooltip("Remove all whitespace from each end of found lines.");
    _trim->value(FindDialog::TRIM == FTrim::YES);
    FindDialog::Callback(_regex, this);
    flw::util::labelfont(this);
    copy_label(fle::APPLICATION != "" ? (fle::APPLICATION + " - " + label).c_str() : label.c_str());
    callback(FindDialog::Callback, this);
    set_modal();
    resizable(this);
    resize(0, 0, flw::PREF_FONTSIZE * 44, flw::PREF_FONTSIZE * 8);
}
void FindDialog::Callback(Fl_Widget* w, void* o) {
    auto* self = static_cast<FindDialog*>(o);
    if (w == self || w == self->_cancel) {
        self->_run = false;
        self->hide();
    }
    else if (w == self->_help) {
        flw::dlg::list("Find Lines Help", help::find_lines() + help::pcre(), true, 60, 40);
        self->_find->take_focus();
    }
    else if (w == self->_ok) {
        if (self->_regex->value() != 0 && self->test_pcre() == false) {
            self->_find->take_focus();
        }
        else {
            FindDialog::REGEX = (self->_regex->value() != 0) ? FRegex::YES : FRegex::NO;
            FindDialog::TRIM  = (self->_trim->value() != 0) ? FTrim::YES : FTrim::NO;
            self->_ret        = true;
            self->_run        = false;
            self->hide();
        }
    }
    else if (w == self->_regex) {
        if (self->_regex->value() != 0) {
            self->_test->activate();
        }
        else {
            self->_test->deactivate();
        }
    }
    else if (w == self->_test) {
        self->test_pcre();
        self->_find->take_focus();
    }
}
std::string FindDialog::run() {
    _run = true;
    flw::util::center_window(this, Fl::first_window());
    show();
    while (_run == true) {
        Fl::wait();
        Fl::flush();
    }
    return (_ret == true) ? _find->value() : "";
}
bool FindDialog::test_pcre() {
    std::string string = _find->value();
    if (flw::util::is_empty(string) == true) {
        flw::dlg::msg_alert("PCRE Error", "Empty string!");
        return false;
    }
    auto re = gnu::pcre8::PCRE(string);
    if (re.is_compiled() == false) {
        flw::dlg::msg_alert("PCRE Error", flw::util::format("Invalid PCRE expression!\n%s", re.err().c_str()));
        return false;
    }
    return true;
}
FindReplace::FindReplace(Config& config) :
flw::GridGroup(),
_config(config) {
    end();
    clip_children(1);
    _case          = new Fl_Check_Button(0, 0, 0, 0, "&Case");
    _find_input    = new flw::InputMenu(0, 0, 0, 0, "Find:");
    _find_next     = new Fl_Repeat_Button(0, 0, 0, 0, "&Find");
    _find_nl       = new Fl_Check_Button(0, 0, 0, 0, widgets::BUTTON_NL);
    _find_prev     = new Fl_Repeat_Button(0, 0, 0, 0, "Find &Prev");
    _regex         = new Fl_Check_Button(0, 0, 0, 0, "Rege&x");
    _replace       = new Fl_Repeat_Button(0, 0, 0, 0, "&Replace");
    _replace_all   = new Fl_Button(0, 0, 0, 0, "Replace &All");
    _replace_input = new flw::InputMenu(0, 0, 0, 0, "Replace:");
    _replace_nl    = new Fl_Check_Button(0, 0, 0, 0, widgets::BUTTON_NL);
    _selection     = new Fl_Check_Button(0, 0, 0, 0, "&Selection");
    _word          = new Fl_Check_Button(0, 0, 0, 0, "&Word");
    add(_find_input,     10, -10, -67,   4, _find_input->input());
    add(_replace_input,  10,  -5, -67,   4, _replace_input->input());
    add(_find_nl,       -66, -10,   8,   4);
    add(_replace_nl,    -66,  -5,   8,   4);
    add(_case,          -58, -10,  10,   4);
    add(_word,          -58,  -5,  10,   4);
    add(_selection,     -48, -10,  13,   4);
    add(_regex,         -48,  -5,  13,   4);
    add(_find_next,     -34, -10,  16,   4);
    add(_find_prev,     -34,  -5,  16,   4);
    add(_replace,       -17, -10,  16,   4);
    add(_replace_all,   -17,  -5,  16,   4);
    _case->tooltip(widgets::TOOLTIP_FIND_CASE);
    _find_input->align(FL_ALIGN_LEFT);
    _find_input->tooltip("Enter search string or regular expression.");
    _find_next->tooltip("Find next word.");
    _find_nl->tooltip(widgets::TOOLTIP_FIND_NL);
    _find_prev->tooltip("Find previous word.");
    _regex->callback(FindReplace::CallbackCheckButton, this);
    _regex->tooltip(widgets::TOOLTIP_FIND_REGEX);
    _replace->tooltip("Find text before replacing it.\n");
    _replace_all->tooltip(
        "Replace all found search strings.\n"
        "Only find text can have regular expression."
    );
    _replace_input->align(FL_ALIGN_LEFT);
    _replace_input->tooltip(widgets::TOOLTIP_REPLACE_REGEX);
    _replace_nl->tooltip(widgets::TOOLTIP_REPLACE_NL);
    _selection->callback(FindReplace::CallbackCheckButton, this);
    _selection->tooltip(widgets::TOOLTIP_FIND_SELECTION);
    _word->tooltip(widgets::TOOLTIP_FIND_WORD);
    box(FL_BORDER_BOX);
    color(FL_BACKGROUND_COLOR);
    tooltip(widgets::TOOLTIP_FIND_JUMP);
}
void FindReplace::add_find_word(std::string word) {
    if (_config.add_find_word(word) == true) {
        update_lists(true, false, 0);
    }
}
void FindReplace::add_replace_word(std::string word) {
    if (_config.add_replace_word(word) == true) {
        update_lists(false, true, 0);
    }
}
void FindReplace::CallbackCheckButton(Fl_Widget*, void* o) {
    auto self = static_cast<FindReplace*>(o);
    self->enable_buttons();
}
void FindReplace::callback(Fl_Callback* cb, void* obj) {
    _find_input->callback(cb, obj);
    _find_next->callback(cb, obj);
    _find_prev->callback(cb, obj);
    _replace->callback(cb, obj);
    _replace_all->callback(cb, obj);
    _replace_input->callback(cb, obj);
}
void FindReplace::enable_buttons() {
    _case->activate();
    _find_next->activate();
    _find_nl->activate();
    _find_prev->activate();
    _regex->activate();
    _replace->activate();
    _replace_all->activate();
    _replace_nl->activate();
    _selection->activate();
    _word->activate();
    if (_regex->value() != 0) {
        _case->deactivate();
        _find_nl->deactivate();
        _find_prev->deactivate();
        _word->deactivate();
    }
    if (_selection->value() != 0) {
        _find_next->deactivate();
        _find_prev->deactivate();
        _replace->deactivate();
    }
}
FNlTab FindReplace::fnltab() const {
    bool f = _regex->value() == 0 && _find_nl->value() != 0;
    bool r = _replace_nl->value() != 0;
    if (f == true && r == true) {
        return FNlTab::YES;
    }
    else if (f == true) {
        return FNlTab::FIND;
    }
    else if (r == true) {
        return FNlTab::REPLACE;
    }
    else {
        return FNlTab::NO;
    }
}
void FindReplace::fnltab(FNlTab fnltab) {
    _find_nl->value(0);
    _replace_nl->value(0);
    if (fnltab == FNlTab::YES) {
        _find_nl->value(1);
        _replace_nl->value(1);
    }
    else if (fnltab == FNlTab::FIND) {
        _find_nl->value(1);
    }
    else if (fnltab == FNlTab::REPLACE) {
        _replace_nl->value(1);
    }
}
int FindReplace::handle(int event) {
    if (event == FL_KEYBOARD) {
        if (Fl::event_key() == FL_Escape) {
            _config.send_message(message::HIDE_FIND, "", "", this);
        }
        else if (Fl::event_alt() != 0 && Fl::event_key() == '1') {
            Fl::focus(_find_input->input());
            redraw();
            return 1;
        }
        else if (Fl::event_alt() != 0 && Fl::event_key() == '2') {
            Fl::focus(_replace_input->input());
            redraw();
            return 1;
        }
    }
    return GridGroup::handle(event);
}
void FindReplace::resize(int X, int Y, int W, int H) {
    flw::GridGroup::resize(X, Y, W, H);
    enable_buttons();
}
void FindReplace::show() {
    Fl_Group::show();
    take_focus();
}
void FindReplace::take_focus() {
    _find_input->input()->take_focus();
    _find_input->input()->insert_position(_find_input->input()->size(), 0);
}
void FindReplace::update_lists(bool find, bool replace, size_t set) {
    if (find == true) {
        _find_input->values(_config.find_list, set);
    }
    if (replace == true) {
        _replace_input->values(_config.replace_list, set);
    }
}
void FindReplace::update_pref() {
    _find_input->update_pref(flw::PREF_FIXED_FONT, flw::PREF_FONTSIZE);
    _replace_input->update_pref(flw::PREF_FIXED_FONT, flw::PREF_FONTSIZE);
    flw::util::labelfont(this);
}
GotoLine::GotoLine() : Fl_Int_Input(0, 0, 10, 10) {
    box(FL_BORDER_BOX);
    when(FL_WHEN_ENTER_KEY_ALWAYS);
    maximum_size(9);
}
int GotoLine::handle(int event) {
    if (event == FL_UNFOCUS || event == FL_LEAVE) {
        hide();
    }
    else if (event == FL_KEYBOARD) {
        if (Fl::event_key() == FL_Escape) {
            hide();
        }
    }
    return Fl_Int_Input::handle(event);
}
int GotoLine::line() const {
    return atoi(value());
}
void GotoLine::popup(int fs, int X, int Y, int W, int H) {
    resize(X, Y, W, H);
    textfont(flw::PREF_FIXED_FONT);
    textsize(fs);
    insert_position(0, 9);
    show();
}
FCaseCompare ReplaceDialog::CASECOMPARE = FCaseCompare::NO;
FNlTab       ReplaceDialog::NLTAB       = FNlTab::NO;
FRegex       ReplaceDialog::REGEX       = FRegex::NO;
FSelection   ReplaceDialog::SELECTION   = FSelection::NO;
FWordCompare ReplaceDialog::WORDCOMPARE = FWordCompare::NO;
ReplaceDialog::ReplaceDialog(const std::string& label, std::string& find, std::string& replace, const std::vector<std::string>& find_list, const std::vector<std::string>& replace_list) :
Fl_Double_Window(0, 0, 10, 10),
_find(find),
_replace(replace) {
    end();
    _cancel        = new Fl_Button(0, 0, 0, 0, flw::label::CANCEL.c_str());
    _case          = new Fl_Check_Button(0, 0, 0, 0, "C&ase");
    _find_input    = new flw::InputMenu(0, 0, 0, 0, "Find");
    _find_nl       = new Fl_Check_Button(0, 0, 0, 0, widgets::BUTTON_NL);
    _grid          = new flw::GridGroup(0, 0, w(), h());
    _help          = new Fl_Button(0, 0, 0, 0, "&Help");
    _ok            = new Fl_Button(0, 0, 0, 0, "Replace &All");
    _regex         = new Fl_Check_Button(0, 0, 0, 0, "Rege&x");
    _replace_input = new flw::InputMenu(0, 0, 0, 0, "Replace");
    _replace_nl    = new Fl_Check_Button(0, 0, 0, 0, widgets::BUTTON_NL);
    _selection     = new Fl_Check_Button(0, 0, 0, 0, "&Selection");
    _test          = new Fl_Button(0, 0, 0, 0, "&Test");
    _word          = new Fl_Check_Button(0, 0, 0, 0, "&Word");
    _ret           = false;
    _run           = false;
    _grid->add(_find_input,     10,   1,  -8,   4, _find_input->input());
    _grid->add(_find_nl,        -7,   1,   6,   4);
    _grid->add(_replace_input,  10,   6,  -8,   4, _replace_input->input());
    _grid->add(_replace_nl,     -7,   6,   6,   4);
    _grid->add(_case,           10,  11,  15,   4);
    _grid->add(_word,           25,  11,  15,   4);
    _grid->add(_selection,      40,  11,  15,   4);
    _grid->add(_regex,          55,  11,  15,   4);
    _grid->add(_help,            1,  -5,  16,   4);
    _grid->add(_cancel,        -51,  -5,  16,   4);
    _grid->add(_test,          -34,  -5,  16,   4);
    _grid->add(_ok,            -17,  -5,  16,   4);
    add(_grid);
    _cancel->callback(ReplaceDialog::Callback, this);
    _case->tooltip(widgets::TOOLTIP_FIND_CASE);
    _case->value(ReplaceDialog::CASECOMPARE == FCaseCompare::YES);
    _find_input->align(FL_ALIGN_LEFT);
    _find_input->values(find_list);
    _find_input->take_focus();
    _find_input->tooltip("Enter search string or regular expression.");
    _find_input->update_pref(flw::PREF_FIXED_FONT, flw::PREF_FONTSIZE);
    _find_nl->tooltip(widgets::TOOLTIP_FIND_NL);
    _find_nl->value(ReplaceDialog::NLTAB == FNlTab::YES || ReplaceDialog::NLTAB == FNlTab::FIND);
    _help->callback(ReplaceDialog::Callback, this);
    _ok->callback(ReplaceDialog::Callback, this);
    _regex->callback(ReplaceDialog::Callback, this);
    _regex->tooltip(widgets::TOOLTIP_FIND_REGEX);
    _regex->value(ReplaceDialog::REGEX == FRegex::YES);
    _replace_input->align(FL_ALIGN_LEFT);
    _replace_input->values(replace_list);
    _replace_input->update_pref(flw::PREF_FIXED_FONT, flw::PREF_FONTSIZE);
    _replace_input->tooltip(widgets::TOOLTIP_REPLACE_REGEX);
    _replace_nl->tooltip(widgets::TOOLTIP_REPLACE_NL);
    _replace_nl->value(ReplaceDialog::NLTAB == FNlTab::YES || ReplaceDialog::NLTAB == FNlTab::REPLACE);
    _selection->callback(ReplaceDialog::Callback, this);
    _selection->tooltip(widgets::TOOLTIP_FIND_SELECTION);
    _selection->value(ReplaceDialog::SELECTION == FSelection::YES);
    _test->tooltip(widgets::TOOLTIP_TEST_REGEX);
    _test->callback(ReplaceDialog::Callback, this);
    _word->tooltip(widgets::TOOLTIP_FIND_WORD);
    _word->value(ReplaceDialog::WORDCOMPARE == FWordCompare::YES);
    tooltip(widgets::TOOLTIP_FIND_JUMP);
    check_buttons();
    flw::util::labelfont(this);
    copy_label(fle::APPLICATION != "" ? (fle::APPLICATION + " - " + label).c_str() : label.c_str());
    callback(ReplaceDialog::Callback, this);
    set_modal();
    resizable(_grid);
    ReplaceDialog::resize(0, 0, flw::PREF_FONTSIZE * 48, flw::PREF_FONTSIZE * 10.5);
}
void ReplaceDialog::Callback(Fl_Widget* w, void* o) {
    auto* self = static_cast<ReplaceDialog*>(o);
    if (w == self || w == self->_cancel) {
        self->_run = false;
        self->hide();
    }
    else if (w == self->_help) {
        flw::dlg::list("Replace Text Help", help::replace_text() + help::pcre(), true, 60, 50);
    }
    else if (w == self->_regex || w == self->_selection) {
        self->check_buttons();
    }
    else if (w == self->_test) {
        self->test_pcre();
    }
    else if (w == self->_ok && self->_find_input->value() != "") {
        if (self->_regex->value() != 0 && self->test_pcre() == false) {
            self->_find_input->take_focus();
        }
        else {
            self->_find    = self->_find_input->value();
            self->_replace = self->_replace_input->value();
            self->_ret     = true;
            self->_run     = false;
            bool f = self->_regex->value() == 0 && self->_find_nl->value() != 0;
            bool r = self->_replace_nl->value() != 0;
            if (f == true && r == true) {
                ReplaceDialog::NLTAB = FNlTab::YES;
            }
            else if (f == true) {
                ReplaceDialog::NLTAB = FNlTab::FIND;
            }
            else if (r == true) {
                ReplaceDialog::NLTAB = FNlTab::REPLACE;
            }
            else {
                ReplaceDialog::NLTAB = FNlTab::NO;
            }
            ReplaceDialog::CASECOMPARE = (self->_case->value() != 0 && self->_case->active() != 0) ? FCaseCompare::YES : FCaseCompare::NO;
            ReplaceDialog::REGEX       = (self->_regex->value() != 0 && self->_regex->active() != 0) ? FRegex::YES : FRegex::NO;
            ReplaceDialog::SELECTION   = (self->_selection->value() != 0 && self->_selection->active() != 0) ? FSelection::YES : FSelection::NO;
            ReplaceDialog::WORDCOMPARE = (self->_word->value() != 0 && self->_word->active() != 0) ? FWordCompare::YES : FWordCompare::NO;
            self->hide();
        }
    }
}
void ReplaceDialog::check_buttons() {
    if (_regex->value() != 0) {
        _test->activate();
        _case->deactivate();
        _find_nl->deactivate();
        _word->deactivate();
    }
    else {
        _test->deactivate();
        _case->activate();
        _find_nl->activate();
        _word->activate();
    }
}
int ReplaceDialog::handle(int event) {
    if (event == FL_KEYBOARD) {
        if (Fl::event_alt() != 0 && Fl::event_key() == '1') {
            Fl::focus(_find_input->input());
            redraw();
            return 1;
        }
        else if (Fl::event_alt() != 0 && Fl::event_key() == '2') {
            Fl::focus(_replace_input->input());
            redraw();
            return 1;
        }
    }
    return Fl_Double_Window::handle(event);
}
bool ReplaceDialog::run() {
    _run = true;
    flw::util::center_window(this, Fl::first_window());
    show();
    while (_run == true) {
        Fl::wait();
        Fl::flush();
    }
    return _ret;
}
bool ReplaceDialog::test_pcre() {
    std::string string = _find_input->value();
    if (flw::util::is_empty(string) == true) {
       flw::dlg::msg_alert("PCRE Error", "Empty string!");
        return false;
    }
    auto re = gnu::pcre8::PCRE(string);
    if (re.is_compiled() == false) {
        flw::dlg::msg_alert("PCRE Error", flw::util::format("Invalid PCRE expression!\n%s", re.err().c_str()));
        return false;
    }
    return true;
}
#define FLE_STATUSBAR_CB(X) [](Fl_Widget*, void* o) { static_cast<StatusBar*>(o)->X; }, this
StatusBar::StatusBar(Config& config) :
flw::GridGroup(),
_config(config)  {
    _label_cursor      = new Fl_Box(0, 0, 0, 0, "");
    _label_cursor_mode = new Fl_Box(0, 0, 0, 0, "");
    _label_message     = new Fl_Box(0, 0, 0, 0, "");
    _line_menu         = new Fl_Menu_Button(0, 0, 0, 0, "");
    _style_menu        = new Fl_Menu_Button(0, 0, 0, 0, "");
    _tab_menu          = new Fl_Menu_Button(0, 0, 0, 0, "");
    add(_label_cursor,        0,   0,  46,   0);
    add(_label_message,      46,   0, -50,   0);
    add(_label_cursor_mode, -50,   0,   6,   0);
    add(_tab_menu,          -44,   0,  16,   0);
    add(_style_menu,        -28,   0,  16,   0);
    add(_line_menu,         -12,   0,  12,   0);
    adjust(_label_cursor_mode, -1,   1,   0,   0);
    adjust(_label_message,     -1,   1,   0,   0);
    adjust(_line_menu,         -1,   1,   0,   0);
    adjust(_style_menu,        -1,   1,   0,   0);
    adjust(_tab_menu,          -1,   1,   0,   0);
    _label_cursor_mode->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE | FL_ALIGN_CLIP);
    _label_cursor_mode->box(FL_BORDER_BOX);
    _label_cursor_mode->tooltip("Current cursor mode, insert or overwrite.");
    _label_cursor->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE | FL_ALIGN_CLIP);
    _label_cursor->box(FL_BORDER_BOX);
    _label_cursor->tooltip("Cursor pos and text selection.");
    _label_message->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE | FL_ALIGN_CLIP);
    _label_message->box(FL_BORDER_BOX);
    _label_message->tooltip("General messages are shown here.");
    _line_menu->box(FL_BORDER_BOX);
    _line_menu->tooltip("Set lineending that will be used when saving file.");
    _style_menu->box(FL_BORDER_BOX);
    _style_menu->tooltip(
        "Select language for current text.\n"
        "Or text to disable all syntax highlightning."
    );
    _tab_menu->box(FL_BORDER_BOX);
    _tab_menu->tooltip(
        "Set tab width and mode for current text.\n"
        "Or change the default tab values (for current syntax).\n"
        "Default values will be used next time a file is loaded.\n"
        "You can also convert to/from spaces/tabs.\n"
    );
    box(FL_FLAT_BOX);
    _line_menu->add(widgets::STATUSBAR_LINE_UNIX,       0, FLE_STATUSBAR_CB(callback_line()), FL_MENU_RADIO);
    _line_menu->add(widgets::STATUSBAR_LINE_WIN,        0, FLE_STATUSBAR_CB(callback_line()), FL_MENU_RADIO);
    _style_menu->add(style::CPP.c_str(),                0, FLE_STATUSBAR_CB(callback_syntax()), FL_MENU_RADIO);
    _style_menu->add(style::LUA.c_str(),                0, FLE_STATUSBAR_CB(callback_syntax()), FL_MENU_RADIO);
    _style_menu->add(style::PYTHON.c_str(),             0, FLE_STATUSBAR_CB(callback_syntax()), FL_MENU_RADIO);
    _style_menu->add(style::RUBY.c_str(),               0, FLE_STATUSBAR_CB(callback_syntax()), FL_MENU_RADIO);
    _style_menu->add(style::GO.c_str(),                 0, FLE_STATUSBAR_CB(callback_syntax()), FL_MENU_RADIO);
    _style_menu->add(style::RUST.c_str(),               0, FLE_STATUSBAR_CB(callback_syntax()), FL_MENU_RADIO);
    _style_menu->add(style::KOTLIN.c_str(),             0, FLE_STATUSBAR_CB(callback_syntax()), FL_MENU_RADIO);
    _style_menu->add(style::JAVA.c_str(),               0, FLE_STATUSBAR_CB(callback_syntax()), FL_MENU_RADIO);
    _style_menu->add(style::CS.c_str(),                 0, FLE_STATUSBAR_CB(callback_syntax()), FL_MENU_RADIO);
    _style_menu->add(style::JS.c_str(),                 0, FLE_STATUSBAR_CB(callback_syntax()), FL_MENU_RADIO);
    _style_menu->add(style::TS.c_str(),                 0, FLE_STATUSBAR_CB(callback_syntax()), FL_MENU_RADIO);
    _style_menu->add(style::PHP.c_str(),                0, FLE_STATUSBAR_CB(callback_syntax()), FL_MENU_RADIO);
    _style_menu->add(style::MARKUP.c_str(),             0, FLE_STATUSBAR_CB(callback_syntax()), FL_MENU_RADIO);
    _style_menu->add(style::MAKEFILE.c_str(),           0, FLE_STATUSBAR_CB(callback_syntax()), FL_MENU_RADIO);
    _style_menu->add(style::SHELL.c_str(),              0, FLE_STATUSBAR_CB(callback_syntax()), FL_MENU_RADIO);
    _style_menu->add(style::BAT.c_str(),                0, FLE_STATUSBAR_CB(callback_syntax()), FL_MENU_RADIO);
    _style_menu->add(style::TEXT.c_str(),               0, FLE_STATUSBAR_CB(callback_syntax()), FL_MENU_RADIO);
    _tab_menu->add(widgets::STATUSBAR_TAB_HARD,         0, FLE_STATUSBAR_CB(callback_tab()), FL_MENU_RADIO);
    _tab_menu->add(widgets::STATUSBAR_TAB_SOFT,         0, FLE_STATUSBAR_CB(callback_tab()), FL_MENU_RADIO | FL_MENU_DIVIDER);
    _tab_menu->add(widgets::STATUSBAR_TABS_TO_SPACES,   0, FLE_STATUSBAR_CB(callback_tab()));
    _tab_menu->add(widgets::STATUSBAR_SPACES_TO_TABS,   0, FLE_STATUSBAR_CB(callback_tab()), FL_MENU_DIVIDER);
    _tab_menu->add(widgets::STATUSBAR_TAB_WIDTH1,       0, FLE_STATUSBAR_CB(callback_tab()), FL_MENU_RADIO);
    _tab_menu->add(widgets::STATUSBAR_TAB_WIDTH2,       0, FLE_STATUSBAR_CB(callback_tab()), FL_MENU_RADIO);
    _tab_menu->add(widgets::STATUSBAR_TAB_WIDTH3,       0, FLE_STATUSBAR_CB(callback_tab()), FL_MENU_RADIO);
    _tab_menu->add(widgets::STATUSBAR_TAB_WIDTH4,       0, FLE_STATUSBAR_CB(callback_tab()), FL_MENU_RADIO);
    _tab_menu->add(widgets::STATUSBAR_TAB_WIDTH5,       0, FLE_STATUSBAR_CB(callback_tab()), FL_MENU_RADIO);
    _tab_menu->add(widgets::STATUSBAR_TAB_WIDTH6,       0, FLE_STATUSBAR_CB(callback_tab()), FL_MENU_RADIO);
    _tab_menu->add(widgets::STATUSBAR_TAB_WIDTH7,       0, FLE_STATUSBAR_CB(callback_tab()), FL_MENU_RADIO);
    _tab_menu->add(widgets::STATUSBAR_TAB_WIDTH8,       0, FLE_STATUSBAR_CB(callback_tab()), FL_MENU_RADIO | FL_MENU_DIVIDER);
    _tab_menu->add(widgets::STATUSBAR_TAB_DEF_HARD,     0, FLE_STATUSBAR_CB(callback_tab_def()), FL_MENU_RADIO);
    _tab_menu->add(widgets::STATUSBAR_TAB_DEF_SOFT,     0, FLE_STATUSBAR_CB(callback_tab_def()), FL_MENU_RADIO | FL_MENU_DIVIDER);
    _tab_menu->add(widgets::STATUSBAR_TAB_DEF_WIDTH1,   0, FLE_STATUSBAR_CB(callback_tab_def()), FL_MENU_RADIO);
    _tab_menu->add(widgets::STATUSBAR_TAB_DEF_WIDTH2,   0, FLE_STATUSBAR_CB(callback_tab_def()), FL_MENU_RADIO);
    _tab_menu->add(widgets::STATUSBAR_TAB_DEF_WIDTH3,   0, FLE_STATUSBAR_CB(callback_tab_def()), FL_MENU_RADIO);
    _tab_menu->add(widgets::STATUSBAR_TAB_DEF_WIDTH4,   0, FLE_STATUSBAR_CB(callback_tab_def()), FL_MENU_RADIO);
    _tab_menu->add(widgets::STATUSBAR_TAB_DEF_WIDTH5,   0, FLE_STATUSBAR_CB(callback_tab_def()), FL_MENU_RADIO);
    _tab_menu->add(widgets::STATUSBAR_TAB_DEF_WIDTH6,   0, FLE_STATUSBAR_CB(callback_tab_def()), FL_MENU_RADIO);
    _tab_menu->add(widgets::STATUSBAR_TAB_DEF_WIDTH7,   0, FLE_STATUSBAR_CB(callback_tab_def()), FL_MENU_RADIO);
    _tab_menu->add(widgets::STATUSBAR_TAB_DEF_WIDTH8,   0, FLE_STATUSBAR_CB(callback_tab_def()), FL_MENU_RADIO);
    if (_config.disable_lineending == true) {
        _line_menu->deactivate();
    }
    if (_config.disable_style == true) {
        _style_menu->deactivate();
    }
    if (_config.disable_tab == true) {
        _tab_menu->deactivate();
    }
    update_pref();
}
void StatusBar::callback_line() {
    std::string label = _line_menu->text();
    if (label == widgets::STATUSBAR_LINE_WIN) {
        _config.send_message(message::STATUSBAR_LINE_WIN);
    }
    else if (label == widgets::STATUSBAR_LINE_UNIX) {
        _config.send_message(message::STATUSBAR_LINE_UNIX);
    }
}
void StatusBar::callback_syntax() {
    std::string label = _style_menu->text();
    if (label == style::BAT) {
        _config.send_message(message::STATUSBAR_STYLE_CHANGED, style::BAT);
    }
    else if (label == style::CPP) {
        _config.send_message(message::STATUSBAR_STYLE_CHANGED, style::CPP);
    }
    else if (label == style::CS) {
        _config.send_message(message::STATUSBAR_STYLE_CHANGED, style::CS);
    }
    else if (label == style::GO) {
        _config.send_message(message::STATUSBAR_STYLE_CHANGED, style::GO);
    }
    else if (label == style::MARKUP) {
        _config.send_message(message::STATUSBAR_STYLE_CHANGED, style::MARKUP);
    }
    else if (label == style::JAVA) {
        _config.send_message(message::STATUSBAR_STYLE_CHANGED, style::JAVA);
    }
    else if (label == style::JS) {
        _config.send_message(message::STATUSBAR_STYLE_CHANGED, style::JS);
    }
    else if (label == style::KOTLIN) {
        _config.send_message(message::STATUSBAR_STYLE_CHANGED, style::KOTLIN);
    }
    else if (label == style::LUA) {
        _config.send_message(message::STATUSBAR_STYLE_CHANGED, style::LUA);
    }
    else if (label == style::MAKEFILE) {
        _config.send_message(message::STATUSBAR_STYLE_CHANGED, style::MAKEFILE);
    }
    else if (label == style::SHELL) {
        _config.send_message(message::STATUSBAR_STYLE_CHANGED, style::SHELL);
    }
    else if (label == style::PHP) {
        _config.send_message(message::STATUSBAR_STYLE_CHANGED, style::PHP);
    }
    else if (label == style::PYTHON) {
        _config.send_message(message::STATUSBAR_STYLE_CHANGED, style::PYTHON);
    }
    else if (label == style::RUBY) {
        _config.send_message(message::STATUSBAR_STYLE_CHANGED, style::RUBY);
    }
    else if (label == style::RUST) {
        _config.send_message(message::STATUSBAR_STYLE_CHANGED, style::RUST);
    }
    else if (label == style::TEXT) {
        _config.send_message(message::STATUSBAR_STYLE_CHANGED, style::TEXT);
    }
    else if (label == style::TS) {
        _config.send_message(message::STATUSBAR_STYLE_CHANGED, style::TS);
    }
}
void StatusBar::callback_tab() {
    std::string label = _tab_menu->text();
    std::string name  = _style_menu->label();
    if (label == widgets::STATUSBAR_TAB_HARD) {
        _config.send_message(message::STATUSBAR_TAB_CHANGED, "FTab::HARD");
    }
    else if (label == widgets::STATUSBAR_TAB_SOFT) {
        _config.send_message(message::STATUSBAR_TAB_CHANGED, "FTab::SOFT");
    }
    else if (label == widgets::STATUSBAR_SPACES_TO_TABS) {
        _config.send_message(message::STATUSBAR_TO_TABS, "TO_TABS");
        _config.send_message(message::STATUSBAR_TAB_CHANGED, "FTab::HARD");
    }
    else if (label == widgets::STATUSBAR_TABS_TO_SPACES) {
        _config.send_message(message::STATUSBAR_TO_SPACES, "TO_SPACES");
        _config.send_message(message::STATUSBAR_TAB_CHANGED, "FTab::SOFT");
    }
    else if (label == widgets::STATUSBAR_TAB_WIDTH1) {
        _config.send_message(message::STATUSBAR_TAB_CHANGED, "1");
    }
    else if (label == widgets::STATUSBAR_TAB_WIDTH2) {
        _config.send_message(message::STATUSBAR_TAB_CHANGED, "2");
    }
    else if (label == widgets::STATUSBAR_TAB_WIDTH3) {
        _config.send_message(message::STATUSBAR_TAB_CHANGED, "3");
    }
    else if (label == widgets::STATUSBAR_TAB_WIDTH4) {
        _config.send_message(message::STATUSBAR_TAB_CHANGED, "4");
    }
    else if (label == widgets::STATUSBAR_TAB_WIDTH5) {
        _config.send_message(message::STATUSBAR_TAB_CHANGED, "5");
    }
    else if (label == widgets::STATUSBAR_TAB_WIDTH6) {
        _config.send_message(message::STATUSBAR_TAB_CHANGED, "6");
    }
    else if (label == widgets::STATUSBAR_TAB_WIDTH7) {
        _config.send_message(message::STATUSBAR_TAB_CHANGED, "7");
    }
    else if (label == widgets::STATUSBAR_TAB_WIDTH8) {
        _config.send_message(message::STATUSBAR_TAB_CHANGED, "8");
    }
}
void StatusBar::callback_tab_def() {
    std::string label = _tab_menu->text();
    std::string name  = _style_menu->label();
    if (label == widgets::STATUSBAR_TAB_HARD) {
        _config.tab_mode(name, FTab::HARD);
    }
    else if (label == widgets::STATUSBAR_TAB_SOFT) {
        _config.tab_mode(name, FTab::SOFT);
    }
    else if (label == widgets::STATUSBAR_TAB_WIDTH1) {
        _config.tab_width(name, 1);
    }
    else if (label == widgets::STATUSBAR_TAB_WIDTH2) {
        _config.tab_width(name, 2);
    }
    else if (label == widgets::STATUSBAR_TAB_WIDTH3) {
        _config.tab_width(name, 3);
    }
    else if (label == widgets::STATUSBAR_TAB_WIDTH4) {
        _config.tab_width(name, 4);
    }
    else if (label == widgets::STATUSBAR_TAB_WIDTH5) {
        _config.tab_width(name, 5);
    }
    else if (label == widgets::STATUSBAR_TAB_WIDTH6) {
        _config.tab_width(name, 6);
    }
    else if (label == widgets::STATUSBAR_TAB_WIDTH7) {
        _config.tab_width(name, 7);
    }
    else if (label == widgets::STATUSBAR_TAB_WIDTH8) {
        _config.tab_width(name, 8);
    }
}
bool StatusBar::label_cursor(std::string val) {
    if (val == _label_cursor->label()) {
        return false;
    }
    _label_cursor->copy_label(val.c_str());
    _label_cursor->redraw();
    return true;
}
bool StatusBar::label_cursor_mode(std::string val) {
    if (_config.pref_insert == false) {
        _label_cursor_mode->deactivate();
    }
    else {
        _label_cursor_mode->activate();
    }
    if (val == _label_cursor_mode->label()) {
        return false;
    }
    _label_cursor_mode->copy_label(val.c_str());
    _label_cursor_mode->redraw();
    return true;
}
bool StatusBar::label_message(std::string val) {
    val = gnu::str::replace(val, "@", "@@");
    if (val == _label_message->label()) {
        return false;
    }
    _label_message->copy_label(val.c_str());
    _label_message->redraw();
    return true;
}
void StatusBar::update_menus(Editor* editor) {
    {
        if (editor->file_line_ending() == FLineEnding::WINDOWS) {
            _line_menu->copy_label(widgets::STATUSBAR_LINE_WIN);
            flw::menu::setonly_item(_line_menu, widgets::STATUSBAR_LINE_WIN);
        }
        else {
            _line_menu->copy_label(widgets::STATUSBAR_LINE_UNIX);
            flw::menu::setonly_item(_line_menu, widgets::STATUSBAR_LINE_UNIX);
        }
    }
    {
        auto tab_mode    = editor->text_tab_mode();
        auto tab_width   = editor->text_tab_width();
        auto label_width = gnu::str::format("Tab width: %u", tab_width);
        auto label_mode  = (tab_mode == FTab::HARD) ? widgets::STATUSBAR_TAB_HARD : widgets::STATUSBAR_TAB_SOFT;
        flw::menu::setonly_item(_tab_menu, label_mode);
        flw::menu::setonly_item(_tab_menu, label_width.c_str());
        _tab_menu->copy_label(gnu::str::format("%s: %u", (tab_mode == FTab::HARD) ? "Tab size" : "Spaces", tab_width).c_str());
    }
    {
        auto tab_mode    = _config.tab_mode(editor->style().name());
        auto tab_width   = _config.tab_width(editor->style().name());
        auto label_width = gnu::str::format("Default/Tab width: %u", tab_width);
        auto label_mode  = (tab_mode == FTab::HARD) ? widgets::STATUSBAR_TAB_DEF_HARD : widgets::STATUSBAR_TAB_DEF_SOFT;
        flw::menu::setonly_item(_tab_menu, label_mode);
        flw::menu::setonly_item(_tab_menu, label_width.c_str());
    }
    {
        auto style_name = editor->style().name();
        flw::menu::setonly_item(_style_menu, style_name.c_str());
        _style_menu->copy_label(style_name.c_str());
    }
}
void StatusBar::update_pref() {
    _style_menu->labelfont(flw::PREF_FONT);
    _style_menu->labelsize(flw::PREF_FONTSIZE - _config.pref_shrink_status);
    _style_menu->textfont(flw::PREF_FONT);
    _style_menu->textsize(flw::PREF_FONTSIZE - _config.pref_shrink_status);
    _tab_menu->labelfont(flw::PREF_FONT);
    _tab_menu->labelsize(flw::PREF_FONTSIZE - _config.pref_shrink_status);
    _tab_menu->textfont(flw::PREF_FONT);
    _tab_menu->textsize(flw::PREF_FONTSIZE - _config.pref_shrink_status);
    _line_menu->labelfont(flw::PREF_FONT);
    _line_menu->labelsize(flw::PREF_FONTSIZE - _config.pref_shrink_status);
    _line_menu->textfont(flw::PREF_FONT);
    _line_menu->textsize(flw::PREF_FONTSIZE - _config.pref_shrink_status);
    _label_cursor_mode->labelfont(flw::PREF_FONT);
    _label_cursor_mode->labelsize(flw::PREF_FONTSIZE - _config.pref_shrink_status);
    _label_cursor->labelfont(flw::PREF_FONT);
    _label_cursor->labelsize(flw::PREF_FONTSIZE - _config.pref_shrink_status);
    _label_message->labelfont(flw::PREF_FONT);
    _label_message->labelsize(flw::PREF_FONTSIZE - _config.pref_shrink_status);
    _h = flw::PREF_FONTSIZE + 8;
}
}
#include <FL/Fl_Color_Chooser.H>
#include <FL/Fl_Hor_Slider.H>
#include <FL/Fl_Scroll.H>
namespace fle {
namespace widgets2 {
    constexpr static const char*    CONFIG_BINARY_HEX_16        = "Load Binary as Hex";
    constexpr static const char*    CONFIG_BINARY_HEX_32        = "Load Binary as Hex (Wide)";
    constexpr static const char*    CONFIG_BINARY_NO            = "Don't Load Binary Files";
    constexpr static const char*    CONFIG_BINARY_TEXT          = "Load Binary as Text";
    constexpr static const char*    CONFIG_BLOCK_CURSOR         = "Block Cursor";
    constexpr static const char*    CONFIG_CARET_CURSOR         = "Caret Cursor";
    constexpr static const char*    CONFIG_DIM_CURSOR           = "Dim Cursor";
    constexpr static const char*    CONFIG_HEAVY_CURSOR         = "Heavy Cursor";
    constexpr static const char*    CONFIG_NORMAL_CURSOR        = "Normal Cursor";
    constexpr static const char*    CONFIG_SCROLL3              = "3 Lines";
    constexpr static const char*    CONFIG_SCROLL6              = "6 Lines";
    constexpr static const char*    CONFIG_SCROLL9              = "9 Lines";
    constexpr static const char*    CONFIG_SCROLL12             = "12 Lines";
    constexpr static const char*    CONFIG_SCROLL15             = "15 Lines";
    constexpr static const char*    CONFIG_SCROLL18             = "18 Lines";
    constexpr static const char*    CONFIG_SCROLL_WAYLAND       = "Does not work as intended in Wayland,\nif desktop scroll settings is not set to 3!";
    constexpr static const char*    CONFIG_SIMPLE_CURSOR        = "Simple cursor";
    constexpr static const char*    CONFIG_TOOLTIP_BINARY_FILE  = "You can load binary files with contents converted to hexadecimal.\nDue to increased memory usage max file size is 425MB.\nOr converted to some kind of text.\nIt will be opened as a unsaved unnamed document.";
    constexpr static const char*    CONFIG_UNDO_FLE_V1          = "FLE";
    constexpr static const char*    CONFIG_UNDO_FLTK            = "FLTK";
    constexpr static const char*    CONFIG_UNDO_NONE            = "None";
    constexpr static const char*    CONFIG_WRAP100              = "100";
    constexpr static const char*    CONFIG_WRAP120              = "120";
    constexpr static const char*    CONFIG_WRAP140              = "140";
    constexpr static const char*    CONFIG_WRAP60               = "60";
    constexpr static const char*    CONFIG_WRAP72               = "72";
    constexpr static const char*    CONFIG_WRAP80               = "80";
    constexpr static const char*    CONFIG_WRAPWINDOW           = "Wrap Window";
    constexpr static const char*    SCHEME_ATTR_BGCOLOR         = "Background";
    constexpr static const char*    SCHEME_ATTR_BGCOLOR_EXT     = "Extended Background";
    constexpr static const char*    SCHEME_ATTR_BGCOLOR_NONE    = "No Background";
    constexpr static const char*    SCHEME_ATTR_GRAMMAR         = "Grammar";
    constexpr static const char*    SCHEME_ATTR_NONE            = "No Attribute";
    constexpr static const char*    SCHEME_ATTR_STRIKE          = "Strike Through";
    constexpr static const char*    SCHEME_ATTR_UNDERLINE       = "Underline";
    constexpr static const char*    SCHEME_FONT_BOLD            = "Bold";
    constexpr static const char*    SCHEME_FONT_BOLD_ITALIC     = "Bold && Italic";
    constexpr static const char*    SCHEME_FONT_ITALIC          = "Italic";
    constexpr static const char*    SCHEME_FONT_REGULAR         = "Regular";
}
class _ConfigDialog : public Fl_Double_Window {
public:
    Config&                     _config;
    Fl_Box*                     _fixed_label;
    Fl_Button*                  _close;
    Fl_Button*                  _fixed;
    Fl_Check_Button*            _autocomplete;
    Fl_Check_Button*            _autoreload;
    Fl_Check_Button*            _highlight;
    Fl_Check_Button*            _indent;
    Fl_Check_Button*            _insert;
    Fl_Check_Button*            _linenumber;
    Fl_Check_Button*            _statusbar;
    Fl_Menu_Button*             _binary;
    Fl_Menu_Button*             _cursor;
    Fl_Menu_Button*             _scroll;
    Fl_Menu_Button*             _undo;
    Fl_Menu_Button*             _wrap;
    flw::GridGroup*             _grid;
    bool                        _run;
    _ConfigDialog(Config& config) :
    Fl_Double_Window(0, 0, 10, 10),
    _config(config) {
        end();
        _autocomplete = new Fl_Check_Button(0, 0, 0, 0, "Autocomplete");
        _autoreload   = new Fl_Check_Button(0, 0, 0, 0, "Autoreload changed file");
        _binary       = new Fl_Menu_Button(0, 0, 0, 0, "Binary files");
        _close        = new Fl_Button(0, 0, 0, 0, "&Close");
        _cursor       = new Fl_Menu_Button(0, 0, 0, 0, "Cursor");
        _fixed        = new Fl_Button(0, 0, 0, 0, "Editor font");
        _fixed_label  = new Fl_Box(0, 0, 0, 0);
        _grid         = new flw::GridGroup(0, 0, w(), h());
        _highlight    = new Fl_Check_Button(0, 0, 0, 0, "!! Highlight current line");
        _indent       = new Fl_Check_Button(0, 0, 0, 0, "Automatic indentation");
        _insert       = new Fl_Check_Button(0, 0, 0, 0, "Enable insert/overwrite mode");
        _linenumber   = new Fl_Check_Button(0, 0, 0, 0, "Linenumber");
        _scroll       = new Fl_Menu_Button(0, 0, 0, 0, "!! Mouse scroll");
        _statusbar    = new Fl_Check_Button(0, 0, 0, 0, "Statusbar");
        _undo         = new Fl_Menu_Button(0, 0, 0, 0, "Undo mode");
        _wrap         = new Fl_Menu_Button(0, 0, 0, 0, "Word wrap");
        _run          = false;
        _grid->add(_linenumber,     1,   1,  -1,   4);
        _grid->add(_statusbar,      1,   6,  -1,   4);
        _grid->add(_autocomplete,   1,  11,  -1,   4);
        _grid->add(_autoreload,     1,  16,  -1,   4);
        _grid->add(_indent,         1,  21,  -1,   4);
        _grid->add(_insert,         1,  26,  -1,   4);
        _grid->add(_highlight,      1,  31,  -1,   4);
        _grid->add(_cursor,         1,  36,  -1,   4);
        _grid->add(_scroll,         1,  41,  -1,   4);
        _grid->add(_wrap,           1,  46,  -1,   4);
        _grid->add(_undo,           1,  51,  -1,   4);
        _grid->add(_binary,         1,  56,  -1,   4);
        _grid->add(_fixed_label,    1,  61,  -1,   4);
        _grid->add(_fixed,        -34,  -5,  16,   4);
        _grid->add(_close,        -17,  -5,  16,   4);
        add(_grid);
        _autocomplete->tooltip(
            "Turn autocomplete on or off.\n"
            "Autocomplete list are generated when file is loaded and every time it is saved."
        );
        _autoreload->tooltip(
            "File is reloaded when it has been updated outside editor.\n"
            "But only when the editor has received focus again.\n"
            "If text has been changed in editor you will be asked."
        );
        _binary->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
        _binary->tooltip(widgets2::CONFIG_TOOLTIP_BINARY_FILE);
        _close->callback(Callback, this);
        _cursor->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
        _fixed->callback(Callback, this);
        _fixed->tooltip("Select editor font.");
        _fixed_label->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
        _fixed_label->box(FL_BORDER_BOX);
        _fixed_label->color(FL_BACKGROUND2_COLOR);
        _fixed_label->tooltip("Select editor font.");
        _highlight->tooltip(
            "Highlightning must be used.\n"
            "And it does not work with empty lines.\n"
            "Set color in 'Color scheme' dialog."
        );
        _indent->tooltip("Enable or disable automatic indentation.");
        _insert->tooltip(
            "Enable or disable insert/overwrite mode.\n"
            "If not checked only insert mode can be used.\n"
        );
        _linenumber->tooltip("Show or hide linenumbers.");
        _scroll->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
        _scroll->tooltip(widgets2::CONFIG_SCROLL_WAYLAND);
        _statusbar->tooltip("Show or hide statusbar.");
        _undo->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
        _undo->tooltip(
            "FLE undo is a replacement for the built in undo.\n"
            "It has some additional features like undo batch replacements in one go.\n"
            "FLTK is the native undo which undo texts in chunks.\n"
            "And you can also disable undo."
        );
        _wrap->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
        if (config.disable_autoreload == true) {
            _autoreload->deactivate();
        }
        callback(Callback, this);
        set_modal();
        init();
        resizable(this);
        update_pref();
        copy_label(fle::APPLICATION != "" ? (fle::APPLICATION + " - Settings").c_str() : "Settings");
    }
    static void Callback(Fl_Widget* w, void* o) {
        auto self = static_cast<_ConfigDialog*>(o);
        if (w == self || w == self->_close) {
            self->_run = false;
            self->save();
            self->hide();
        }
        else if (w == self->_fixed) {
            auto dialog = flw::dlg::Font(flw::PREF_FIXED_FONT, flw::PREF_FIXED_FONTSIZE, "Select Editor Font");
            if (dialog.run() == true) {
                flw::PREF_FIXED_FONT            = dialog.font();
                flw::PREF_FIXED_FONTSIZE        = dialog.fontsize();
                flw::PREF_FIXED_FONTNAME        = dialog.fontname();
                self->_config.pref_tmp_fontsize = 0;
                self->update_pref();
            }
        }
    }
    void init() {
        std::string text;
        if (_autoreload->active() != 0) {
            _autoreload->value(_config.pref_autoreload);
        }
        _autocomplete->value(_config.pref_autocomplete);
        _highlight->value(_config.pref_highlight);
        _indent->value(_config.pref_indentation);
        _insert->value(_config.pref_insert);
        _linenumber->value(_config.pref_linenumber);
        _statusbar->value(_config.pref_statusbar);
        {
            _cursor->add(widgets2::CONFIG_NORMAL_CURSOR, 0, nullptr, nullptr, FL_MENU_RADIO);
            _cursor->add(widgets2::CONFIG_CARET_CURSOR, 0, nullptr, nullptr, FL_MENU_RADIO);
            _cursor->add(widgets2::CONFIG_DIM_CURSOR, 0, nullptr, nullptr, FL_MENU_RADIO);
            _cursor->add(widgets2::CONFIG_BLOCK_CURSOR, 0, nullptr, nullptr, FL_MENU_RADIO);
            _cursor->add(widgets2::CONFIG_HEAVY_CURSOR, 0, nullptr, nullptr, FL_MENU_RADIO);
            _cursor->add(widgets2::CONFIG_SIMPLE_CURSOR, 0, nullptr, nullptr, FL_MENU_RADIO);
            if (_config.pref_cursor == Fl_Text_Display::CARET_CURSOR) {
                text = widgets2::CONFIG_CARET_CURSOR;
            }
            else if (_config.pref_cursor == Fl_Text_Display::DIM_CURSOR) {
                text = widgets2::CONFIG_DIM_CURSOR;
            }
            else if (_config.pref_cursor == Fl_Text_Display::BLOCK_CURSOR) {
                text = widgets2::CONFIG_BLOCK_CURSOR;
            }
            else if (_config.pref_cursor == Fl_Text_Display::HEAVY_CURSOR) {
                text = widgets2::CONFIG_HEAVY_CURSOR;
            }
            else if (_config.pref_cursor == Fl_Text_Display::SIMPLE_CURSOR) {
                text = widgets2::CONFIG_SIMPLE_CURSOR;
            }
            else {
                text = widgets2::CONFIG_NORMAL_CURSOR;
            }
            flw::menu::setonly_item(_cursor, text.c_str());
        }
        {
            _scroll->add(widgets2::CONFIG_SCROLL3, 0, nullptr, nullptr, FL_MENU_RADIO);
            _scroll->add(widgets2::CONFIG_SCROLL6, 0, nullptr, nullptr, FL_MENU_RADIO);
            _scroll->add(widgets2::CONFIG_SCROLL9, 0, nullptr, nullptr, FL_MENU_RADIO);
            _scroll->add(widgets2::CONFIG_SCROLL12, 0, nullptr, nullptr, FL_MENU_RADIO);
            _scroll->add(widgets2::CONFIG_SCROLL15, 0, nullptr, nullptr, FL_MENU_RADIO);
            _scroll->add(widgets2::CONFIG_SCROLL18, 0, nullptr, nullptr, FL_MENU_RADIO);
            if (_config.pref_mouse_scroll == 3) {
                text = widgets2::CONFIG_SCROLL6;
            }
            else if (_config.pref_mouse_scroll == 6) {
                text = widgets2::CONFIG_SCROLL9;
            }
            else if (_config.pref_mouse_scroll == 9) {
                text = widgets2::CONFIG_SCROLL12;
            }
            else if (_config.pref_mouse_scroll == 12) {
                text = widgets2::CONFIG_SCROLL15;
            }
            else if (_config.pref_mouse_scroll == 15) {
                text = widgets2::CONFIG_SCROLL18;
            }
            else {
                text = widgets2::CONFIG_SCROLL3;
            }
            flw::menu::setonly_item(_scroll, text.c_str());
        }
        {
            _wrap->add(widgets2::CONFIG_WRAP60, 0, nullptr, nullptr, FL_MENU_RADIO);
            _wrap->add(widgets2::CONFIG_WRAP72, 0, nullptr, nullptr, FL_MENU_RADIO);
            _wrap->add(widgets2::CONFIG_WRAP80, 0, nullptr, nullptr, FL_MENU_RADIO);
            _wrap->add(widgets2::CONFIG_WRAP100, 0, nullptr, nullptr, FL_MENU_RADIO);
            _wrap->add(widgets2::CONFIG_WRAP120, 0, nullptr, nullptr, FL_MENU_RADIO);
            _wrap->add(widgets2::CONFIG_WRAP140, 0, nullptr, nullptr, FL_MENU_RADIO);
            _wrap->add(widgets2::CONFIG_WRAPWINDOW, 0, nullptr, nullptr, FL_MENU_RADIO);
            if (_config.pref_wrap == 60) {
                text = widgets2::CONFIG_WRAP60;
            }
            else if (_config.pref_wrap == 72) {
                text = widgets2::CONFIG_WRAP72;
            }
            else if (_config.pref_wrap == 100) {
                text = widgets2::CONFIG_WRAP100;
            }
            else if (_config.pref_wrap == 120) {
                text = widgets2::CONFIG_WRAP120;
            }
            else if (_config.pref_wrap == 140) {
                text = widgets2::CONFIG_WRAP140;
            }
            else if (_config.pref_wrap == 66) {
                text = widgets2::CONFIG_WRAPWINDOW;
            }
            else {
                text = widgets2::CONFIG_WRAP80;
            }
            flw::menu::setonly_item(_wrap, text.c_str());
        }
        {
            _undo->add(widgets2::CONFIG_UNDO_FLE_V1, 0, nullptr, nullptr, FL_MENU_RADIO);
            _undo->add(widgets2::CONFIG_UNDO_FLTK, 0, nullptr, nullptr, FL_MENU_RADIO);
            _undo->add(widgets2::CONFIG_UNDO_NONE, 0, nullptr, nullptr, FL_MENU_RADIO);
            if (_config.pref_undo == FUndoMode::FLE_V1) {
                text = widgets2::CONFIG_UNDO_FLE_V1;
            }
            else if (_config.pref_undo == FUndoMode::FLTK) {
                text = widgets2::CONFIG_UNDO_FLTK;
            }
            else {
                text = widgets2::CONFIG_UNDO_NONE;
            }
            flw::menu::setonly_item(_undo, text.c_str());
        }
        {
            _binary->add(widgets2::CONFIG_BINARY_NO, 0, nullptr, nullptr, FL_MENU_RADIO);
            _binary->add(widgets2::CONFIG_BINARY_TEXT, 0, nullptr, nullptr, FL_MENU_RADIO);
            _binary->add(widgets2::CONFIG_BINARY_HEX_16, 0, nullptr, nullptr, FL_MENU_RADIO);
            _binary->add(widgets2::CONFIG_BINARY_HEX_32, 0, nullptr, nullptr, FL_MENU_RADIO);
            if (_config.pref_binary == FBinFile::HEX_16) {
                text = widgets2::CONFIG_BINARY_HEX_16;
            }
            else if (_config.pref_binary == FBinFile::HEX_32) {
                text = widgets2::CONFIG_BINARY_HEX_32;
            }
            else if (_config.pref_binary == FBinFile::TEXT) {
                text = widgets2::CONFIG_BINARY_TEXT;
            }
            else {
                text = widgets2::CONFIG_BINARY_NO;
            }
            flw::menu::setonly_item(_binary, text.c_str());
        }
    }
    void run() {
        _run = true;
        flw::util::center_window(this, Fl::first_window());
        show();
        while (_run == true) {
            Fl::wait();
            Fl::flush();
        }
    }
    void save() {
        if (_insert->value() != _config.pref_insert) {
            _config.send_message(message::RESET_INSERT_MODE);
        }
        _config.pref_autocomplete = _autocomplete->value();
        _config.pref_autoreload   = _autoreload->value();
        _config.pref_highlight    = _highlight->value();
        _config.pref_indentation  = _indent->value();
        _config.pref_insert       = _insert->value();
        _config.pref_linenumber   = _linenumber->value();
        _config.pref_statusbar    = _statusbar->value();
        auto label = gnu::str::to_string(_cursor->text());
        if (label == widgets2::CONFIG_NORMAL_CURSOR) {
            _config.pref_cursor = Fl_Text_Display::NORMAL_CURSOR;
        }
        else if (label == widgets2::CONFIG_CARET_CURSOR) {
            _config.pref_cursor = Fl_Text_Display::CARET_CURSOR;
        }
        else if (label == widgets2::CONFIG_DIM_CURSOR) {
            _config.pref_cursor = Fl_Text_Display::DIM_CURSOR;
        }
        else if (label == widgets2::CONFIG_BLOCK_CURSOR) {
            _config.pref_cursor = Fl_Text_Display::BLOCK_CURSOR;
        }
        else if (label == widgets2::CONFIG_HEAVY_CURSOR) {
            _config.pref_cursor = Fl_Text_Display::HEAVY_CURSOR;
        }
        else if (label == widgets2::CONFIG_SIMPLE_CURSOR) {
            _config.pref_cursor = Fl_Text_Display::SIMPLE_CURSOR;
        }
        label = gnu::str::to_string(_scroll->text());
        if (label == widgets2::CONFIG_SCROLL3) {
            _config.pref_mouse_scroll = 0;
        }
        else if (label == widgets2::CONFIG_SCROLL6) {
            _config.pref_mouse_scroll = 3;
        }
        else if (label == widgets2::CONFIG_SCROLL9) {
            _config.pref_mouse_scroll = 6;
        }
        else if (label == widgets2::CONFIG_SCROLL12) {
            _config.pref_mouse_scroll = 9;
        }
        else if (label == widgets2::CONFIG_SCROLL15) {
            _config.pref_mouse_scroll = 12;
        }
        else if (label == widgets2::CONFIG_SCROLL18) {
            _config.pref_mouse_scroll = 15;
        }
        label = gnu::str::to_string(_wrap->text());
        if (label == widgets2::CONFIG_WRAP60) {
            _config.pref_wrap = 60;
        }
        else if (label == widgets2::CONFIG_WRAP72) {
            _config.pref_wrap = 72;
        }
        else if (label == widgets2::CONFIG_WRAP100) {
            _config.pref_wrap = 100;
        }
        else if (label == widgets2::CONFIG_WRAP120) {
            _config.pref_wrap = 120;
        }
        else if (label == widgets2::CONFIG_WRAP140) {
            _config.pref_wrap = 140;
        }
        else if (label == widgets2::CONFIG_WRAPWINDOW) {
            _config.pref_wrap = 66;
        }
        else if (label == widgets2::CONFIG_WRAP80) {
            _config.pref_wrap = 80;
        }
        label = gnu::str::to_string(_undo->text());
        if (label == widgets2::CONFIG_UNDO_FLE_V1) {
            _config.pref_undo = FUndoMode::FLE_V1;
        }
        else if (label == widgets2::CONFIG_UNDO_FLTK) {
            _config.pref_undo = FUndoMode::FLTK;
        }
        else if (label == widgets2::CONFIG_UNDO_NONE) {
            _config.pref_undo = FUndoMode::NONE;
        }
        label = gnu::str::to_string(_binary->text());
        if (label == widgets2::CONFIG_BINARY_HEX_16) {
            _config.pref_binary = FBinFile::HEX_16;
        }
        else if (label == widgets2::CONFIG_BINARY_HEX_32) {
            _config.pref_binary = FBinFile::HEX_32;
        }
        else if (label == widgets2::CONFIG_BINARY_TEXT) {
            _config.pref_binary = FBinFile::TEXT;
        }
        else if (label == widgets2::CONFIG_BINARY_NO) {
            _config.pref_binary = FBinFile::NO;
        }
    }
    void update_pref() {
        flw::util::labelfont(this);
        _binary->textfont(flw::PREF_FONT);
        _binary->textsize(flw::PREF_FONTSIZE);
        _cursor->textfont(flw::PREF_FONT);
        _cursor->textsize(flw::PREF_FONTSIZE);
        _fixed_label->copy_label(gnu::str::format("%s - %d", flw::PREF_FIXED_FONTNAME.c_str(), flw::PREF_FIXED_FONTSIZE).c_str());
        _fixed_label->labelfont(flw::PREF_FIXED_FONT);
        _fixed_label->labelsize(flw::PREF_FIXED_FONTSIZE);
        _scroll->textfont(flw::PREF_FONT);
        _scroll->textsize(flw::PREF_FONTSIZE);
        _undo->textfont(flw::PREF_FONT);
        _undo->textsize(flw::PREF_FONTSIZE);
        _wrap->textfont(flw::PREF_FONT);
        _wrap->textsize(flw::PREF_FONTSIZE);
        resize(x(), y(), flw::PREF_FONTSIZE * 30, flw::PREF_FONTSIZE * 36);
    }
};
void dlg::config(Config& config) {
    auto dlg = _ConfigDialog(config);
    dlg.run();
    config.send_message(message::PREF_CHANGED);
}
class _DlgEditor : public Fl_Double_Window, Message {
    Config&                     _config;
    Editor*                     _editor;
    FindBar*                    _findbar;
    Fl_Button*                  _b1;
    Fl_Button*                  _b2;
    bool                        _edit;
    bool                        _res;
    bool                        _run;
    std::string                 _org;
public:
    _DlgEditor(Config& config, const std::string& title, int W, int H) :
    Fl_Double_Window(0, 0, flw::PREF_FONTSIZE * W, flw::PREF_FONTSIZE * H),
    Message(config),
    _config(config) {
        end();
        _b1      = new Fl_Button(0, 0, 0, 0, "");
        _b2      = new Fl_Button(0, 0, 0, 0, "");
        _findbar = new FindBar(config);
        _editor  = new Editor(config, _findbar);
        _edit    = false;
        _res     = false;
        _run     = false;
        add(_editor);
        add(_b1);
        add(_b2);
        add(_findbar);
        _b1->callback(_DlgEditor::Callback, this);
        _b2->callback(_DlgEditor::Callback, this);
        _findbar->findreplace().update_lists(true, true, -1);
        copy_label(title.c_str());
        callback(_DlgEditor::Callback, this);
        set_modal();
        resizable(this);
        update_pref();
        flw::util::center_window(this, Fl::first_window());
        _editor->take_focus();
    }
    static void Callback(Fl_Widget* w, void* o) {
        auto self = static_cast<_DlgEditor*>(o);
        if (w == self) {
        }
        else if (w == self->_b1) {
            self->_res = false;
            self->_run = false;
            self->hide();
        }
        else if (w == self->_b2) {
            if (w->label() == flw::label::SAVE) {
                self->_editor->file_save();
            }
            else {
                self->_res = true;
                self->_run = false;
                self->hide();
            }
        }
    }
    bool load_file(std::string file, std::string style) {
        auto err = _editor->file_load(file);
        if (err != "") {
            flw::dlg::msg_alert("Load File Error", err);
            return false;
        }
        else if (style == "") {
            _editor->style_from_filename();
        }
        else {
            _editor->style_from_language(style);
        }
        _editor->update_autocomplete();
        _org = text();
        return true;
    }
    Message::CTRL message(const std::string& message, const std::string&, const std::string&, void* p) override {
        if (message == message::DND_EVENT) {
            auto discard = reinterpret_cast<bool*>(const_cast<void*>(p));
            *discard = false;
        }
        else if (message == message::PREF_CHANGED) {
            update_pref();
            resize(x(), y(), w(), h());
        }
        else if (message == message::HIDE_FIND) {
            _editor->findbar().hide();
            _editor->take_focus();
            size(w(), h());
            Fl::redraw();
            _config.active->take_focus();
        }
        else if (message == message::TEXT_CHANGED) {
        }
        else if (message == message::SHOW_FIND) {
            _editor->findbar().show();
            size(w(), h());
            Fl::redraw();
        }
        return Message::CTRL::CONTINUE;
    }
    void resize(int X, int Y, int W, int H) override {
        auto fs = flw::PREF_FONTSIZE / 2;
        auto h  = _findbar->height();
        Fl_Double_Window::resize(X, Y, W, H);
        _editor->resize (0, 0,               W, H - fs * 6 - h);
        _findbar->resize(0, H - fs * 6 - h,  W, h);
        if (_b2->label() == flw::label::SAVE || _b2->label() == flw::label::UPDATE) {
            _b2->resize(W - fs * 34, H - fs * 5, fs * 16,  fs * 4);
            _b1->resize(W - fs * 17, H - fs * 5, fs * 16,  fs * 4);
        }
        else {
            _b1->resize(W - fs * 34, H - fs * 5, fs * 16,  fs * 4);
            _b2->resize(W - fs * 17, H - fs * 5, fs * 16,  fs * 4);
        }
    }
    bool run() {
        _run = true;
        show();
        while (_run == true) {
            Fl::wait();
            Fl::flush();
        }
        return _edit == true && _res == true && _org != _editor->text_get_buffer(_editor->file_line_ending(), FTrim::NO, FChecksum::NO).c_str();
    }
    bool file_save() {
        auto err = _editor->file_save();
        if (err != "") {
            flw::dlg::msg_alert("Sabve File Error", err);
            return false;
        }
        return true;
    }
    void set_text(const char* text, std::string style) {
        _editor->text_set(text, FLineEnding::UNIX, FChecksum::YES);
        _editor->style_from_language(style);
        _editor->update_autocomplete();
        _org = text;
    }
    std::string text() const {
        return _editor->text_get_buffer(_editor->file_line_ending(), FTrim::NO, FChecksum::NO).c_str();
    }
    void update_buttons(bool edit, bool file) {
        _edit = edit;
        if (_edit == false && file == false) {
            _b1->hide();
            _b2->label(flw::label::CLOSE.c_str());
            _b2->tooltip("Close dialog.");
        }
        else if (_edit == false && file == true) {
            _b1->hide();
            _b2->label(flw::label::CLOSE.c_str());
            _b2->tooltip("Close dialog.");
        }
        else if (_edit == true && file == false) {
            _b1->label(flw::label::DISCARD.c_str());
            _b1->tooltip("Discard changes and close dialog.");
            _b2->label(flw::label::UPDATE.c_str());
            _b2->tooltip("Update text and close dialog.");
        }
        else if (_edit == true && file == true) {
            _b1->label(flw::label::CLOSE.c_str());
            _b1->tooltip("Close dialog.");
            _b2->label(flw::label::SAVE.c_str());
            _b2->tooltip("Save text.");
        }
    }
    void update_pref() {
        flw::util::labelfont(this);
        _editor->findbar().update_pref();
    }
};
bool dlg::edit(Config& config, const std::string& title, std::string& text, const std::string& style, int W, int H) {
    auto editor = _DlgEditor(config, title, W, H);
    editor.set_text(text.c_str(), style);
    editor.update_buttons(true, false);
    auto res = editor.run();
    if (res == true) {
        text = editor.text();
    }
    return res;
}
void dlg::edit_file(Config& config, const std::string& title, const std::string& file, const std::string& style, int W, int H) {
    auto editor = _DlgEditor(config, title, W, H);
    if (editor.load_file(file, style) == false) {
        return;
    }
    editor.update_buttons(true, true);
    editor.run();
}
void dlg::view(Config& config, const std::string& title, const std::string& text, const std::string& style, int W, int H) {
    auto editor = _DlgEditor(config, title, W, H);
    editor.set_text(text.c_str(), style);
    editor.update_buttons(false, false);
    editor.run();
}
void dlg::view_file(Config& config, const std::string& title, const std::string& file, const std::string& style, int W, int H) {
    auto editor = _DlgEditor(config, title, W, H);
    if (editor.load_file(file, style) == false) {
        return;
    }
    editor.update_buttons(false, true);
    editor.run();
}
class _KeyboardDialog : public Fl_Double_Window {
public:
    Config&                     _config;
    Fl_Box*                     _col[6];
    Fl_Box*                     _label[fle::FKEY_SIZE];
    Fl_Button*                  _close;
    Fl_Button*                  _reset;
    Fl_Check_Button*            _alt[fle::FKEY_SIZE];
    Fl_Check_Button*            _ctrl[fle::FKEY_SIZE];
    Fl_Check_Button*            _kommand[fle::FKEY_SIZE];
    Fl_Check_Button*            _shift[fle::FKEY_SIZE];
    Fl_Int_Input*               _key[fle::FKEY_SIZE];
    Fl_Scroll*                  _scroll;
    bool                        _run;
    char                        _buff[256];
    flw::GridGroup*             _grid1;
    flw::GridGroup*             _grid2;
    flw::GridGroup*             _grid3;
    int                         _count;
    int                         _height;
    _KeyboardDialog(Config& config) :
    Fl_Double_Window(0, 0, 10, 10),
    _config(config) {
        end();
        _close  = new Fl_Button(0, 0, 0, 0, "&Close");
        _col[0] = new Fl_Box(0, 0, 0, 0, "Alt");
        _col[1] = new Fl_Box(0, 0, 0, 0, "Ctrl");
        _col[2] = new Fl_Box(0, 0, 0, 0, "Shift");
        _col[3] = new Fl_Box(0, 0, 0, 0, "Cmd");
        _col[4] = new Fl_Box(0, 0, 0, 0, "Key");
        _col[5] = new Fl_Box(0, 0, 0, 0, "Description");
        _grid1  = new flw::GridGroup(0, 0, w(), h());
        _grid2  = new flw::GridGroup(0, 0, w(), h());
        _grid3  = new flw::GridGroup(0, 0, w(), h());
        _reset  = new Fl_Button(0, 0, 0, 0, "&Reset");
        _scroll = new Fl_Scroll(0, 0, w(), h());
        _height = 0;
        _run    = true;
        end();
        for (int f = 0; f < fle::FKEY_SIZE; f++) {
            _alt[f] = new Fl_Check_Button(0, 0, 0, 0);
            _alt[f]->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
            _grid2->add(_alt[f], 1, 5 * f + 1, 6, 4);
            _ctrl[f] = new Fl_Check_Button(0, 0, 0, 0);
            _ctrl[f]->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
            _grid2->add(_ctrl[f], 7, 5 * f + 1, 6, 4);
            _shift[f] = new Fl_Check_Button(0, 0, 0, 0);
            _shift[f]->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
            _grid2->add(_shift[f], 13, 5 * f + 1, 6, 4);
            _kommand[f] = new Fl_Check_Button(0, 0, 0, 0);
            _kommand[f]->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
            _kommand[f]->tooltip("Check this option to turn on command mode for this shortcut key.");
            _grid2->add(_kommand[f], 19, 5 * f + 1, 6, 4);
            _key[f] = new Fl_Int_Input(0, 0, 0, 0);
            _key[f]->align(FL_ALIGN_RIGHT | FL_ALIGN_CLIP);
            _key[f]->textfont(flw::PREF_FIXED_FONT);
            _key[f]->textsize(flw::PREF_FONTSIZE);
            _key[f]->labelfont(flw::PREF_FIXED_FONT);
            _key[f]->labelsize(flw::PREF_FONTSIZE);
            _key[f]->tooltip(
                "Enter key value as an hex number.\n"
                "Valid values are from 0x20 to 0xFFFF.\n"
                "Either an ascii letter or a FLTK keycode.\n"
                "Beware there is no check that the key actual works."
            );
            _grid2->add(_key[f], 25, 5 * f + 1, 10, 4);
            _label[f] = new Fl_Box(0, 0, 0, 0, _config.keys[f].help);
            _label[f]->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
            _grid2->add(_label[f], 49, 5 * f + 1, -1, 4);
        }
        _height = (fle::FKEY_SIZE + 1) * flw::PREF_FONTSIZE * 2.5;
        _grid1->add(_col[0],   1,   1,   8,   4);
        _grid1->add(_col[1],   7,   1,   8,   4);
        _grid1->add(_col[2],  13,   1,   8,   4);
        _grid1->add(_col[3],  19,   1,  14,   4);
        _grid1->add(_col[4],  25,   1,  10,   4);
        _grid1->add(_col[5],  49,   1,   0,   4);
        _grid3->add(_reset,  -33,  -5,  16,   4);
        _grid3->add(_close,  -16,  -5,  16,   4);
        _scroll->add(_grid2);
        add(_grid1);
        add(_scroll);
        add(_grid3);
        _scroll->box(FL_ENGRAVED_FRAME);
        _close->callback(_KeyboardDialog::Callback, this);
        _reset->callback(_KeyboardDialog::Callback, this);
        _reset->tooltip("Reset all keyboard settings to default values.");
        flw::util::labelfont(this);
        for (int f = 0; f < 6; f++) {
            _col[f]->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
        }
        callback(_KeyboardDialog::Callback, this);
        set_modal();
        resizable(this);
        resize(0, 0, flw::PREF_FONTSIZE * 60, flw::PREF_FONTSIZE * 40);
        load_keys();
        copy_label(fle::APPLICATION != "" ? (fle::APPLICATION + " - keyboard Settings").c_str() : "keyboard Settings");
    }
    static void Callback(Fl_Widget* w, void* o) {
        auto self = static_cast<_KeyboardDialog*>(o);
        if (w == self->_close && self->save_keys() == true) {
            self->_run = false;
            self->hide();
        }
        else if (w == self->_reset) {
            self->reset_keys();
        }
    }
    int from_hex(const char* val) {
        errno = 0;
        auto ival = strtoul(val, nullptr, 16);
        if (errno != 0 || ival > 0xFFFF) {
            return -1;
        }
        return ival;
    }
    void load_keys() {
        for (int f = 0; f < fle::FKEY_SIZE; f++) {
            _alt[f]->value(_config.keys[f].alt_u);
            _ctrl[f]->value(_config.keys[f].ctrl_u);
            _shift[f]->value(_config.keys[f].shift_u);
            _kommand[f]->value(_config.keys[f].kommand_u);
            _key[f]->value(to_hex(_config.keys[f].key_u));
            _key[f]->copy_label(KeyConf::KeyDescr(_config.keys[f].key_u).c_str());
        }
        Fl::redraw();
    }
    void reset_keys() {
        for (int f = 0; f < fle::FKEY_SIZE; f++) {
            _alt[f]->value(_config.keys[f].alt_d);
            _ctrl[f]->value(_config.keys[f].ctrl_d);
            _shift[f]->value(_config.keys[f].shift_d);
            _kommand[f]->value(_config.keys[f].kommand_d);
            _key[f]->value(to_hex(_config.keys[f].key_d));
            _key[f]->copy_label(KeyConf::KeyDescr(_config.keys[f].key_d).c_str());
        }
        Fl::redraw();
    }
    void resize(int X, int Y, int W, int H) override {
        auto fs = flw::PREF_FONTSIZE / 2;
        Fl_Double_Window::resize(X, Y, W, H);
        _grid1->resize  (fs,      0,           W - fs * 2,  fs * 4);
        _scroll->resize (fs,      fs * 4,      W - fs * 2,  H - fs * 10);
        _grid2->resize  (fs + 2,  0,           W - fs * 5,  _height);
        _grid3->resize  (fs,      H - fs * 6,  W - fs * 2,  fs * 6);
    }
    void run() {
        _run = true;
        flw::util::center_window(this, Fl::first_window());
        show();
        while (_run == true) {
            Fl::wait();
            Fl::flush();
        }
    }
    bool save_keys() {
        auto err = 0;
        for (int f = 0; f < fle::FKEY_SIZE; f++) {
            auto hex = from_hex(_key[f]->value());
            if (hex < 0x20) {
                _col[4]->label("ERROR");
                _col[4]->labelcolor(FL_RED);
                _key[f]->take_focus();
                _key[f]->color(FL_RED);
                err++;
            }
            else {
                _key[f]->color(FL_BACKGROUND2_COLOR);
            }
        }
        Fl::redraw();
        if (err > 0) {
            flw::dlg::msg_alert("Keyboard Configuration Error", "There were some error with key values!");
            return false;
        }
        _col[4]->label("Key");
        _col[4]->labelcolor(FL_FOREGROUND_COLOR);
        for (int f = 0; f < fle::FKEY_SIZE; f++) {
            _config.keys[f].alt_u     = _alt[f]->value();
            _config.keys[f].ctrl_u    = _ctrl[f]->value();
            _config.keys[f].shift_u   = _shift[f]->value();
            _config.keys[f].kommand_u = _kommand[f]->value();
            _config.keys[f].key_u     = from_hex(_key[f]->value());
            _key[f]->copy_label(KeyConf::KeyDescr(_config.keys[f].key_u).c_str());
        }
        _config.send_message(message::PREF_CHANGED);
        return true;
    }
    const char* to_hex(int val) {
        snprintf(_buff, 256, "0x%X", val);
        return _buff;
    }
};
void dlg::keyboard(Config& config) {
    auto dlg = _KeyboardDialog(config);
    dlg.run();
}
class _SchemeButton : public Fl_Button {
    std::string                 _label;
    bool                        _label_color;
    unsigned char               _r;
    unsigned char               _g;
    unsigned char               _b;
public:
    _SchemeButton(const std::string& label, bool label_color) : Fl_Button(0, 0, 0, 0) {
        _label       = label;
        _label_color = label_color;
        _r           = 0;
        _g           = 0;
        _b           = 0;
        align(FL_ALIGN_RIGHT);
        box(FL_BORDER_BOX);
        tooltip(
            "Select new color.\n"
            "Press ctrl + left button to reset color.\n"
            "Right click to copy hex values.\n"
            "Middle click to paste hex values.\n"
            "\n"
            "Hex values from the clipboard should look like this:\n"
            "0xff, 0xff, 0xff."
        );
    }
    void copy_color() const {
        char buf[200];
        snprintf(buf, 200, "0x%02x, 0x%02x, 0x%02x", _r, _g, _b);
        Fl::copy(buf, strlen(buf), 2);
    }
    int handle(int event) override {
        if (event == FL_PASTE) {
            auto str = gnu::str::to_string(Fl::event_text());
            if (str != "") {
                auto m = gnu::pcre8::PCRE(
                    "\\W*(0[xX][0-9a-fA-F]{2})"
                    "\\W*(0[xX][0-9a-fA-F]{2})"
                    "\\W*(0[xX][0-9a-fA-F]{2})"
                ).exec(str);
                if (m.size() == 4) {
                    auto r = static_cast<uint8_t>(strtoul(m[1].word().c_str(), nullptr, 0));
                    auto g = static_cast<uint8_t>(strtoul(m[2].word().c_str(), nullptr, 0));
                    auto b = static_cast<uint8_t>(strtoul(m[3].word().c_str(), nullptr, 0));
                    auto c = fl_rgb_color(r, g, b);
                    set_color(c);
                }
            }
            return 1;
        }
        return Fl_Button::handle(event);
    }
    bool is_bg_button() const {
        return _label == "";
    }
    void paste_color() {
        Fl::paste(*this, 1);
    }
    void set_color(Fl_Color col) {
        char buf[200];
        if (_label != "") {
            color(col);
            Fl::get_color(col, _r, _g, _b);
            snprintf(buf, 200, "%s: (0x%02x, 0x%02x, 0x%02x)", _label.c_str(), _r, _g, _b);
        }
        else if (col == StyleProp::DEFAULT_BG) {
            *buf = 0;
            color(FL_BACKGROUND_COLOR);
            Fl::get_color(FL_WHITE, _r, _g, _b);
        }
        else {
            color(col);
            Fl::get_color(col, _r, _g, _b);
            snprintf(buf, 200, "(0x%02x, 0x%02x, 0x%02x)", _r, _g, _b);
        }
        if (_label_color == true) {
            labelcolor(col);
        }
        copy_label(buf);
        redraw();
    }
    void set_new_color() {
        if (fl_color_chooser("Select Color", _r, _g, _b, 2) == 0) {
            return;
        }
        set_color(fl_rgb_color(_r, _g, _b));
    }
};
class _SchemeDialog : public Fl_Double_Window {
public:
    Config&                     _config;
    Fl_Button*                  _close;
    Fl_Button*                  _reset;
    Fl_Menu_Button*             _attr[style::STYLE_LAST];
    Fl_Menu_Button*             _bgattr[style::STYLE_LAST];
    Fl_Menu_Button*             _font[style::STYLE_LAST];
    Fl_Menu_Button*             _scheme;
    _SchemeButton*              _bgcolors[style::STYLE_LAST];
    _SchemeButton*              _colors[style::STYLE_LAST];
    bool                        _run;
    flw::GridGroup*             _grid;
    _SchemeDialog(Config& config) :
    Fl_Double_Window(0, 0, 10, 10),
    _config(config) {
        end();
        _close  = new Fl_Button(0, 0, 0, 0, "&Close");
        _grid   = new flw::GridGroup(0, 0, w(), h());
        _reset  = new Fl_Button(0, 0, 0, 0, "Reset current");
        _scheme = new Fl_Menu_Button(0, 0, 0, 0);
        _run    = false;
        _scheme->add(style::SCHEME_DEF.c_str(), 0, nullptr, nullptr, FL_MENU_RADIO);
        _scheme->add(style::SCHEME_LIGHT.c_str(), 0, nullptr, nullptr, FL_MENU_RADIO);
        _scheme->add(style::SCHEME_TAN.c_str(), 0, nullptr, nullptr, FL_MENU_RADIO);
        _scheme->add(style::SCHEME_BLUE.c_str(), 0, nullptr, nullptr, FL_MENU_RADIO);
        _scheme->add(style::SCHEME_DARK.c_str(), 0, nullptr, nullptr, FL_MENU_RADIO);
        _scheme->add(style::SCHEME_NEON.c_str(), 0, nullptr, nullptr, FL_MENU_RADIO);
        _scheme->copy_label(_config.pref_scheme.c_str());
        _scheme->callback(_SchemeDialog::CallbackScheme, this);
        _scheme->textfont(flw::PREF_FONT);
        _scheme->textsize(flw::PREF_FONTSIZE);
        _scheme->tooltip("Select color scheme.");
        flw::menu::setonly_item(_scheme, _config.pref_scheme.c_str());
        _grid->add(_scheme, 1, 1, -1, 4);
        for (size_t f = 0; f < style::STYLE_LAST; f++) {
            {
                _colors[f] = new _SchemeButton(style::NAMES[f], style::FONTS[f] != nullptr);
                _colors[f]->callback(_SchemeDialog::CallbackColorButton, this);
                _grid->add(_colors[f], 39, 6 + f * 5, 10, 4);
            }
            if (style::FONTS[f] != nullptr) {
                _font[f] = new Fl_Menu_Button(0, 0, 0, 0);
                _font[f]->add(widgets2::SCHEME_FONT_REGULAR, 0, nullptr, nullptr, FL_MENU_RADIO);
                _font[f]->add(widgets2::SCHEME_FONT_BOLD, 0, nullptr, nullptr, FL_MENU_RADIO);
                _font[f]->add(widgets2::SCHEME_FONT_ITALIC, 0, nullptr, nullptr, FL_MENU_RADIO);
                _font[f]->add(widgets2::SCHEME_FONT_BOLD_ITALIC, 0, nullptr, nullptr, FL_MENU_RADIO);
                _font[f]->callback(_SchemeDialog::CallbackFont, this);
                _font[f]->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
                _font[f]->label(widgets2::SCHEME_FONT_REGULAR);
                _font[f]->textfont(flw::PREF_FONT);
                _font[f]->textsize(flw::PREF_FONTSIZE);
                _font[f]->tooltip(
                    "To use bold and italic fonts the main editor font must have them in right order.\n"
                    "Selected font must be a regular font.\n"
                    "Then the three after the regular font must be:\n"
                    "\"bold\", \"italic\" and \"bold italic\".\n"
                );
                flw::menu::setonly_item(_font[f], widgets2::SCHEME_FONT_REGULAR);
                _grid->add(_font[f], 1, 6 + f * 5, 18, 4);
                if (*style::FONTS[f]) {
                    _attr[f] = new Fl_Menu_Button(0, 0, 0, 0);
                    _attr[f]->add(widgets2::SCHEME_ATTR_NONE, 0, nullptr, nullptr, FL_MENU_RADIO);
                    _attr[f]->add(widgets2::SCHEME_ATTR_GRAMMAR, 0, nullptr, nullptr, FL_MENU_RADIO);
                    _attr[f]->add(widgets2::SCHEME_ATTR_STRIKE, 0, nullptr, nullptr, FL_MENU_RADIO);
                    _attr[f]->add(widgets2::SCHEME_ATTR_UNDERLINE, 0, nullptr, nullptr, FL_MENU_RADIO | FL_MENU_DIVIDER);
                    _attr[f]->callback(_SchemeDialog::CallbackAttr, this);
                    _attr[f]->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
                    _attr[f]->label(widgets2::SCHEME_ATTR_NONE);
                    _attr[f]->textfont(flw::PREF_FONT);
                    _attr[f]->textsize(flw::PREF_FONTSIZE);
                    _attr[f]->tooltip(
                        "Set additional style for text.\n"
                    );
                    flw::menu::setonly_item(_attr[f], widgets2::SCHEME_ATTR_NONE);
                    _grid->add(_attr[f], 20, 6 + f * 5, 18, 4);
                }
                else {
                    _attr[f]   = nullptr;
                }
            }
            else {
                _font[f] = nullptr;
                _attr[f] = nullptr;
            }
            if (f == 3 || f > 6) {
                _bgcolors[f] = new _SchemeButton("", false);
                _bgcolors[f]->callback(_SchemeDialog::CallbackColorButton, this);
                _grid->add(_bgcolors[f], 127, 6 + f * 5, 10, 4);
                _bgattr[f] = new Fl_Menu_Button(0, 0, 0, 0);
                _bgattr[f]->add(widgets2::SCHEME_ATTR_BGCOLOR_NONE, 0, nullptr, nullptr, FL_MENU_RADIO);
                _bgattr[f]->add(widgets2::SCHEME_ATTR_BGCOLOR, 0, nullptr, nullptr, FL_MENU_RADIO);
                _bgattr[f]->add(widgets2::SCHEME_ATTR_BGCOLOR_EXT, 0, nullptr, nullptr, FL_MENU_RADIO);
                _bgattr[f]->callback(_SchemeDialog::CallbackAttr, this);
                _bgattr[f]->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
                _bgattr[f]->textfont(flw::PREF_FONT);
                _bgattr[f]->textsize(flw::PREF_FONTSIZE);
                _bgattr[f]->tooltip(
                    "Turn on background color.\n"
                    "Set also new color."
                );
                flw::menu::setonly_item(_bgattr[f], widgets2::SCHEME_ATTR_BGCOLOR_NONE);
                _grid->add(_bgattr[f], 100, 6 + f * 5, 26, 4);
            }
            else {
                _bgattr[f]   = nullptr;
                _bgcolors[f] = nullptr;
            }
        }
        _grid->add(_reset,  -34,  -5,  16,   4);
        _grid->add(_close,  -17,  -5,  16,   4);
        add(_grid);
        init_widgets();
        _close->callback(_SchemeDialog::Callback, this);
        _close->tooltip("Save changes and close dialog.");
        _reset->callback(_SchemeDialog::Callback, this);
        _reset->tooltip("Reset colors values to default values for the current scheme.");
        flw::util::labelfont(this);
        copy_label(fle::APPLICATION != "" ? (fle::APPLICATION + " - Color Scheme").c_str() : "Color Scheme");
        callback(_SchemeDialog::Callback, this);
        set_modal();
        resizable(_grid);
        resize(0, 0, flw::PREF_FONTSIZE * 78, flw::PREF_FONTSIZE * 51);
    }
    static void Callback(Fl_Widget* w, void* o) {
        auto self = static_cast<_SchemeDialog*>(o);
        if (w == self->_close) {
            self->_run = false;
            self->save_scheme();
            self->hide();
            self->_config.send_message(message::PREF_CHANGED);
        }
        else if (w == self->_reset) {
            self->reset_scheme();
            self->_config.send_message(message::PREF_CHANGED);
        }
    }
    static void CallbackAttr(Fl_Widget* w, void* o) {
        auto self  = static_cast<_SchemeDialog*>(o);
        auto menu  = static_cast<Fl_Menu_Button*>(w);
        auto label = gnu::str::to_string(menu->text());
        menu->copy_label(label.c_str());
        self->save_scheme();
        self->_config.send_message(message::PREF_CHANGED);
        Fl::redraw();
    }
    static void CallbackColorButton(Fl_Widget* w, void* o) {
        auto self   = static_cast<_SchemeDialog*>(o);
        auto button = static_cast<_SchemeButton*>(w);
        if (Fl::event_command() != 0) {
            size_t index = self->get_index(button);
            if (index >= style::STYLE_LAST) {
                return;
            }
            auto prop = self->_config.style_prop(static_cast<style::STYLE>(index));
            prop->reset();
            self->init_attr(self->_attr[index], prop->attr());
            self->init_font(self->_font[index], prop->font());
            if (button->is_bg_button() == true) {
                button->set_color(prop->bgcolor());
            }
            else {
                button->set_color(prop->color());
            }
        }
        else if (Fl::event_button() == FL_RIGHT_MOUSE) {
            button->copy_color();
        }
        else if (Fl::event_button() == FL_MIDDLE_MOUSE) {
            button->paste_color();
        }
        else {
            button->set_new_color();
        }
        self->save_scheme();
        self->_config.send_message(message::PREF_CHANGED);
        Fl::redraw();
    }
    static void CallbackFont(Fl_Widget* w, void* o) {
        auto self  = static_cast<_SchemeDialog*>(o);
        auto menu  = static_cast<Fl_Menu_Button*>(w);
        auto label = gnu::str::to_string(menu->text());
        menu->copy_label(label.c_str());
        self->save_scheme();
        self->_config.send_message(message::PREF_CHANGED);
        Fl::redraw();
    }
    static void CallbackScheme(Fl_Widget*, void* o) {
        auto self  = static_cast<_SchemeDialog*>(o);
        auto label = gnu::str::to_string(self->_scheme->text());
        if (label == "") {
            return;
        }
        self->save_scheme();
        self->_config.pref_scheme = label;
        self->init_widgets();
        flw::menu::setonly_item(self->_scheme, label.c_str());
        self->_scheme->copy_label(label.c_str());
        self->_config.send_message(message::PREF_CHANGED);
    }
    size_t get_index(Fl_Widget* widget) {
        for (size_t f = 0; f < style::STYLE_LAST; f++) {
            if (_colors[f] == widget || _bgcolors[f] == widget || _font[f] == widget) {
                return f;
            }
        }
        return -1;
    }
    void init_attr(Fl_Menu_Button* attr, int value) {
        if (attr == nullptr) {
            return;
        }
        std::string l = widgets2::SCHEME_ATTR_NONE;
        if (value == Fl_Text_Display::ATTR_GRAMMAR) {
            l = widgets2::SCHEME_ATTR_GRAMMAR;
        }
        else if (value == Fl_Text_Display::ATTR_STRIKE_THROUGH) {
            l = widgets2::SCHEME_ATTR_STRIKE;
        }
        else if (value == Fl_Text_Display::ATTR_UNDERLINE) {
            l = widgets2::SCHEME_ATTR_UNDERLINE;
        }
        attr->copy_label(l.c_str());
        flw::menu::setonly_item(attr, l.c_str());
    }
    void init_bgattr(Fl_Menu_Button* attr, int value) {
        if (attr == nullptr) {
            return;
        }
        std::string l = widgets2::SCHEME_ATTR_BGCOLOR_NONE;
        if (value == Fl_Text_Display::ATTR_BGCOLOR) {
            l = widgets2::SCHEME_ATTR_BGCOLOR;
        }
        else if (value == Fl_Text_Display::ATTR_BGCOLOR_EXT) {
            l = widgets2::SCHEME_ATTR_BGCOLOR_EXT;
        }
        attr->copy_label(l.c_str());
        flw::menu::setonly_item(attr, l.c_str());
    }
    void init_font(Fl_Menu_Button* font, int value) {
        if (font == nullptr) {
            return;
        }
        std::string l = widgets2::SCHEME_FONT_REGULAR;
        if (value == 3) {
            l = widgets2::SCHEME_FONT_BOLD_ITALIC;
        }
        else if (value == 2) {
            l = widgets2::SCHEME_FONT_ITALIC;
        }
        else if (value == 1) {
            l = widgets2::SCHEME_FONT_BOLD;
        }
        font->copy_label(l.c_str());
        flw::menu::setonly_item(font, l.c_str());
    }
    void init_widgets() {
        for (size_t f = 0; f < style::STYLE_LAST; f++) {
            auto prop = _config.style_prop(static_cast<style::STYLE>(f));
            init_attr(_attr[f], prop->attr());
            init_bgattr(_bgattr[f], prop->bgattr());
            init_font(_font[f], prop->font());
            _colors[f]->set_color(prop->color());
            if (_bgcolors[f] != nullptr) {
                _bgcolors[f]->set_color(prop->bgcolor());
            }
        }
    }
    void reset_scheme() {
        _config.init_scheme_to_default();
        init_widgets();
        Fl::redraw();
    }
    void run() {
        _run = true;
        flw::util::center_window(this, Fl::first_window());
        show();
        while (_run == true) {
            Fl::wait();
            Fl::flush();
        }
    }
    void save_scheme() {
        for (size_t f = 0; f < style::STYLE_LAST; f++) {
            auto attr    = _attr[f];
            auto bgattr  = _bgattr[f];
            auto bgcolor = _bgcolors[f];
            auto color   = _colors[f];
            auto font    = _font[f];
            auto prop    = _config.style_prop(static_cast<style::STYLE>(f));
            prop->color_u = color->color();
            if (bgcolor != nullptr && bgcolor->color() != FL_BACKGROUND_COLOR) {
                prop->bgcolor_u = bgcolor->color();
            }
            if (attr != nullptr) {
                auto label = gnu::str::to_string(attr->label());
                prop->attr_u = 0;
                if (label == widgets2::SCHEME_ATTR_GRAMMAR) {
                    prop->attr_u = Fl_Text_Display::ATTR_GRAMMAR;
                }
                else if (label == widgets2::SCHEME_ATTR_STRIKE) {
                    prop->attr_u = Fl_Text_Display::ATTR_STRIKE_THROUGH;
                }
                else if (label == widgets2::SCHEME_ATTR_UNDERLINE) {
                    prop->attr_u = Fl_Text_Display::ATTR_UNDERLINE;
                }
            }
            if (bgattr != nullptr) {
                auto label = gnu::str::to_string(bgattr->label());
                prop->bgattr_u = 0;
                if (label == widgets2::SCHEME_ATTR_BGCOLOR) {
                    prop->bgattr_u = Fl_Text_Display::ATTR_BGCOLOR;
                }
                else if (label == widgets2::SCHEME_ATTR_BGCOLOR_EXT) {
                    prop->bgattr_u = Fl_Text_Display::ATTR_BGCOLOR_EXT;
                }
            }
            if (font != nullptr) {
                auto label = gnu::str::to_string(font->label());
                prop->bold_u   = false;
                prop->italic_u = false;
                if (label == widgets2::SCHEME_FONT_BOLD) {
                    prop->bold_u = true;
                }
                else if (label == widgets2::SCHEME_FONT_ITALIC) {
                    prop->italic_u = true;
                }
                else if (label == widgets2::SCHEME_FONT_BOLD_ITALIC) {
                    prop->bold_u   = true;
                    prop->italic_u = true;
                }
            }
        }
    }
};
void dlg::scheme(Config& config) {
    auto dlg = _SchemeDialog(config);
    dlg.run();
}
class _TweakDialog : public Fl_Double_Window {
    Fl_Box*                     _label;
    Fl_Button*                  _close;
    Fl_Button*                  _reset;
    Fl_Button*                  _save;
    Fl_Check_Button*            _force;
    Fl_Hor_Slider*              _auto_file_size;
    Fl_Hor_Slider*              _auto_lines;
    Fl_Hor_Slider*              _auto_word_size;
    Fl_Hor_Slider*              _backup_file_size;
    Fl_Hor_Slider*              _count_char;
    Fl_Hor_Slider*              _file_size;
    Fl_Hor_Slider*              _out_lines;
    Fl_Hor_Slider*              _out_line_length;
    Fl_Hor_Slider*              _scroll;
    Fl_Hor_Slider*              _style_size;
    Fl_Hor_Slider*              _wrap_length;
    flw::GridGroup*             _grid;
    bool                        _run;
public:
    _TweakDialog() :
    Fl_Double_Window(0, 0, 10, 10) {
        end();
        _auto_file_size   = new Fl_Hor_Slider(0, 0, 0, 0);
        _auto_lines       = new Fl_Hor_Slider(0, 0, 0, 0);
        _auto_word_size   = new Fl_Hor_Slider(0, 0, 0, 0);
        _backup_file_size = new Fl_Hor_Slider(0, 0, 0, 0);
        _close            = new Fl_Button(0, 0, 0, 0, "&Close");
        _count_char       = new Fl_Hor_Slider(0, 0, 0, 0);
        _file_size        = new Fl_Hor_Slider(0, 0, 0, 0);
        _force            = new Fl_Check_Button(0, 0, 0, 0, "Force style update on every text change");
        _grid             = new flw::GridGroup(0, 0, w(), h());
        _label            = new Fl_Box(0, 0, 0, 0);
        _out_line_length  = new Fl_Hor_Slider(0, 0, 0, 0);
        _out_lines        = new Fl_Hor_Slider(0, 0, 0, 0);
        _reset            = new Fl_Button(0, 0, 0, 0, "Reset");
        _save             = new Fl_Button(0, 0, 0, 0, "Save");
        _scroll           = new Fl_Hor_Slider(0, 0, 0, 0);
        _style_size       = new Fl_Hor_Slider(0, 0, 0, 0);
        _wrap_length      = new Fl_Hor_Slider(0, 0, 0, 0);
        _run              = false;
        _grid->add(_force,              1,   1,  -1,   4);
        _grid->add(_file_size,          1,   8,  -1,   4);
        _grid->add(_style_size,         1,  16,  -1,   4);
        _grid->add(_backup_file_size,   1,  24,  -1,   4);
        _grid->add(_auto_lines,         1,  32,  -1,   4);
        _grid->add(_auto_file_size,     1,  40,  -1,   4);
        _grid->add(_auto_word_size,     1,  48,  -1,   4);
        _grid->add(_out_lines,          1,  56,  -1,   4);
        _grid->add(_out_line_length,    1,  64,  -1,   4);
        _grid->add(_wrap_length,        1,  72,  -1,   4);
        _grid->add(_count_char,         1,  80,  -1,   4);
        _grid->add(_scroll,             1,  88,  -1,   4);
        _grid->add(_label,              1,  94,  -1,  10);
        _grid->add(_reset,            -51,  -5,  16,   4);
        _grid->add(_save,             -34,  -5,  16,   4);
        _grid->add(_close,            -17,  -5,  16,   4);
        add(_grid);
        flw::util::labelfont(this);
        _auto_file_size->align(FL_ALIGN_TOP | FL_ALIGN_LEFT);
        _auto_file_size->callback(_TweakDialog::Callback, this);
        _auto_file_size->color(FL_BACKGROUND2_COLOR);
        _auto_file_size->range(limits::AUTOCOMPLETE_FILESIZE_MIN, limits::AUTOCOMPLETE_FILESIZE_MAX);
        _auto_file_size->precision(0);
        _auto_file_size->step((int) limits::AUTOCOMPLETE_FILESIZE_STEP);
        _auto_file_size->value(limits::AUTOCOMPLETE_FILESIZE_VAL);
        _auto_lines->align(FL_ALIGN_TOP | FL_ALIGN_LEFT);
        _auto_lines->callback(_TweakDialog::Callback, this);
        _auto_lines->color(FL_BACKGROUND2_COLOR);
        _auto_lines->range(limits::AUTOCOMPLETE_LINES_MIN, limits::AUTOCOMPLETE_LINES_MAX);
        _auto_lines->precision(0);
        _auto_lines->step((int) limits::AUTOCOMPLETE_LINES_STEP);
        _auto_lines->value(limits::AUTOCOMPLETE_LINES_VAL);
        _auto_word_size->align(FL_ALIGN_TOP | FL_ALIGN_LEFT);
        _auto_word_size->callback(_TweakDialog::Callback, this);
        _auto_word_size->color(FL_BACKGROUND2_COLOR);
        _auto_word_size->range(limits::AUTOCOMPLETE_WORD_SIZE_MIN, limits::AUTOCOMPLETE_WORD_SIZE_MAX);
        _auto_word_size->precision(0);
        _auto_word_size->step((int) limits::AUTOCOMPLETE_WORD_SIZE_STEP);
        _auto_word_size->value(limits::AUTOCOMPLETE_WORD_SIZE_VAL);
        _backup_file_size->align(FL_ALIGN_TOP | FL_ALIGN_LEFT);
        _backup_file_size->callback(_TweakDialog::Callback, this);
        _backup_file_size->color(FL_BACKGROUND2_COLOR);
        _backup_file_size->range(limits::FILE_BACKUP_SIZE_MIN, limits::FILE_BACKUP_SIZE_MAX);
        _backup_file_size->precision(0);
        _backup_file_size->step((int) limits::FILE_BACKUP_SIZE_STEP);
        _backup_file_size->value(limits::FILE_BACKUP_SIZE_VAL);
        _close->callback(_TweakDialog::Callback, this);
        _count_char->align(FL_ALIGN_TOP | FL_ALIGN_LEFT);
        _count_char->callback(_TweakDialog::Callback, this);
        _count_char->color(FL_BACKGROUND2_COLOR);
        _count_char->range(limits::COUNT_CHAR_MIN, limits::COUNT_CHAR_MAX);
        _count_char->precision(0);
        _count_char->step((int) limits::COUNT_CHAR_STEP);
        _count_char->value(limits::COUNT_CHAR_VAL);
        _file_size->align(FL_ALIGN_TOP | FL_ALIGN_LEFT);
        _file_size->callback(_TweakDialog::Callback, this);
        _file_size->color(FL_BACKGROUND2_COLOR);
        _file_size->range(limits::FILE_SIZE_MIN, limits::FILE_SIZE_MAX);
        _file_size->precision(0);
        _file_size->step((int) limits::FILE_SIZE_STEP);
        _file_size->value(limits::FILE_SIZE_VAL);
        _file_size->tooltip("Max size of hex view is 1/5 of file size.");
        _force->tooltip(
            "This will slow down text input considerably for large files (> 1-5MB).\n"
            "Turn on if styling is broken.\n"
            "Markup files are always restyled for every text change."
        );
        _force->value(limits::FORCE_RESTYLING);
        _label->align(FL_ALIGN_TOP | FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
        _label->box(FL_BORDER_BOX);
        _label->label(
            "Press save to update values.\n"
            "These values will be saved to the preferences file.\n"
            "All values are global and affects all editors running in same instance.\n"
        );
        _out_lines->align(FL_ALIGN_TOP | FL_ALIGN_LEFT);
        _out_lines->callback(_TweakDialog::Callback, this);
        _out_lines->color(FL_BACKGROUND2_COLOR);
        _out_lines->range(limits::OUTPUT_LINES_MIN, limits::OUTPUT_LINES_MAX);
        _out_lines->precision(0);
        _out_lines->step((int) limits::OUTPUT_LINES_STEP);
        _out_lines->value(limits::OUTPUT_LINES_VAL);
        _out_line_length->align(FL_ALIGN_TOP | FL_ALIGN_LEFT);
        _out_line_length->callback(_TweakDialog::Callback, this);
        _out_line_length->color(FL_BACKGROUND2_COLOR);
        _out_line_length->range(limits::OUTPUT_LINE_LENGTH_MIN, limits::OUTPUT_LINE_LENGTH_MAX);
        _out_line_length->precision(0);
        _out_line_length->step((int) limits::OUTPUT_LINE_LENGTH_STEP);
        _out_line_length->value(limits::OUTPUT_LINE_LENGTH_VAL);
        _reset->callback(_TweakDialog::Callback, this);
        _reset->tooltip("Reset all values to default values.");
        _save->callback(_TweakDialog::Callback, this);
        _save->tooltip("Update and save changes.");
        _scroll->align(FL_ALIGN_TOP | FL_ALIGN_LEFT);
        _scroll->callback(_TweakDialog::Callback, this);
        _scroll->color(FL_BACKGROUND2_COLOR);
        _scroll->range(limits::SCROLL_MIN, limits::SCROLL_MAX);
        _scroll->precision(0);
        _scroll->step((int) limits::SCROLL_STEP);
        _scroll->value(limits::SCROLL_VAL);
        _scroll->tooltip(widgets2::CONFIG_SCROLL_WAYLAND);
        _style_size->align(FL_ALIGN_TOP | FL_ALIGN_LEFT);
        _style_size->callback(_TweakDialog::Callback, this);
        _style_size->color(FL_BACKGROUND2_COLOR);
        _style_size->range(limits::STYLE_FILESIZE_MIN, limits::STYLE_FILESIZE_MAX);
        _style_size->precision(0);
        _style_size->step((int) limits::STYLE_FILESIZE_STEP);
        _style_size->value(limits::STYLE_FILESIZE_VAL);
        _wrap_length->align(FL_ALIGN_TOP | FL_ALIGN_LEFT);
        _wrap_length->callback(_TweakDialog::Callback, this);
        _wrap_length->color(FL_BACKGROUND2_COLOR);
        _wrap_length->range(limits::WRAP_LINE_LENGTH_MIN, limits::WRAP_LINE_LENGTH_MAX);
        _wrap_length->precision(0);
        _wrap_length->step((int) limits::WRAP_LINE_LENGTH_STEP);
        _wrap_length->value(limits::WRAP_LINE_LENGTH_VAL);
        _TweakDialog::Callback(_auto_file_size, this);
        _TweakDialog::Callback(_auto_lines, this);
        _TweakDialog::Callback(_auto_word_size, this);
        _TweakDialog::Callback(_backup_file_size, this);
        _TweakDialog::Callback(_count_char, this);
        _TweakDialog::Callback(_file_size, this);
        _TweakDialog::Callback(_out_line_length, this);
        _TweakDialog::Callback(_out_lines, this);
        _TweakDialog::Callback(_scroll, this);
        _TweakDialog::Callback(_style_size, this);
        _TweakDialog::Callback(_wrap_length, this);
        callback(_TweakDialog::Callback, this);
        copy_label(fle::APPLICATION != "" ? (fle::APPLICATION + " - Tweaks").c_str() : "Tweaks");
        set_modal();
        resizable(_grid);
        size(flw::PREF_FONTSIZE * 48, flw::PREF_FONTSIZE * 56);
        flw::util::center_window(this, Fl::first_window());
        _grid->do_layout();
    }
    static void Callback(Fl_Widget* w, void* o) {
        auto self = static_cast<_TweakDialog*>(o);
        if (w == self) {
        }
        else if (w == self->_close) {
            self->_run = false;
            self->hide();
        }
        else if (w == self->_reset) {
            self->reset();
        }
        else if (w == self->_save) {
            self->update();
        }
        else if (w == self->_auto_file_size) {
            auto l = gnu::str::format("Max file size for autocomplete: %s", gnu::str::format_int(self->_auto_file_size->value()).c_str());
            self->_auto_file_size->copy_label(l.c_str());
            self->redraw();
        }
        else if (w == self->_auto_lines) {
            auto l = gnu::str::format("Max lines for autocomplete: %s", gnu::str::format_int(self->_auto_lines->value()).c_str());
            self->_auto_lines->copy_label(l.c_str());
            self->redraw();
        }
        else if (w == self->_auto_word_size) {
            auto l = gnu::str::format("Max word size for autocomplete: %s", gnu::str::format_int(self->_auto_word_size->value()).c_str());
            self->_auto_word_size->copy_label(l.c_str());
            self->redraw();
        }
        else if (w == self->_backup_file_size) {
            auto l = gnu::str::format("Max file size for backups: %s", gnu::str::format_int(self->_backup_file_size->value()).c_str());
            self->_backup_file_size->copy_label(l.c_str());
            self->redraw();
        }
        else if (w == self->_count_char) {
            auto l = gnu::str::format("Max text selection to count utf8 characters: %s", gnu::str::format_int(self->_count_char->value()).c_str());
            self->_count_char->copy_label(l.c_str());
            self->redraw();
        }
        else if (w == self->_file_size) {
            auto l = gnu::str::format("Max file size: %s", gnu::str::format_int(self->_file_size->value()).c_str());
            self->_file_size->copy_label(l.c_str());
            self->redraw();
        }
        else if (w == self->_out_lines) {
            auto l = gnu::str::format("Max lines for output: %s", gnu::str::format_int(self->_out_lines->value()).c_str());
            self->_out_lines->copy_label(l.c_str());
            self->redraw();
        }
        else if (w == self->_out_line_length) {
            auto l = gnu::str::format("Max line length for output: %s", gnu::str::format_int(self->_out_line_length->value()).c_str());
            self->_out_line_length->copy_label(l.c_str());
            self->redraw();
        }
        else if (w == self->_scroll) {
            auto l = gnu::str::format("!! Additional lines for fast mouse scroll mode: %s", gnu::str::format_int(self->_scroll->value()).c_str());
            self->_scroll->copy_label(l.c_str());
            self->redraw();
        }
        else if (w == self->_style_size) {
            auto l = gnu::str::format("Max file size for highlightning: %s", gnu::str::format_int(self->_style_size->value()).c_str());
            self->_style_size->copy_label(l.c_str());
            self->redraw();
        }
        else if (w == self->_wrap_length) {
            auto l = gnu::str::format("Max line length before wrap is turned on file load: %s", gnu::str::format_int(self->_wrap_length->value()).c_str());
            self->_wrap_length->copy_label(l.c_str());
            self->redraw();
        }
    }
    void reset() {
        limits::AUTOCOMPLETE_FILESIZE_VAL  = limits::AUTOCOMPLETE_FILESIZE_DEF;
        limits::AUTOCOMPLETE_LINES_VAL     = limits::AUTOCOMPLETE_LINES_DEF;
        limits::AUTOCOMPLETE_WORD_SIZE_VAL = limits::AUTOCOMPLETE_WORD_SIZE_DEF;
        limits::COUNT_CHAR_VAL             = limits::COUNT_CHAR_DEF;
        limits::FILE_BACKUP_SIZE_VAL       = limits::FILE_BACKUP_SIZE_DEF;
        limits::FILE_SIZE_VAL              = limits::FILE_SIZE_DEF;
        limits::FORCE_RESTYLING            = 0;
        limits::OUTPUT_LINES_VAL           = limits::OUTPUT_LINES_DEF;
        limits::OUTPUT_LINE_LENGTH_VAL     = limits::OUTPUT_LINE_LENGTH_DEF;
        limits::SCROLL_VAL                 = limits::SCROLL_DEF;
        limits::STYLE_FILESIZE_VAL         = limits::STYLE_FILESIZE_DEF;
        limits::WRAP_LINE_LENGTH_VAL       = limits::WRAP_LINE_LENGTH_DEF;
        _force->value(limits::FORCE_RESTYLING);
        _auto_file_size->value(limits::AUTOCOMPLETE_FILESIZE_VAL);
        _auto_lines->value(limits::AUTOCOMPLETE_LINES_VAL);
        _auto_word_size->value(limits::AUTOCOMPLETE_WORD_SIZE_VAL);
        _backup_file_size->value(limits::FILE_BACKUP_SIZE_VAL);
        _count_char->value(limits::COUNT_CHAR_VAL);
        _file_size->value(limits::FILE_SIZE_VAL);
        _out_line_length->value(limits::OUTPUT_LINE_LENGTH_VAL);
        _out_lines->value(limits::OUTPUT_LINES_VAL);
        _scroll->value(limits::SCROLL_VAL);
        _style_size->value(limits::STYLE_FILESIZE_VAL);
        _wrap_length->value(limits::WRAP_LINE_LENGTH_VAL);
        _TweakDialog::Callback(_auto_file_size, this);
        _TweakDialog::Callback(_auto_lines, this);
        _TweakDialog::Callback(_auto_word_size, this);
        _TweakDialog::Callback(_backup_file_size, this);
        _TweakDialog::Callback(_count_char, this);
        _TweakDialog::Callback(_file_size, this);
        _TweakDialog::Callback(_out_line_length, this);
        _TweakDialog::Callback(_out_lines, this);
        _TweakDialog::Callback(_scroll, this);
        _TweakDialog::Callback(_style_size, this);
        _TweakDialog::Callback(_wrap_length, this);
        _label->label("Settings has been reset to default values.");
    }
    void run() {
        _run = true;
        show();
        while (_run == true) {
            Fl::wait();
            Fl::flush();
        }
    }
    void update() {
        limits::AUTOCOMPLETE_FILESIZE_VAL  = _auto_file_size->value();
        limits::AUTOCOMPLETE_LINES_VAL     = _auto_lines->value();
        limits::AUTOCOMPLETE_WORD_SIZE_VAL = _auto_word_size->value();
        limits::COUNT_CHAR_VAL             = _count_char->value();
        limits::FILE_BACKUP_SIZE_VAL       = _backup_file_size->value();
        limits::FILE_SIZE_VAL              = _file_size->value();
        limits::FORCE_RESTYLING            = _force->value();
        limits::OUTPUT_LINES_VAL           = _out_lines->value();
        limits::OUTPUT_LINE_LENGTH_VAL     = _out_line_length->value();
        limits::SCROLL_VAL                 = _scroll->value();
        limits::STYLE_FILESIZE_VAL         = _style_size->value();
        limits::WRAP_LINE_LENGTH_VAL       = _wrap_length->value();
        _label->label("Settings has been updated.");
    }
};
void dlg::tweaks() {
    auto dlg = _TweakDialog();
    dlg.run();
}
}
#include <FL/fl_ask.H>
namespace fle {
View::View(Config& config, Editor* editor) : Fl_Text_Editor(0, 0, 0, 0), Message(config), _config(config) {
    end();
    _editor = editor;
    buffer(&_editor->buffer());
}
void View::draw() {
    auto& buf1 = _editor->buffer();
    auto& buf2 = _editor->style_buffer();
    if (_config.pref_highlight == false || buf2.length() == 0) {
        Fl_Text_Editor::draw();
        return;
    }
    auto  pos   = insert_position();
    auto  start = 0;
    auto  end   = 0;
    auto  range = 0;
    buf1.get_line_range(pos, start, end);
    range = end - start;
    if (range > 0 && range < 2048) {
        auto style = std::string();
        style.reserve(range);
        for (int f = start; f < end; f++) {
            style += buf2.peek(f);
            buf2.poke(f, style::STYLE_CUR_LINE);
        }
        Fl_Text_Editor::draw();
        for (size_t f = 0; f < style.length(); f++) {
            buf2.poke(start + f, style[f]);
        }
    }
    else {
        auto c = buf2.peek(pos);
        buf2.poke(pos, style::STYLE_CUR_LINE);
        Fl_Text_Editor::draw();
        buf2.poke(pos, c);
    }
}
View::~View() {
    buffer(nullptr);
}
void View::CallbackStyleBuffer(const int pos, const int inserted_size, const int deleted_size, const int restyled_size, const char* deleted_text, void* o) {
    (void) restyled_size;
    auto editor = static_cast<Editor*>(o);
#ifdef DEBUG
#endif
    if (editor->buffer().has_restyle() == false) {
        return;
    }
    else if (editor->style().name() == style::TEXT) {
        return;
    }
    char* deleted_style = nullptr;
    if (deleted_size > 0) {
       editor->style_buffer().remove(pos, pos + deleted_size);
    }
    if (inserted_size > 0) {
        auto buffer = gnu::file::allocate(nullptr, inserted_size + 1);
        memset(buffer, style::STYLE_INIT, inserted_size);
        editor->style_buffer().insert(pos, buffer);
        free(buffer);
    }
    editor->style().update(pos, inserted_size, deleted_size, deleted_text, deleted_style, editor);
    free(deleted_style);
#ifdef DEBUG
    if (editor->buffer().length() != editor->style_buffer().length()) {
        flw::dlg::msg_alert("Error: in View::CallbackStyleBuffer()", flw::util::format("TEXTSIZE=%d, STYLESIZE=%d !!",  editor->buffer().length(), editor->style_buffer().length()));
    }
#endif
}
void View::callback_connect() {
    _editor->buffer().add_modify_callback(View::CallbackStyleBuffer, _editor);
}
void View::callback_disconnect() {
    _editor->buffer().remove_modify_callback(View::CallbackStyleBuffer, _editor);
}
int View::handle(int event) {
    auto ro = _editor->text_is_readonly();
    if (event == FL_DRAG) {
        _editor->update_statusbar();
    }
    if (event == FL_PUSH) {
        if (Fl::event_button() == FL_LEFT_MOUSE && Fl::event_clicks() == 1) {
            _editor->text_select_word();
        }
        else if (Fl::event_button() == FL_RIGHT_MOUSE) {
            _editor->show_menu();
            return 1;
        }
    }
    else if (event == FL_RELEASE) {
        auto r = Fl_Text_Editor::handle(event);
        _editor->update_statusbar();
        return r;
    }
    else if (event == FL_DND_RELEASE) {
        if (ro == true) {
            _editor->statusbar_set_message(errors::TEXT_IS_READ_ONLY);
            return 1;
        }
        _editor->text_set_dnd_event(true);
        return 1;
    }
    else if (event == FL_PASTE) {
        if (ro == true) {
            _editor->statusbar_set_message(errors::TEXT_IS_READ_ONLY);
            return 1;
        }
        else if (_editor->text_has_dnd_event() == true) {
            _editor->text_set_dnd_event(false);
            if (_handle_dnd() == true) {
                return 1;
            }
        }
        else if (Fl::clipboard_contains(Fl::clipboard_plain_text) != 0) {
            _editor->buffer().break_undo_append();
        }
    }
    else if (event == FL_FOCUS) {
        _editor->view_set(this);
        _editor->update_after_focus();
    }
    else if (event == FL_MOUSEWHEEL) {
        if (_handle_mousewheel() == true) {
            return 1;
        }
    }
    else if (event == FL_KEYBOARD) {
        if (ro == true) {
            _editor->statusbar_set_message(errors::TEXT_IS_READ_ONLY);
            _editor->update_statusbar();
            return 0;
        }
        else if (_handle_key() == 1) {
            _editor->update_statusbar();
            return 1;
        }
        else if (Fl::event_key() >= FL_F && Fl::event_key() <= FL_F_Last) {
            return 0;
        }
        else {
            auto r = Fl_Text_Editor::handle(event);
            _editor->update_statusbar();
            return r;
        }
    }
    return Fl_Text_Editor::handle(event);
}
bool View::_handle_dnd() {
    auto str = gnu::str::to_string(Fl::event_text());
    if (str != "") {
        auto discard = false;
        _config.send_message(message::DND_EVENT, str, "", &discard);
        if (discard == false) {
            _editor->buffer().lock_undo_tmp();
        }
        return discard;
    }
    return false;
}
#define FLE_VIEW_CLEAR_KOMMAND_AND_RET(X) if (_editor->text_has_kommand() == true && _editor->statusbar_message() == strings::COMMAND_MODE) { _editor->statusbar_set_message(""); } _editor->text_set_kommand(false); return X;
#define FLE_VIEW_KEY(X) (_config.keys[X].key_u == key && _config.keys[X].alt_u == alt && _config.keys[X].shift_u == shift && _config.keys[X].ctrl_u == ctrl)
#define FLE_VIEW_KOMMAND_KEY(X) (_config.keys[X].key_u == key && _config.keys[X].kommand_u == kommand && _config.keys[X].alt_u == alt && _config.keys[X].shift_u == shift && _config.keys[X].ctrl_u == ctrl)
int View::_handle_key() {
    int  key     = Fl::event_key();
    bool alt     = Fl::event_alt();
    bool ctrl    = Fl::event_ctrl();
    bool shift   = Fl::event_shift();
    bool kommand = _editor->text_has_kommand();
    if (key == FL_Insert) {
        if (_config.pref_insert == true) {
            Fl_Text_Editor::handle(FL_KEYBOARD);
            _editor->update_statusbar();
            if (_editor->view_not_active() != nullptr) {
                _editor->view_not_active()->insert_mode(_editor->view().insert_mode());
            }
        }
        return 1;
    }
    else if (ctrl == true && key == 'v') {
        Fl::paste(*this, 1);
        return 1;
    }
    else if (FLE_VIEW_KEY(FKEY_KOMMAND_START)) {
        _editor->statusbar_set_message(strings::COMMAND_MODE);
        _editor->text_set_kommand(1);
        return 1;
    }
    else if (FLE_VIEW_KOMMAND_KEY(FKEY_KOMMAND_STOP)) {
        FLE_VIEW_CLEAR_KOMMAND_AND_RET(1)
    }
    else if (key == FL_Escape) {
        if (_editor->findreplace().visible() != 0) {
            _config.send_message(message::HIDE_FIND, "", "", &_editor->findreplace());
        }
        FLE_VIEW_CLEAR_KOMMAND_AND_RET(1)
    }
    else if (_editor->text_has_kommand() == true && (key == FL_Right || key == FL_Left || key == FL_Up || key == FL_Down || key == FL_Page_Up || key == FL_Page_Down || key == FL_Home || key == FL_End)) {
        FLE_VIEW_CLEAR_KOMMAND_AND_RET(0)
    }
    else if (FLE_VIEW_KOMMAND_KEY(FKEY_AUTOCOMPLETE)) {
        _editor->autocomplete_show();
        FLE_VIEW_CLEAR_KOMMAND_AND_RET(1)
    }
    else if (FLE_VIEW_KOMMAND_KEY(FKEY_BOOKMARKS_NEXT)) {
        _editor->bookmarks().goto_next();
        FLE_VIEW_CLEAR_KOMMAND_AND_RET(1)
    }
    else if (FLE_VIEW_KOMMAND_KEY(FKEY_BOOKMARKS_PREV)) {
        _editor->bookmarks().goto_prev();
        FLE_VIEW_CLEAR_KOMMAND_AND_RET(1)
    }
    else if (FLE_VIEW_KOMMAND_KEY(FKEY_BOOKMARKS_TOGGLE)) {
        _editor->bookmarks().toggle();
        FLE_VIEW_CLEAR_KOMMAND_AND_RET(1)
    }
    else if (FLE_VIEW_KOMMAND_KEY(FKEY_CASE_LOWER)) {
        _editor->text_convert_case(FCase::LOWER);
        FLE_VIEW_CLEAR_KOMMAND_AND_RET(1)
    }
    else if (FLE_VIEW_KOMMAND_KEY(FKEY_CASE_UPPER)) {
        _editor->text_convert_case(FCase::UPPER);
        FLE_VIEW_CLEAR_KOMMAND_AND_RET(1)
    }
    else if (FLE_VIEW_KOMMAND_KEY(FKEY_COMMENT_BLOCK)) {
        _editor->text_comment_block();
        FLE_VIEW_CLEAR_KOMMAND_AND_RET(1)
    }
    else if (FLE_VIEW_KOMMAND_KEY(FKEY_COMMENT_LINE)) {
        _editor->text_comment_line();
        FLE_VIEW_CLEAR_KOMMAND_AND_RET(1)
    }
    else if (FLE_VIEW_KOMMAND_KEY(FKEY_COPY_TEXT)) {
        if (_editor->buffer().cut_or_copy_line(insert_position(), FCopy::COPY_LINE) == true) {
            FLE_VIEW_CLEAR_KOMMAND_AND_RET(1)
        }
    }
    else if (FLE_VIEW_KOMMAND_KEY(FKEY_CUT_TEXT)) {
        if (_editor->buffer().cut_or_copy_line(insert_position(), FCopy::CUT_LINE)) {
            FLE_VIEW_CLEAR_KOMMAND_AND_RET(1)
        }
    }
    else if (FLE_VIEW_KOMMAND_KEY(FKEY_DELETE_LINE_LEFT)) {
        _editor->buffer().set_backspace_key();
        _editor->buffer().delete_text_left(insert_position(), FDelText::LINE);
        FLE_VIEW_CLEAR_KOMMAND_AND_RET(1)
    }
    else if (FLE_VIEW_KOMMAND_KEY(FKEY_DELETE_LINE_RIGHT)) {
        _editor->buffer().set_delete_key();
        _editor->buffer().delete_text_right(insert_position(), FDelText::LINE);
        FLE_VIEW_CLEAR_KOMMAND_AND_RET(1)
    }
    else if (FLE_VIEW_KOMMAND_KEY(FKEY_DELETE_WORD_LEFT)) {
        _editor->buffer().set_backspace_key();
        auto ret = _editor->buffer().delete_text_left(insert_position(), FDelText::WORD);
        FLE_VIEW_CLEAR_KOMMAND_AND_RET(ret)
    }
    else if (FLE_VIEW_KOMMAND_KEY(FKEY_DELETE_WORD_RIGHT)) {
        _editor->buffer().set_delete_key();
        auto ret = _editor->buffer().delete_text_right(insert_position(), FDelText::WORD);
        FLE_VIEW_CLEAR_KOMMAND_AND_RET(ret)
    }
    else if (FLE_VIEW_KOMMAND_KEY(FKEY_DUP_TEXT)) {
        _editor->buffer().break_undo_append();
        _editor->text_duplicate_line_or_selection();
        FLE_VIEW_CLEAR_KOMMAND_AND_RET(1)
    }
    else if (FLE_VIEW_KOMMAND_KEY(FKEY_ENTER1)) {
        auto pos = _editor->buffer().indent(FIndent::BREAKLINE);
        if (pos.has_cursor() == true) {
            _editor->cursor_move(pos);
            FLE_VIEW_CLEAR_KOMMAND_AND_RET(1)
        }
    }
    else if (FLE_VIEW_KOMMAND_KEY(FKEY_ENTER2)) {
        auto pos = _editor->buffer().indent(FIndent::ADDLINE);
        if (pos.has_cursor() == true) {
            _editor->cursor_move(pos);
            FLE_VIEW_CLEAR_KOMMAND_AND_RET(1)
        }
    }
    else if (FLE_VIEW_KOMMAND_KEY(FKEY_FIND_LINES)) {
        _editor->show_find_lines_dialog_or_run_again(FFindLines::GETINPUT);
        FLE_VIEW_CLEAR_KOMMAND_AND_RET(1)
    }
    else if (FLE_VIEW_KOMMAND_KEY(FKEY_FIND_LINES_AGAIN)) {
        _editor->show_find_lines_dialog_or_run_again(FFindLines::RUNAGAIN);
        FLE_VIEW_CLEAR_KOMMAND_AND_RET(1)
    }
    else if (FLE_VIEW_KOMMAND_KEY(FKEY_GOTO_LINE)) {
        _editor->goto_show();
        FLE_VIEW_CLEAR_KOMMAND_AND_RET(1)
    }
    else if (FLE_VIEW_KOMMAND_KEY(FKEY_HELP)) {
        _editor->help();
        FLE_VIEW_CLEAR_KOMMAND_AND_RET(1)
    }
    else if (FLE_VIEW_KOMMAND_KEY(FKEY_HOME)) {
        if (_editor->home() == true) {
            FLE_VIEW_CLEAR_KOMMAND_AND_RET(1)
        }
    }
    else if (FLE_VIEW_KOMMAND_KEY(FKEY_JUMP_DOWN)) {
        jump(true);
        FLE_VIEW_CLEAR_KOMMAND_AND_RET(1)
    }
    else if (FLE_VIEW_KOMMAND_KEY(FKEY_JUMP_UP)) {
        jump(false);
        FLE_VIEW_CLEAR_KOMMAND_AND_RET(1)
    }
    else if (FLE_VIEW_KEY(FKEY_MENU)) {
        _editor->show_menu();
        FLE_VIEW_CLEAR_KOMMAND_AND_RET(1)
    }
    else if (FLE_VIEW_KOMMAND_KEY(FKEY_MOVE_UP)) {
        _editor->text_move_lines(FMoveV::UP);
        FLE_VIEW_CLEAR_KOMMAND_AND_RET(1)
    }
    else if (FLE_VIEW_KOMMAND_KEY(FKEY_MOVE_DOWN)) {
        _editor->text_move_lines(FMoveV::DOWN);
        FLE_VIEW_CLEAR_KOMMAND_AND_RET(1)
    }
    else if (FLE_VIEW_KOMMAND_KEY(FKEY_OUTPUT_NEXT)) {
        _editor->callback_output(1);
        FLE_VIEW_CLEAR_KOMMAND_AND_RET(1)
    }
    else if (FLE_VIEW_KOMMAND_KEY(FKEY_OUTPUT_PREV)) {
        _editor->callback_output(-1);
        FLE_VIEW_CLEAR_KOMMAND_AND_RET(1)
    }
    else if (FLE_VIEW_KOMMAND_KEY(FKEY_OUTPUT_TOGGLE)) {
        _editor->show_output(FOutput::TOGGLE);
        FLE_VIEW_CLEAR_KOMMAND_AND_RET(1)
    }
    else if (FLE_VIEW_KOMMAND_KEY(FKEY_QUICK_FIND)) {
        _editor->find_quick();
        FLE_VIEW_CLEAR_KOMMAND_AND_RET(1)
    }
    else if (FLE_VIEW_KOMMAND_KEY(FKEY_SELECT_LINE)) {
        _editor->text_select_line();
        FLE_VIEW_CLEAR_KOMMAND_AND_RET(1)
    }
    else if (FLE_VIEW_KOMMAND_KEY(FKEY_SHOW_CUSTOM1)) {
        _config.send_message(message::SHOW_CUSTOM1, "", "", _editor);
        FLE_VIEW_CLEAR_KOMMAND_AND_RET(1)
    }
    else if (FLE_VIEW_KOMMAND_KEY(FKEY_SHOW_CUSTOM2)) {
        _config.send_message(message::SHOW_CUSTOM2, "", "", _editor);
        FLE_VIEW_CLEAR_KOMMAND_AND_RET(1)
    }
    else if (FLE_VIEW_KOMMAND_KEY(FKEY_SHOW_FIND_REPLACE)) {
        _config.send_message(message::SHOW_FIND, "", "", &_editor->findreplace());
        FLE_VIEW_CLEAR_KOMMAND_AND_RET(1)
    }
    else if (FLE_VIEW_KOMMAND_KEY(FKEY_SORT_ASCENDING)) {
        _editor->text_sort_lines(FSort::ASCENDING);
        FLE_VIEW_CLEAR_KOMMAND_AND_RET(1)
    }
    else if (FLE_VIEW_KOMMAND_KEY(FKEY_SORT_DESCENDING)) {
        _editor->text_sort_lines(FSort::DESCENDING);
        FLE_VIEW_CLEAR_KOMMAND_AND_RET(1)
    }
    else if (FLE_VIEW_KOMMAND_KEY(FKEY_SEARCH_BACKWARD)) {
        _editor->find_replace(FSearchDir::BACKWARD);
        FLE_VIEW_CLEAR_KOMMAND_AND_RET(1)
    }
    else if (FLE_VIEW_KOMMAND_KEY(FKEY_SEARCH_FORWARD)) {
        _editor->find_replace(FSearchDir::FORWARD);
        FLE_VIEW_CLEAR_KOMMAND_AND_RET(1)
    }
    else if (FLE_VIEW_KOMMAND_KEY(FKEY_REPLACE)) {
        _editor->find_replace(_editor->find_search_dir(), true);
        FLE_VIEW_CLEAR_KOMMAND_AND_RET(1)
    }
    else if (FLE_VIEW_KOMMAND_KEY(FKEY_REDO)) {
        _editor->redo();
        FLE_VIEW_CLEAR_KOMMAND_AND_RET(1)
    }
    else if (FLE_VIEW_KOMMAND_KEY(FKEY_UNDO)) {
        _editor->undo();
        FLE_VIEW_CLEAR_KOMMAND_AND_RET(1)
    }
    else if (FLE_VIEW_KOMMAND_KEY(FKEY_VIEW_1)) {
        if (&_editor->view() != _editor->view1()) {
            _editor->view1()->take_focus();
        }
        FLE_VIEW_CLEAR_KOMMAND_AND_RET(1)
    }
    else if (FLE_VIEW_KOMMAND_KEY(FKEY_VIEW_2)) {
        if (_editor->view2() != nullptr && &_editor->view() != _editor->view2()) {
            _editor->view2()->take_focus();
        }
        else if (_editor->view2() == nullptr) {
            _editor->view_set_split(_editor->view_split());
        }
        FLE_VIEW_CLEAR_KOMMAND_AND_RET(1)
    }
    else if (FLE_VIEW_KOMMAND_KEY(FKEY_VIEW_CLOSE)) {
        _editor->view_set_split(FSplitView::NO);
        FLE_VIEW_CLEAR_KOMMAND_AND_RET(1)
    }
    else if (FLE_VIEW_KOMMAND_KEY(FKEY_SHIFT_LEFT)) {
        _editor->text_insert_tab_or_move_lines_left_right(FMoveH::LEFT);
        FLE_VIEW_CLEAR_KOMMAND_AND_RET(1)
    }
    else if (FLE_VIEW_KOMMAND_KEY(FKEY_SHIFT_RIGHT)) {
        _editor->text_insert_tab_or_move_lines_left_right(FMoveH::RIGHT);
        FLE_VIEW_CLEAR_KOMMAND_AND_RET(1)
    }
    else if (key == FL_BackSpace) {
        _editor->buffer().set_backspace_key();
        auto res = _editor->buffer().delete_indent(insert_position(), _editor->text_tab_mode(), _editor->text_tab_width());
        FLE_VIEW_CLEAR_KOMMAND_AND_RET(res)
    }
    else if (key == FL_Delete) {
        _editor->buffer().set_delete_key();
        FLE_VIEW_CLEAR_KOMMAND_AND_RET(0)
    }
    else if (FLE_VIEW_KOMMAND_KEY(FKEY_SELECT_PAIR1) || FLE_VIEW_KOMMAND_KEY(FKEY_SELECT_PAIR2)) {
        _editor->select_pair(shift);
        FLE_VIEW_CLEAR_KOMMAND_AND_RET(1)
    }
    else if (FLE_VIEW_KOMMAND_KEY(FKEY_SELECT_STYLE)) {
        _editor->select_color();
        FLE_VIEW_CLEAR_KOMMAND_AND_RET(1)
    }
    else if (kommand == 1) {
        return 1;
    }
    return 0;
}
bool View::_handle_mousewheel() {
    auto dy     = Fl::event_dy();
    auto ctrl   = Fl::event_ctrl() != 0;
    auto alt    = Fl::event_alt() != 0;
    auto lines  = (alt == true) ? fle::limits::SCROLL_VAL + _config.pref_mouse_scroll : _config.pref_mouse_scroll;
    auto scroll = mVScrollBar->value();
    if (ctrl == true && alt == false) {
        if (dy > 0) {
            if (_config.pref_tmp_fontsize == 0) {
                _config.pref_tmp_fontsize = flw::PREF_FIXED_FONTSIZE - 1;
            }
            else if (_config.pref_tmp_fontsize > 6) {
                _config.pref_tmp_fontsize--;
            }
        }
        else if (dy < 0) {
            if (_config.pref_tmp_fontsize == 0) {
                _config.pref_tmp_fontsize = flw::PREF_FIXED_FONTSIZE + 1;
            }
            else if (_config.pref_tmp_fontsize < 72) {
                _config.pref_tmp_fontsize++;
            }
        }
        if (_config.pref_tmp_fontsize != 0) {
            _editor->statusbar_set_message(gnu::str::format("Fontsize changed to %s%d", (_config.pref_tmp_fontsize == flw::PREF_FIXED_FONTSIZE) ? "default " : "", _config.pref_tmp_fontsize));
            _config.send_message(message::FONTSIZE2_CHANGED);
        }
        return true;
    }
    else if (dy > 0 && lines > 0) {
        if (Fl::event_inside(this) != 0) {
            mVScrollBar->value(scroll + lines);
        }
        else {
            return true;
        }
    }
    else if (dy < 0 && lines > 0) {
        if (Fl::event_inside(this) != 0) {
            mVScrollBar->value(scroll - lines);
        }
        else {
            return true;
        }
    }
    return false;
}
void View::init(View* view1) {
    insert_mode(view1->insert_mode());
    update_pref(false);
    take_focus();
}
void View::jump(bool down) {
    auto count = 0;
    auto pos   = insert_position();
    auto lines = static_cast<int>(_config.pref_mouse_scroll) + 3;
    auto& buf  = _editor->buffer();
    while (pos >= 0 && pos <= buf.length() && count < lines) {
        if (down == true && buf[pos++] == '\n') {
            count++;
            move_down();
        }
        else if (down == false && buf[pos--] == '\n') {
            count++;
            move_up();
        }
    }
    if (count > 0) {
        show_insert_position();
    }
}
Message::CTRL View::message(const std::string& message, const std::string&, const std::string&, void*) {
    if (message == message::FONTSIZE2_CHANGED) {
        update_pref(false);
    }
    else if (message == message::FILE_LOADED) {
        update_pref(false);
    }
    else if (message == message::RESET_INSERT_MODE) {
        insert_mode(1);
        if (_editor->view_not_active() != nullptr) {
            _editor->view_not_active()->insert_mode(1);
        }
        _editor->update_statusbar();
    }
    return Message::CTRL::CONTINUE;
}
int View::take_focus() {
    Fl_Text_Editor::take_focus();
    _editor->update_statusbar();
    return 1;
}
bool View::update_pref(bool wrap_for_view2) {
    auto fs         = (_config.pref_tmp_fontsize == 0) ? flw::PREF_FIXED_FONTSIZE : _config.pref_tmp_fontsize;
    auto width      = fs * 3.5;
    auto cursor_pos = insert_position();
    if (_config.pref_tmp_fontsize == flw::PREF_FIXED_FONTSIZE) {
        _config.pref_tmp_fontsize = 0;
    }
    if (_editor->buffer().length() > 200'000'000) {
        width = fs * 6;
    }
    else if (_editor->buffer().length() > 20'000'000) {
        width = fs * 5;
    }
    else if (_editor->buffer().length() > 1'000'000) {
        width = fs * 4.5;
    }
    else if (_editor->buffer().length() > 50'000) {
        width = fs * 4;
    }
    if (_config.pref_linenumber == true) {
        linenumber_width(width);
    }
    else {
        linenumber_width(0);
    }
    if (wrap_for_view2 == true || _editor->wrap_col() != _config.pref_wrap) {
        if (wrap_for_view2 == false) {
            _editor->wrap_set_col(_config.pref_wrap);
        }
        if (_editor->wrap_mode() == FWrap::YES) {
            auto wc = flw::WaitCursor();
            if (_config.pref_wrap == 66) {
                wrap_mode(Fl_Text_Display::WRAP_AT_BOUNDS, 0);
            }
            else {
                wrap_mode(Fl_Text_Display::WRAP_AT_COLUMN, _config.pref_wrap);
            }
        }
        else {
            wrap_mode(Fl_Text_Display::WRAP_NONE, 0);
        }
        wrap_for_view2 = true;
    }
    _config.init_scheme(fs);
    highlight_data(&_editor->style_buffer(), _config.scheme, style::STYLE_LAST + 1, style::STYLE_FG, nullptr, 0);
    color(_config.scheme[style::STYLE_BG - style::STYLE_FG].color, _config.scheme[style::STYLE_BG_SEL - style::STYLE_FG].color);
    cursor_color(_config.scheme[style::STYLE_CURSOR - style::STYLE_FG].color);
    cursor_style(_config.pref_cursor);
    labelsize(flw::PREF_FONTSIZE);
    linenumber_align(FL_ALIGN_RIGHT);
    linenumber_bgcolor(_config.scheme[style::STYLE_BG_NUM - style::STYLE_FG].color);
    linenumber_fgcolor(_config.scheme[style::STYLE_FG_NUM - style::STYLE_FG].color);
    linenumber_font(_config.scheme[style::STYLE_FG_NUM - style::STYLE_FG].font);
    linenumber_format("%4d");
    linenumber_size(fs);
    scrollbar_width(flw::PREF_FONTSIZE);
    textcolor(_config.scheme[style::STYLE_FG - style::STYLE_FG].color);
    textfont(flw::PREF_FIXED_FONT);
    textsize(fs);
    grammar_underline_color(fl_contrast(_config.scheme[style::STYLE_FG - style::STYLE_FG].color, _config.scheme[style::STYLE_BG - style::STYLE_FG].color));
    if (_editor->view1() == this && _editor->text_tab_width() != (unsigned) _editor->buffer().tab_distance()) {
        _editor->buffer().tab_distance(_editor->text_tab_width());
    }
    insert_position(cursor_pos);
    redisplay_range(0, _editor->buffer().length());
    Fl::redraw();
    return wrap_for_view2;
}
}
#include <FL/Fl_Menu_Button.H>
namespace fle {
namespace menu {
#ifdef DEBUG
constexpr const char* DEBUG1                      = "Debug/Widget";
constexpr const char* DEBUG2                      = "Debug/Undo";
constexpr const char* DEBUG3                      = "Debug/Print Style";
constexpr const char* DEBUG4                      = "Debug/Save Style";
constexpr const char* DEBUG5                      = "Debug/Save Style with no Pos";
constexpr const char* DEBUG6                      = "Debug/Print Style Info";
constexpr const char* DEBUG7                      = "Debug/Compare Text with File";
#endif
constexpr const char* BOOKMARKS_CLEAR             = "Bookmarks/Clear";
constexpr const char* BOOKMARKS_NEXT              = "Bookmarks/Next";
constexpr const char* BOOKMARKS_PREV              = "Bookmarks/Previous";
constexpr const char* BOOKMARKS_TOGGLE            = "Bookmarks/Toggle";
constexpr const char* CASE_LOWER                  = "Case/lowercase";
constexpr const char* CASE_UPPER                  = "Case/UPPERCASE";
constexpr const char* COMMENT_BLOCK               = "Comment/Toggle Block";
constexpr const char* COMMENT_LINE                = "Comment/Toggle Line";
constexpr const char* EDIT_COPY                   = "Copy";
constexpr const char* EDIT_CUT                    = "Cut";
constexpr const char* EDIT_PASTE                  = "Paste";
constexpr const char* FIND_LINES                  = "Find Lines...";
constexpr const char* KEYBOARD                    = "Keyboard Config...";
constexpr const char* HELP                        = "Help...";
constexpr const char* OUTPUT_HORIZONTAL           = "Output/Horizontal";
constexpr const char* OUTPUT_TOGGLE               = "Output/Toggle";
constexpr const char* OUTPUT_VERTICAL             = "Output/Vertical";
constexpr const char* PRINT                       = "Print...";
constexpr const char* REDO                        = "Undo/Redo";
constexpr const char* REDO_ALL                    = "Undo/Redo All";
constexpr const char* REDO_SAVEPOINT              = "Undo/Redo to Savepoint or Last";
constexpr const char* SCHEME                      = "Color Scheme...";
constexpr const char* SETTINGS                    = "Settings...";
constexpr const char* SORT_LINES_ASCENDING        = "Sort/Ascending";
constexpr const char* SORT_LINES_DESCENDING       = "Sort/Descending";
constexpr const char* SPLIT_CLOSE                 = "Split View/Close";
constexpr const char* SPLIT_HOR                   = "Split View/Horizontal";
constexpr const char* SPLIT_VER                   = "Split View/Vertical";
constexpr const char* TRIM_TRAILING               = "Trim Trailing Whitespace";
constexpr const char* TWEAKS                      = "Tweaks...";
constexpr const char* UNDO                        = "Undo/Undo";
constexpr const char* UNDO_ALL                    = "Undo/Undo All";
constexpr const char* UNDO_SAVEPOINT              = "Undo/Undo to Savepoint or First";
constexpr const char* UPDATE_AUTOCOMPLETE         = "Update/Autocomplete";
constexpr const char* UPDATE_STYLE                = "Update/Style";
constexpr const char* WRAP                        = "Word Wrap";
}
#define FLE_EDITOR_CB(X)                    [](Fl_Widget*, void* o) { static_cast<Editor*>(o)->X; static_cast<Editor*>(o)->take_focus(); }, this
#define FLE_EDITOR_CB_CONFIG(X)             [](Fl_Widget*, void* o) { X(static_cast<Editor*>(o)->_config); static_cast<Editor*>(o)->take_focus(); }, this
#define FLE_EDITOR_RETURN_IF_READONLY_0()   if (text_is_readonly() == true) { statusbar_set_message(errors::TEXT_IS_READ_ONLY); return; }
#define FLE_EDITOR_RETURN_IF_READONLY_1(X)  if (text_is_readonly() == true) { statusbar_set_message(errors::TEXT_IS_READ_ONLY); return (X); }
Editor::Editor(Config& config, FindBar* findbar, int X, int Y, int W, int H) :
Fl_Group(X, Y, W, H),
Message(config),
_bookmarks(this),
_config(config),
_editor_flags() {
    assert(findbar);
    end();
    _style        = nullptr;
    _findbar      = findbar;
    _autocomplete = nullptr;
    _custom       = nullptr;
    _regex        = new gnu::pcre8::PCRE();
    _buf1         = new TextBuffer(this, _config);
    _buf2         = new TextBuffer(nullptr, _config);
    _editors      = new flw::SplitGroup();
    _goto         = new GotoLine();
    _main         = new flw::SplitGroup();
    _menu         = new Fl_Menu_Button(0, 0, 0, 0);
    _output       = new flw::ScrollBrowser();
    _view1        = new View(_config, this);
    _view2        = nullptr;
    _view         = _view1;
    _main->add(_editors, true);
    _main->add(_output, false);
    _editors->add(_view1, true);
    _editors->min_split_pos(70);
    add(_main);
    add(_menu);
    add(_goto);
    _main->pos(flw::SplitGroup::Pos::HORIZONTAL);
    _output->callback(Editor::CallbackOutput, this);
    _output->hide();
    _output->textfont(flw::PREF_FONT);
    _output->when(FL_WHEN_ENTER_KEY_CHANGED);
    _findbar->findreplace().hide();
    _goto->callback(Editor::CallbackGoto, this);
    callback_connect();
    if (_config.active == nullptr) {
        _config.active = this;
        _findbar->findreplace().callback(Editor::CallbackFind, this);
    }
    build_menu();
    tooltip("");
    style(nullptr);
    update_pref();
    box(FL_THIN_DOWN_BOX);
}
Editor::~Editor() {
    if (_config.active == this) {
        _config.active = nullptr;
    }
    _view  = nullptr;
    _view1 = nullptr;
    _view2 = nullptr;
    _editors->add(nullptr, true);
    _editors->add(nullptr, false);
    delete _regex;
    delete _style;
    delete _buf1;
    delete _buf2;
}
void Editor::activate() {
    Fl_Group::activate();
    _view1->activate();
    _findbar->findreplace().activate();
    _findbar->statusbar().activate();
    if (_view2 != nullptr) {
        _view2->activate();
    }
}
void Editor::autocomplete_callback() {
    auto selected = _autocomplete->selected();
    auto word     = _autocomplete->word();
    auto word_pos = _autocomplete->word_pos();
    if (selected != "" && selected != word && word_pos <= text_length()) {
        auto start = selected.find(word);
        if (start != std::string::npos) {
           selected.erase(0, word.length());
        }
        auto i = _buf1->get_indent(word_pos);
        gnu::str::replace(selected, "|", std::string("\n") + i);
        _buf1->insert(word_pos, selected.c_str());
        cursor_move_to_pos(word_pos + selected.size(), true);
    }
    autocomplete_remove();
}
void Editor::autocomplete_remove() {
    if (_autocomplete == nullptr) {
        take_focus();
        return;
    }
    _autocomplete->callback(nullptr, nullptr);
    remove(_autocomplete);
    Fl::delete_widget(_autocomplete);
    _autocomplete = nullptr;
    Fl::redraw();
    Fl::flush();
    take_focus();
}
void Editor::autocomplete_show() {
    FLE_EDITOR_RETURN_IF_READONLY_0()
    auto fs  = _tmp_fixed_fontsize();
    auto X   = 0;
    auto Y   = 0;
    auto W   = fs * 18;
    auto H   = fs * 14;
    auto pos = cursor_insert_position();
    if (_custom != nullptr) {
        return;
    }
    else if (_autocomplete != nullptr) {
        autocomplete_remove();
    }
    _autocomplete = new AutoComplete("autocomplete");
    auto word     = _buf1->get_letters_to_left(cursor_insert_position());
    add(_autocomplete);
    if (_words.size() == 0 || _view->position_to_xy(pos, &X, &Y) == 0) {
        return autocomplete_remove();
    }
    else if (_autocomplete->populate(fs, _words, word, pos) == 0) {
        return autocomplete_remove();
    }
    if (X + W > x() + w()) {
        X = x() + w() - W;
    }
    if (Y + H - y() > h() - fs) {
        Y -= (H + fs);
        Y -= 4;
    }
    else {
        Y += 4;
    }
    _autocomplete->callback(Editor::CallbackAutoComplete, this);
    _autocomplete->popup(X, Y + fs, W, H);
    _autocomplete->take_focus();
    Fl::redraw();
    Fl::flush();
}
void Editor::build_menu() {
    _menu->clear();
#ifdef DEBUG
    _menu->add(menu::DEBUG1, 0,                                                             FLE_EDITOR_CB(debug()));
    _menu->add(menu::DEBUG2, 0,                                                             FLE_EDITOR_CB(debug(2)), FL_MENU_DIVIDER);
    _menu->add(menu::DEBUG3, 0,                                                             FLE_EDITOR_CB(debug(1)));
    _menu->add(menu::DEBUG4, 0,                                                             FLE_EDITOR_CB(debug_save_style("style.txt")));
    _menu->add(menu::DEBUG5, 0,                                                             FLE_EDITOR_CB(debug_save_style("style.txt", false)));
    _menu->add(menu::DEBUG6, 0,                                                             FLE_EDITOR_CB(style().debug()), FL_MENU_DIVIDER);
    _menu->add(menu::DEBUG7, 0,                                                             FLE_EDITOR_CB(file_compare_buffer()));
#endif
    _menu->add(menu::EDIT_CUT,              FL_CTRL + 'x',                                  FLE_EDITOR_CB(text_cut_to_clipboard()));
    _menu->add(menu::EDIT_COPY,             FL_CTRL + 'c',                                  FLE_EDITOR_CB(text_copy_to_clipboard()));
    _menu->add(menu::EDIT_PASTE,            FL_CTRL + 'v',                                  FLE_EDITOR_CB(text_insert_from_clipboard()), FL_MENU_DIVIDER);
    _menu->add(menu::HELP,                  _config.keys[FKEY_HELP].to_int(),               FLE_EDITOR_CB(help()));
    _menu->add(menu::SETTINGS,              0,                                              FLE_EDITOR_CB_CONFIG(ShowSetup));
    _menu->add(menu::SCHEME,                0,                                              FLE_EDITOR_CB_CONFIG(ShowScheme));
    _menu->add(menu::KEYBOARD,              0,                                              FLE_EDITOR_CB_CONFIG(ShowKeyboardSetup));
    _menu->add(menu::TWEAKS,                0,                                              FLE_EDITOR_CB(ShowTweaks()), FL_MENU_DIVIDER);
    _menu->add(menu::PRINT   ,              0,                                              FLE_EDITOR_CB(show_print()));
    _menu->add(menu::TRIM_TRAILING,         0,                                              FLE_EDITOR_CB(text_remove_trailing()));
    _menu->add(menu::FIND_LINES,            _config.keys[FKEY_FIND_LINES].to_int(),         FLE_EDITOR_CB(show_find_lines_dialog_or_run_again(FFindLines::GETINPUT)));
    _menu->add(menu::WRAP,                  0,                                              FLE_EDITOR_CB(wrap_toggle_mode()), FL_MENU_DIVIDER | FL_MENU_TOGGLE);
    _menu->add(menu::SPLIT_CLOSE,           _config.keys[FKEY_VIEW_CLOSE].to_int(),         FLE_EDITOR_CB(view_set_split(FSplitView::NO)));
    _menu->add(menu::SPLIT_HOR,             0,                                              FLE_EDITOR_CB(view_set_split(FSplitView::HORIZONTAL)));
    _menu->add(menu::SPLIT_VER,             0,                                              FLE_EDITOR_CB(view_set_split(FSplitView::VERTICAL)));
    _menu->add(menu::OUTPUT_TOGGLE,         _config.keys[FKEY_OUTPUT_TOGGLE].to_int(),      FLE_EDITOR_CB(show_output(FOutput::TOGGLE)));
    _menu->add(menu::OUTPUT_HORIZONTAL,     0,                                              FLE_EDITOR_CB(show_output(FOutput::SHOW_HORIZONTAL)));
    _menu->add(menu::OUTPUT_VERTICAL,       0,                                              FLE_EDITOR_CB(show_output(FOutput::SHOW_VERTICAL)));
    _menu->add(menu::COMMENT_LINE,          _config.keys[FKEY_COMMENT_LINE].to_int(),       FLE_EDITOR_CB(text_comment_line()));
    _menu->add(menu::COMMENT_BLOCK,         _config.keys[FKEY_COMMENT_BLOCK].to_int(),      FLE_EDITOR_CB(text_comment_block()));
    _menu->add(menu::CASE_LOWER,            _config.keys[FKEY_CASE_LOWER].to_int(),         FLE_EDITOR_CB(text_convert_case(FCase::LOWER)));
    _menu->add(menu::CASE_UPPER,            _config.keys[FKEY_CASE_UPPER].to_int(),         FLE_EDITOR_CB(text_convert_case(FCase::UPPER)));
    _menu->add(menu::SORT_LINES_ASCENDING,  _config.keys[FKEY_SORT_ASCENDING].to_int(),     FLE_EDITOR_CB(text_sort_lines(FSort::ASCENDING)));
    _menu->add(menu::SORT_LINES_DESCENDING, _config.keys[FKEY_SORT_DESCENDING].to_int(),    FLE_EDITOR_CB(text_sort_lines(FSort::DESCENDING)));
    _menu->add(menu::BOOKMARKS_NEXT,        _config.keys[FKEY_BOOKMARKS_NEXT].to_int(),     FLE_EDITOR_CB(_bookmarks.goto_next()));
    _menu->add(menu::BOOKMARKS_PREV,        _config.keys[FKEY_BOOKMARKS_PREV].to_int(),     FLE_EDITOR_CB(_bookmarks.goto_prev()), FL_MENU_DIVIDER);
    _menu->add(menu::BOOKMARKS_TOGGLE,      _config.keys[FKEY_BOOKMARKS_TOGGLE].to_int(),   FLE_EDITOR_CB(_bookmarks.toggle()));
    _menu->add(menu::BOOKMARKS_CLEAR,       0,                                              FLE_EDITOR_CB(_bookmarks.clear()));
    _menu->add(menu::UNDO,                  _config.keys[FKEY_UNDO].to_int(),               FLE_EDITOR_CB(undo(FUndoRange::ONE)));
    _menu->add(menu::UNDO_SAVEPOINT,        0,                                              FLE_EDITOR_CB(undo(FUndoRange::SAVEPOINT)));
    _menu->add(menu::UNDO_ALL,              0,                                              FLE_EDITOR_CB(undo(FUndoRange::ALL)), FL_MENU_DIVIDER);
    _menu->add(menu::REDO,                  _config.keys[FKEY_REDO].to_int(),               FLE_EDITOR_CB(redo(FUndoRange::ONE)));
    _menu->add(menu::REDO_SAVEPOINT,        0,                                              FLE_EDITOR_CB(redo(FUndoRange::SAVEPOINT)));
    _menu->add(menu::REDO_ALL,              0,                                              FLE_EDITOR_CB(redo(FUndoRange::ALL)));
    _menu->add(menu::UPDATE_AUTOCOMPLETE,   0,                                              FLE_EDITOR_CB(update_autocomplete()));
    _menu->add(menu::UPDATE_STYLE,          0,                                              FLE_EDITOR_CB(style().update()));
    _menu->type(Fl_Menu_Button::POPUP3);
}
void Editor::CallbackAutoComplete(Fl_Widget*, void* o) {
    auto self = static_cast<Editor*>(o);
    self->autocomplete_callback();
}
void Editor::CallbackCustom(Fl_Widget*, void* o) {
    auto self = static_cast<Editor*>(o);
    self->custom_callback();
}
void Editor::CallbackFind(Fl_Widget* w, void* o) {
    auto  self = static_cast<Editor*>(o);
    auto& f    = self->findreplace();
    if (self->text_is_readonly() == true) {
        self->statusbar_set_message(errors::TEXT_IS_READ_ONLY);
    }
    else if (w == f.find_input()) {
        self->find_replace(self->_editor_flags.fsearchdir);
    }
    else if (w == f.next_button()) {
        self->_editor_flags.fsearchdir = FSearchDir::FORWARD;
        self->find_replace(FSearchDir::FORWARD);
    }
    else if (w == f.prev_button()) {
        self->_editor_flags.fsearchdir = FSearchDir::BACKWARD;
        self->find_replace(self->_editor_flags.fsearchdir);
    }
    else if (w == f.replace_button()) {
        self->find_replace(self->_editor_flags.fsearchdir, true);
    }
    else if (w == f.replace_all_button()) {
        self->find_replace_all(f.find_string(), f.replace_string(), f.fnltab(), f.fselection(), f.fcasecompare(), f.fwordcompare(), f.fregex(), FSaveWord::YES, FHideFind::YES);
    }
    else if (w == f.replace_input()) {
        self->find_replace(self->_editor_flags.fsearchdir, true);
    }
}
void Editor::CallbackGoto(Fl_Widget*, void* o) {
    auto self = static_cast<Editor*>(o);
    self->goto_callback();
}
void Editor::CallbackOutput(Fl_Widget*, void* o) {
    auto self = static_cast<Editor*>(o);
    self->callback_output();
}
void Editor::callback_output(int add_line) {
    auto row = _output->value();
    if (_regex->is_compiled() == false) {
        return;
    }
    row += add_line;
    if (row < 1) {
        row = _output->size();
    }
    else if (row > _output->size()) {
        row = 1;
    }
    if (row <= _output->size()) {
        auto text1   = _output->text(row);
        auto matches = _regex->exec(text1);
        _output->value(row);
        if (matches.size() > 1) {
            auto line = gnu::str::to_int(_regex->match("line").word());
            auto col  = gnu::str::to_int(_regex->match("col").word());
            cursor_move_to_rowcol(line, col);
            take_focus();
        }
    }
}
int Editor::count_lines() const {
    return _buf1->count_lines(0, _buf1->length());
}
CursorPos Editor::cursor(bool top_set_line) {
    CursorPos res;
    if (_view2 == nullptr) {
        res.pos1 = _view1->insert_position();
        res.drag = _view1->drag_pos();
        if (top_set_line == true) {
            res.top1 = _view1->top_line();
        }
    }
    else if (_view1 == _view) {
        res.pos1 = _view1->insert_position();
        res.pos2 = _view2->insert_position();
        res.drag = _view1->drag_pos();
        if (top_set_line == true) {
            res.top1 = _view1->top_line();
            res.top2 = _view2->top_line();
        }
    }
    else {
        res.pos2 = _view1->insert_position();
        res.pos1 = _view2->insert_position();
        res.drag = _view2->drag_pos();
        res.swap = true;
        if (top_set_line == true) {
            res.top2 = _view1->top_line();
            res.top1 = _view2->top_line();
        }
    }
    auto start = 0;
    auto end   = 0;
    if (_buf1->selection_position(&start, &end) != 0) {
        res.start = start;
        res.end   = end;
    }
    else {
        res.drag = 0;
    }
    return res;
}
void Editor::cursor_move(CursorPos cursor) {
    if (cursor.start > cursor.end) {
        return;
    }
    else if (cursor.is_empty() == true) {
        return;
    }
    auto pos1 = (cursor.swap == false) ? cursor.pos1 : cursor.pos2;
    auto pos2 = (cursor.swap == false) ? cursor.pos2 : cursor.pos1;
    auto top1 = (cursor.swap == false) ? cursor.top1 : cursor.top2;
    auto top2 = (cursor.swap == false) ? cursor.top2 : cursor.top1;
    if (_view2 == nullptr) {
        if (pos1 >= 0) {
            _view1->insert_position(_buf1->utf8_align(pos1));
            _view1->show_insert_position();
        }
        if (top1 >= 0 && wrap_mode() == FWrap::NO) {
            _view1->top_set_line(top1);
        }
    }
    else {
        if (pos1 >= 0) {
            _view1->insert_position(_buf1->utf8_align(pos1));
            _view1->show_insert_position();
        }
        if (top1 >= 0 && wrap_mode() == FWrap::NO) {
            _view1->top_set_line(top1);
        }
        if (pos2 >= 0) {
            _view2->insert_position(_buf1->utf8_align(pos2));
            _view2->show_insert_position();
        }
        if (top2 >= 0 && wrap_mode() == FWrap::NO) {
            _view2->top_set_line(top2);
        }
    }
    if (pos1 >= 0 || pos2 >= 0) {
        auto drag_tmp = cursor.drag;
        if (cursor.start >= 0 && cursor.end > cursor.start) {
            _buf1->select(cursor.start, cursor.end);
        }
        else {
            _buf1->unselect();
            drag_tmp = 0;
        }
        if (drag_tmp >= 0) {
            _view1->drag_set_pos(drag_tmp);
            if (_view2 != nullptr) {
                _view2->drag_set_pos(drag_tmp);
            }
        }
    }
}
void Editor::cursor_move_to_pos(int pos, bool force_unselect) {
    _view->insert_position(_buf1->utf8_align(pos));
    _view->show_insert_position();
    if (force_unselect == true) {
        _buf1->unselect();
    }
    if (_findbar->statusbar().visible() != 0) {
        _findbar->statusbar().redraw();
    }
}
void Editor::cursor_move_to_rowcol(int row, int column) {
    auto pos = _buf1->skip_lines(0, row - 1);
    auto end = _buf1->line_end(pos);
    cursor_move_to_pos(pos + column > end ? end : pos + column - 1, true);
}
void Editor::custom_callback() {
    auto selected = _custom->selected();
    auto event    = _custom->event();
    custom_remove();
    _config.send_message(message::CUSTOM_CALLBACK, selected, event, this);
}
void Editor::custom_remove() {
    if (_custom == nullptr) {
        take_focus();
        return;
    }
    _custom->callback(nullptr, nullptr);
    remove(_custom);
    Fl::delete_widget(_custom);
    _custom = nullptr;
    Fl::redraw();
    Fl::flush();
    take_focus();
}
void Editor::custom_show(const std::set<std::string>& list, const std::string& event, const std::string& word) {
    auto fs  = _tmp_fixed_fontsize();
    auto X   = 0;
    auto Y   = 0;
    auto W   = fs * 18;
    auto H   = fs * 14;
    auto pos = cursor_insert_position();
    if (_autocomplete != nullptr) {
        return;
    }
    else if (_custom != nullptr) {
        custom_remove();
    }
    _custom = new AutoComplete(event);
    add(_custom);
    if (list.size() == 0 || _view->position_to_xy(pos, &X, &Y) == 0) {
        return custom_remove();
    }
    else if (_custom->populate(fs, list, word, pos) == 0) {
        return custom_remove();
    }
    if (X + W > x() + w()) {
        X = x() + w() - W;
    }
    if (Y + H - y() > h() - fs) {
        Y -= (H + fs);
        Y -= 4;
    }
    else {
        Y += 4;
    }
    _custom->callback(Editor::CallbackCustom, this);
    _custom->popup(X, Y + fs, W, H);
    _custom->take_focus();
    Fl::redraw();
    Fl::flush();
}
void Editor::deactivate() {
    Fl_Group::deactivate();
    _view1->deactivate();
    if (_view2 != nullptr) {
        _view2->deactivate();
    }
}
void Editor::debug(int what) {
#ifdef DEBUG
    printf("\n");
    printf("/*\n");
    printf(" *       __ _          ______    _ _ _             \n");
    printf(" *      / _| |     _ _|  ____|  | (_) |            \n");
    printf(" *     | |_| | ___(_|_) |__   __| |_| |_ ___  _ __ \n");
    printf(" *     |  _| |/ _ \\   |  __| / _` | | __/ _ \\| '__|\n");
    printf(" *     | | | |  __/_ _| |___| (_| | | || (_) | |   \n");
    printf(" *     |_| |_|\\___(_|_)______\\__,_|_|\\__\\___/|_|   \n");
    printf(" *                                                 \n");
    printf(" *                                                 \n");
    printf(" */\n");
    printf("\n");
    if (what == 1) {
        printf("%s\n", debug_save_style().c_str());
        _style->debug();
    }
    else if (what == 2) {
        if (_buf1->undo() != nullptr) {
            _buf1->undo()->debug(true);
        }
    }
    else {
        size_t b, s, u;
        auto t = memory_usage(b, s, u);
        printf("\nflw:\n");
        printf("    FONT               = %2d\n", flw::PREF_FONT);
        printf("    FONTNAME           = '%s'\n", flw::PREF_FONTNAME.c_str());
        printf("    FONTSIZE           = %2d\n", flw::PREF_FONTSIZE);
        printf("    FIXED_FONT         = %2d\n", flw::PREF_FIXED_FONT);
        printf("    FIXED_FONTNAME     = '%s'\n", flw::PREF_FIXED_FONTNAME.c_str());
        printf("    FIXED_FONTSIZE     = %2d\n", flw::PREF_FIXED_FONTSIZE);
        printf("\nWindow:\n");
        if (top_window() != nullptr) {
            printf("    (x, y, w, h)       = %04d, %04d, %04d, %04d\n", top_window()->x(), top_window()->y(), top_window()->w(), top_window()->h());
        }
        _config.debug();
        printf("\nEditor:\n");
        printf("    this               = %p\n", this);
        printf("    id                 = %9d\n", object_id());
        printf("    autocomplete words = %9d\n", (int) _words.size());
        printf("    changed_name       = '%s'\n", filename_short_changed().c_str());
        printf("    output_regex       = %9d\n", _regex ? 1 : 0);
        printf("    buffer length      = %9llu\n", (long long unsigned) b);
        printf("    style length       = %9llu\n", (long long unsigned) s);
        printf("    undo capacity      = %9llu\n", (long long unsigned) u);
        printf("    total              = %9llu\n", (long long unsigned) t);
        printf("\nView:\n");
        printf("    view               = %9s\n", _view == _view1 ? _view2 ? "view1 (view2)" : "view1" : "view2 (view1)");
        printf("    view.id            = %9d\n", _view->object_id());
        printf("    view1.cursor       = %9d\n", _view1->insert_position());
        printf("    view1.dragPos      = %9d\n", _view1->drag_pos());
        printf("    view1.dragType     = %9d\n", _view1->drag_type());
        printf("    view2.cursor       = %9d\n", _view2 ? _view2->insert_position() : -1);
        printf("    view2.dragPos      = %9d\n", _view2 ? _view2->drag_pos() : -1);
        printf("    view2.dragType     = %9d\n", _view2 ? _view2->drag_type() : -1);
        printf("\nStyle:\n");
        printf("    style              = '%s'\n", _style->name().c_str());
        cursor(true).debug(__LINE__, __FILE__);
        _statusbar_info.debug();
        _file_info.debug();
        _editor_flags.debug();
        _bookmarks.debug();
        _buf1->debug();
        if (_buf1->undo() != nullptr) {
            _buf1->undo()->debug(false);
        }
    }
    printf("\n");
    fflush(stdout);
#else
    (void) what;
#endif
}
std::string Editor::debug_save_style(std::string filename, bool add_pos) const {
#ifdef DEBUG
    int line = 1;
    std::string h;
    h.reserve(_buf1->length());
    if (add_pos == true) {
        h += gnu::str::format("%6d: %8d: ", line, 0);
    }
    for (auto f = 0; f < _buf2->length(); f++) {
        auto c = _buf1->byte_at(f);
        auto s = _buf2->byte_at(f);
        if (c == '\n') {
            line++;
            h += s;
            if (add_pos == true) {
                h += gnu::str::format("\n%6d: %8d: ", line, f);
            }
            else {
                h += gnu::str::format("\n");
            }
        }
        else {
            h += s;
        }
    }
    if (filename != "") {
        auto file = gnu::file::open(filename, "wb");
        if (file == nullptr) {
            return h;
        }
        fwrite(h.c_str(), 1, h.length(), file);
        fclose(file);
    }
    return h;
#else
    (void) filename;
    (void) add_pos;
    return "";
#endif
}
void Editor::file_check_reload() {
    FLE_EDITOR_RETURN_IF_READONLY_0()
    static int RECURSIVE = 0;
    RECURSIVE++;
    if (RECURSIVE == 2) {
        RECURSIVE--;
        return;
    }
    auto file1 = _file_info.fi;
    if (_config.pref_autoreload == false || file1.mtime() == -1) {
        RECURSIVE--;
        return;
    }
    file1 = gnu::file::File(file1.filename());
    if (file1.is_missing() == true && file1.filename() != "") {
        statusbar_set_message(errors::FILE_DELETED);
        text_set_dirty(true);
    }
    else if (file1.is_file() == true && (_file_info.fi.size() != file1.size() || _file_info.fi.mtime() != file1.mtime())) {
        auto reload = true;
        if (text_is_dirty() == true) {
            if (_file_info.reload_time == file1.mtime()) {
                reload = false;
            }
            else if (flw::dlg::msg_ask("Reload File", flw::util::format(info::ASK_RELOAD, file1.c_str()), flw::label::YES, flw::label::NO) == flw::label::NO) {
                reload = false;
                _file_info.reload_time = file1.mtime();
            }
        }
        if (reload == true) {
            auto style_name = _style->name();
            auto pos        = cursor(true);
            auto err        = file_load(file1.filename());
            if (err != "") {
                flw::dlg::msg_alert("Reloading File", err);
            }
            else {
                style_from_language(style_name);
                cursor_move(pos);
                statusbar_set_message(info::FILE_RELOAD);
            }
        }
    }
    RECURSIVE--;
}
void Editor::file_compare_buffer() {
    auto mem = gnu::file::read(filename_long());
    if (mem.c_str() != nullptr) {
        auto t = text_get_buffer(file_line_ending(), FTrim::NO, FChecksum::NO);
        if (mem != t) {
            flw::dlg::msg_alert("Buffer Error", flw::util::format(errors::TEXT_DIFF_FROM_FILE.c_str(), _file_info.fi.c_str()));
        }
        else {
            flw::dlg::msg("File Compare", info::TEXT_SAME_AS_FILE);
        }
    }
    else {
        flw::dlg::msg_alert("File Error", flw::util::format(errors::LOADING_FILE.c_str(), _file_info.fi.c_str()));
    }
}
std::string Editor::file_load(const std::string& filename, bool force_hex) {
    auto wc      = flw::WaitCursor();
    auto fbuf    = gnu::file::Buf();
    auto fi      = gnu::file::File(filename);
    auto backup1 = filename_backup(fi.filename());
    auto backup2 = backup1 + FileInfo::TodayExt();
    auto line    = FLineEnding::UNIX;
    auto dirty   = false;
    text_set("", FLineEnding::UNIX, FChecksum::NO);
    statusbar_set_message("");
    _file_info.filename_backup_today = "";
    if (gnu::str::is_whitespace(filename) == true) {
        text_set_dirty(false);
        return statusbar_set_message(errors::NO_FILENAME);
    }
    if (fi.is_dir() == true) {
        return statusbar_set_message(gnu::str::format(errors::FILE_IS_DIR.c_str(), fi.c_str()));
    }
    else if (fi.size() > static_cast<int64_t>(limits::FILE_SIZE_VAL)) {
        return statusbar_set_message(gnu::str::format(errors::FILE_TOO_LARGE.c_str(), fi.c_str()));
    }
    else if (fi.size() == -1) {
        auto bak_fi = gnu::file::File(backup1);
        if (bak_fi.size() > 0) {
            fbuf = gnu::file::read(bak_fi.filename());
            if (fbuf.c_str() == nullptr) {
                fbuf = gnu::file::Buf("", 0);
            }
            else {
                statusbar_set_message(info::BACKUP_LOADED);
            }
        }
        else {
            fbuf = gnu::file::Buf("", 0);
        }
        dirty = true;
    }
    else {
        fbuf = gnu::file::read(fi.filename());
        if (fbuf.c_str() == nullptr) {
            return statusbar_set_message(gnu::str::format(errors::LOADING_FILE.c_str(), fi.c_str()));
        }
    }
    auto count = fbuf.count();
    if (count[0] == 0 && force_hex == false) {
        if (count[256] > limits::WRAP_LINE_LENGTH_VAL) {
            wrap_set_mode(FWrap::YES);
            statusbar_set_message(info::FILE_WRAPPED);
        }
        if (count[13] > 0) {
            fbuf = fbuf.remove_cr();
            line = FLineEnding::WINDOWS;
        }
        text_set(fbuf.c_str(), line, FChecksum::YES);
        _file_info.fi = fi;
        if (gnu::file::File(backup2).is_file() == true) {
            _file_info.filename_backup_today = backup2;
        }
    }
    else {
        if (force_hex == true && fbuf.size() > limits::FILE_SIZE_VAL / limits::HEXFILE_DIVIDER) {
            return statusbar_set_message(gnu::str::format(errors::HEX_TOO_LARGE.c_str(), fi.c_str()));
        }
        else if (force_hex == true) {
            fbuf = string::binary_to_hex(fbuf.c_str(), fbuf.size(), _config.pref_binary == FBinFile::HEX_32);
            statusbar_set_message(info::HEX_LOADED);
        }
        else if (_config.pref_binary == FBinFile::NO) {
            return statusbar_set_message(gnu::str::format(errors::LOADING_BIN.c_str(), fi.name().c_str()));
        }
        else if (_config.pref_binary == FBinFile::HEX_16 && fbuf.size() > limits::FILE_SIZE_VAL / limits::HEXFILE_DIVIDER) {
            return statusbar_set_message(gnu::str::format(errors::HEX_TOO_LARGE.c_str(), fi.c_str()));
        }
        else if (_config.pref_binary == FBinFile::HEX_16) {
            fbuf = string::binary_to_hex(fbuf.c_str(), fbuf.size());
            statusbar_set_message(info::HEX_LOADED);
        }
        else if (_config.pref_binary == FBinFile::HEX_32 && fbuf.size() > limits::FILE_SIZE_VAL / limits::HEXFILE_DIVIDER) {
            return statusbar_set_message(gnu::str::format(errors::HEX_TOO_LARGE.c_str(), fi.c_str()));
        }
        else if (_config.pref_binary == FBinFile::HEX_32) {
            fbuf = string::binary_to_hex(fbuf.c_str(), fbuf.size(), true);
            statusbar_set_message(info::HEX_LOADED);
        }
        else {
            fbuf = string::binary_to_text(fbuf.c_str(), fbuf.size());
            statusbar_set_message(info::BIN_LOADED);
        }
        text_set(fbuf.c_str(), FLineEnding::UNIX, FChecksum::NO);
        _file_info.binary = true;
        dirty = true;
    }
    text_set_dirty(dirty, true);
    update_autocomplete(fbuf.c_str());
    _config.send_message(message::FILE_LOADED, "", "", this);
    return "";
}
std::string Editor::file_save() {
    FLE_EDITOR_RETURN_IF_READONLY_1("")
    auto wc      = flw::WaitCursor();
    auto backup1 = gnu::file::File(filename_backup());
    auto text1   = text_get_buffer(file_line_ending(), FTrim::NO, FChecksum::YES);
    auto fi      = gnu::file::File(filename_long());
    auto saved   = false;
    if (text1.size() <= limits::FILE_BACKUP_SIZE_VAL && backup1.filename() != "") {
        auto backup2 = gnu::file::File(backup1.filename() + FileInfo::TodayExt());
        if (fi.size() > 0 && backup2.is_missing() == true) {
            _file_info.filename_backup_today = backup2.filename();
            gnu::file::copy(filename_long(), backup2.filename(), nullptr, nullptr, false);
        }
        else if (backup2.is_file() == true) {
            _file_info.filename_backup_today = backup2.filename();
        }
        if (gnu::file::write(backup1.filename(), text1, false) == true) {
            gnu::file::chmod(backup1.filename(), fi.mode());
        }
    }
    if (_file_info.fi.is_link() == true) {
        auto real = gnu::file::File(filename_long(), true);
        saved = gnu::file::write(real.filename(), text1);
    }
    else {
        saved = gnu::file::write(filename_long(), text1);
    }
    update_autocomplete(text1.c_str());
    if (saved == false) {
        _buf1->checksum_clear();
        return statusbar_set_message(gnu::str::format(errors::SAVE_FILE.c_str(), _file_info.fi.c_str()));
    }
    _buf1->set_save_point();
    _file_info.fi = gnu::file::File(_file_info.fi.filename());
    gnu::file::chmod(filename_long(), fi.mode());
    text_set_dirty(false);
    update_pref();
    cursor_save();
    return "";
}
std::string Editor::file_save_as(const std::string& filename) {
    FLE_EDITOR_RETURN_IF_READONLY_1("")
    _file_info.fi = gnu::file::File(filename);
    return file_save();
}
size_t Editor::find_lines(const std::string& find, FRegex fregex, FTrim ftrim) {
    auto out   = (flw::ScrollBrowser*) _output;
    auto time  = gnu::Time::Milli();
    auto lines = std::vector<std::string>();
    auto rx    = (fregex == FRegex::YES) ? new gnu::pcre8::PCRE(find, true) : nullptr;
    _buf1->find_lines("", find, rx, ftrim, lines);
    out->clear();
    if (lines.size() > 0) {
        for (const auto& line : lines) {
            out->add(line.c_str());
        }
        _regex->compile("\\s*(?<line>\\d+)\\s+-\\s+(?<col>\\d+)|.*", true);
        _regex->set_names({"line", "col"});
        show_output(FOutput::SHOW);
        statusbar_set_message(gnu::str::format(info::FOUND_LINES.c_str(), static_cast<unsigned>(lines.size()), gnu::Time::Milli() - time));
    }
    else {
        _regex->clear();
        statusbar_set_message(gnu::str::format(info::NO_STRING_FOUND.c_str(), find.c_str()));
    }
    take_focus();
    delete rx;
    return lines.size();
}
size_t Editor::find_lines(const std::string& find, FRegex fregex, FTrim ftrim, std::vector<std::string>& out) {
    auto size = out.size();
    auto rx   = (fregex == FRegex::YES) ? new gnu::pcre8::PCRE(find, true) : (gnu::pcre8::PCRE*) nullptr;
    _buf1->find_lines(_file_info.fi.name(), find, rx, ftrim, out);
    delete rx;
    return out.size() - size;
}
void Editor::find_quick() {
    auto start    = 0;
    auto end      = 0;
    auto selected = std::string();
    if (_buf1->get_selection(start, end, false) == true) {
        CursorPos old = cursor(false);
        selected = gnu::str::grab(_buf1->text_range(start, end));
        _findbar->findreplace().find_string(selected);
        _findbar->findreplace().add_find_word(selected);
        CursorPos pos = _buf1->find_replace(selected, nullptr, FSearchDir::FORWARD, FCaseCompare::YES, FWordCompare::NO, FNlTab::NO);
        if (old != pos && pos.has_cursor() == true) {
            auto line = 0;
            auto col  = 0;
            cursor_move(pos);
            if (cursor_pos_to_line_and_col(cursor_insert_position(), line, col) > 0) {
                statusbar_set_message(gnu::str::format(info::FOUND_STRING_LINECOL.c_str(), line, col - selected.length() + 1));
            }
            else {
                statusbar_set_message(gnu::str::format(info::FOUND_STRING_POS.c_str(), pos.pos1));
            }
        }
        else {
            statusbar_set_message(gnu::str::format(info::NO_STRING_FOUND.c_str(), selected.c_str()));
        }
    }
    else {
        text_select_word();
    }
}
bool Editor::find_replace(FSearchDir fsearchdir, bool replace_text) {
    FLE_EDITOR_RETURN_IF_READONLY_1(false)
    auto& fr   = _findbar->findreplace();
    auto  find = fr.find_string();
    if (find == "") {
        if (fr.visible() == 0) {
            _config.send_message(message::SHOW_FIND, "", "", &fr);
        }
        return false;
    }
    auto pos = CursorPos();
    if (fr.fregex() == FRegex::YES) {
        auto rx = gnu::pcre8::PCRE(find, true);
        if (rx.is_compiled() == false) {
            fl_beep(FL_BEEP_ERROR);
            statusbar_set_message(rx.err());
            return false;
        }
        pos = _buf1->find_replace_regex(
            find,
            (replace_text == true) ? fr.replace_string().c_str() : nullptr,
            fr.fnltab()
        );
    }
    else {
        pos = _buf1->find_replace(
            find,
            (replace_text == true) ? fr.replace_string().c_str() : nullptr,
            fsearchdir,
            fr.fcasecompare(),
            fr.fwordcompare(),
            fr.fnltab()
        );
    }
    if (pos.has_cursor() == false) {
        statusbar_set_message(gnu::str::format(info::NO_STRING_FOUND.c_str(), find.c_str()));
        if (fr.visible() != 0) {
            fr.take_focus();
        }
        else {
            take_focus();
        }
        return false;
    }
    auto line = 0;
    auto col  = 0;
    cursor_move(pos);
    _view->display_insert();
    if (cursor_pos_to_line_and_col(cursor_insert_position(), line, col) > 0) {
        int col2 = pos.end - pos.start;
        if (line > 1 && (col == 0 || col2 < 0)) {
            statusbar_set_message(gnu::str::format(info::FOUND_STRING_LINE.c_str(), line - 1));
        }
        else {
            statusbar_set_message(gnu::str::format(info::FOUND_STRING_LINECOL.c_str(), line, col - col2 + 1));
        }
    }
    else {
        statusbar_set_message(gnu::str::format(info::FOUND_STRING_POS.c_str(), pos.pos1));
    }
    _findbar->findreplace().add_find_word(find);
    _findbar->findreplace().add_replace_word((replace_text == true) ? fr.replace_string() : "");
    return true;
}
size_t Editor::find_replace_all(std::string find, std::string replace, FNlTab fnltab, FSelection fselection, FCaseCompare fcase, FWordCompare fword, FRegex fregex, FSaveWord fsave, FHideFind fhide, bool disable_message) {
    FLE_EDITOR_RETURN_IF_READONLY_1(0)
    auto time = gnu::Time::Milli();
    auto pos  = CursorPos();
    if (fregex == FRegex::YES) {
        auto rx = gnu::pcre8::PCRE(find, true);
        if (rx.is_compiled() == false) {
            fl_beep(FL_BEEP_ERROR);
            statusbar_set_message(rx.err());
            return false;
        }
        pos = _buf1->find_replace_regex_all(&rx, replace, fselection, fnltab);
    }
    else {
        pos = _buf1->find_replace_all(find, replace, fselection, fcase, fword, fnltab);
    }
    cursor_move(pos);
    if (_buf1->count_changes() == 0) {
        if (disable_message == false) {
            statusbar_set_message(gnu::str::format(info::NO_STRINGS_REPLACED.c_str(), find.c_str(), replace.c_str()));
        }
        if (_findbar->findreplace().visible() != 0) {
            _findbar->findreplace().take_focus();
        }
    }
    else {
        if (fhide == FHideFind::YES) {
            _config.send_message(message::HIDE_FIND, "", "", &_findbar->findreplace());
        }
        if (fsave == FSaveWord::YES) {
            _findbar->findreplace().add_find_word(find);
            _findbar->findreplace().add_replace_word(replace);
        }
        if (disable_message == false) {
            statusbar_set_message(gnu::str::format(info::REPLACED_STRINGS.c_str(), (unsigned) _buf1->count_changes(), gnu::Time::Milli() - time));
        }
        take_focus();
    }
    return _buf1->count_changes();
}
void Editor::goto_callback() {
    auto line = _goto->line();
    _goto->hide();
    if (line > 0) {
        cursor_move_to_rowcol(line, 1);
    }
}
void Editor::goto_show() {
    auto X   = 0;
    auto Y   = 0;
    auto fs  = _tmp_fixed_fontsize();
    auto W   = fs * 9;
    auto H   = fs * 2;
    auto pos = cursor_insert_position();
    if (_view->position_to_xy(pos, &X, &Y) == 0) {
        X = x() + (w() / 2) - (W / 2);
        Y = y() + (h() / 2) - (H / 2);
    }
    else {
        Y += fs;
        if (X + W > x() + w()) {
            X = x() + w() - W;
        }
        if (Y + H > y() + h()) {
            Y -= (H + fs);
        }
    }
    _goto->popup(fs * 1.4, X, Y, W, H);
    _goto->take_focus();
    Fl::redraw();
    Fl::flush();
}
int Editor::handle(int event) {
    if (event == FL_FOCUS) {
        update_after_focus();
    }
    return Fl_Group::handle(event);
}
void Editor::help() const {
    std::string help;
    help += help::general(_config);
    help += help::flags(_config);
    flw::dlg::list("Help", help, true, 60, 50);
}
bool Editor::home() {
    if (_editor_flags.fwrap == FWrap::YES) {
        return false;
    }
    auto pos = _buf1->home(cursor_insert_position());
    if (pos == -1) {
        return false;
    }
    cursor_move_to_pos(pos, true);
    _buf1->unselect();
    return true;
}
size_t Editor::memory_usage(size_t& buffer, size_t& style, size_t& undo) const {
    buffer = _buf1->length();
    style  = _buf2->length();
    undo   = (_buf1->undo() != nullptr) ? _buf1->undo()->capacity() : 0;
    return buffer + style + undo;
}
Message::CTRL Editor::message(const std::string& message, const std::string& s1, const std::string&, void*) {
    if (message == message::PREF_CHANGED) {
        update_pref();
    }
    else if (message == message::CUSTOM_AUTOCOMPLETE) {
        update_autocomplete();
    }
    else if (message == message::UNDO_MODE_CHANGED) {
        _buf1->undo_set_mode_using_config();
    }
    else if (_config.active == this) {
        if (message == message::STATUSBAR_STYLE_CHANGED) {
            style_from_language(s1);
            take_focus();
            return Message::CTRL::ABORT;
        }
        else if (message == message::STATUSBAR_LINE_UNIX) {
            if (_file_info.flineending == FLineEnding::WINDOWS) {
                buffer().set_dirty(true);
            }
            _file_info.flineending = FLineEnding::UNIX;
            _findbar->statusbar().update_menus(this);
            take_focus();
            return Message::CTRL::ABORT;
        }
        else if (message == message::STATUSBAR_LINE_WIN) {
            if (_file_info.flineending == FLineEnding::UNIX) {
                buffer().set_dirty(true);
            }
            _file_info.flineending = FLineEnding::WINDOWS;
            _findbar->statusbar().update_menus(this);
            take_focus();
            return Message::CTRL::ABORT;
        }
        else if (message == message::STATUSBAR_TAB_CHANGED) {
            _editor_flags.set_tab_from_string(s1);
            _findbar->statusbar().update_menus(this);
            update_pref();
            take_focus();
            return Message::CTRL::ABORT;
        }
        else if (message == message::STATUSBAR_TO_SPACES) {
            text_to_space();
            return Message::CTRL::ABORT;
        }
        else if (message == message::STATUSBAR_TO_TABS) {
            text_to_tab();
            return Message::CTRL::ABORT;
        }
    }
    return Message::CTRL::CONTINUE;
}
int Editor::redo(FUndoRange fundocount) {
    auto count = 0;
    FLE_EDITOR_RETURN_IF_READONLY_1(count)
    if (_buf1->undo() != nullptr) {
        if (fundocount == FUndoRange::SAVEPOINT && _buf1->undo_check_save_point() == true) {
            return 0;
        }
        auto cur = _buf1->redo(fundocount, cursor(false));
        if (_buf1->count_changes() == 0) {
            statusbar_set_message("");
        }
        else {
            cursor_move(cur);
            statusbar_set_message(gnu::str::format(info::REDID_CHANGES.c_str(), _buf1->count_changes()));
            _buf1->undo_check_save_point();
            count = _buf1->count_changes();
        }
    }
    else if (_buf1->undo_mode() == FUndoMode::FLTK) {
        if (fundocount == FUndoRange::ALL) {
            flw::WaitCursor wc;
            while (_buf1->can_redo() == true) {
                count += Fl_Text_Editor::kf_redo(0, _view);
            }
        }
        else {
            count = Fl_Text_Editor::kf_redo(0, _view);
        }
    }
    return count;
}
void Editor::select_color() {
    auto pos = _buf1->select_color();
    cursor_move(pos);
    _view->display_insert();
}
void Editor::select_pair(bool move_cursor) {
    auto found = false;
    auto pos   = _buf1->select_pair(move_cursor, found);
    if (found == false) {
        statusbar_set_message(info::PAIRS);
    }
    else {
        statusbar_set_message("");
        cursor_move(pos);
        _view->display_insert();
    }
}
size_t Editor::show_find_lines_dialog_or_run_again(FFindLines ffindlines) {
    auto        list  = _config.find_list;
    size_t      count = 0;
    std::string find;
    if (ffindlines == FFindLines::RUNAGAIN && list.size() > 0) {
        find = list.front();
    }
    else {
        find = FindDialog("Find Lines", list).run();
    }
    if (find != "") {
        count = find_lines(find, FindDialog::REGEX, FindDialog::TRIM);
        if (count > 0) {
            _findbar->findreplace().add_find_word(find);
        }
    }
    return count;
}
void Editor::show_menu() {
    FLE_EDITOR_RETURN_IF_READONLY_0()
    _menu->size(flw::PREF_FONTSIZE * 14, flw::PREF_FONTSIZE + 8);
    flw::menu::enable_item(_menu, menu::SETTINGS, true);
    flw::menu::enable_item(_menu, menu::BOOKMARKS_CLEAR, _bookmarks.size() > 0);
    flw::menu::enable_item(_menu, menu::BOOKMARKS_TOGGLE, true);
    flw::menu::enable_item(_menu, menu::BOOKMARKS_NEXT, _bookmarks.size() > 0);
    flw::menu::enable_item(_menu, menu::BOOKMARKS_PREV, _bookmarks.size() > 0);
    flw::menu::enable_item(_menu, menu::SPLIT_CLOSE, _view2 != nullptr);
    flw::menu::enable_item(_menu, menu::UPDATE_AUTOCOMPLETE, _config.pref_autocomplete);
    flw::menu::set_item(_menu, menu::WRAP, _editor_flags.fwrap == FWrap::YES);
    auto r = (_buf1->undo() != nullptr) ? _buf1->undo()->has_redo() : _buf1->can_redo();
    auto u = (_buf1->undo() != nullptr) ? _buf1->undo()->has_undo() : _buf1->can_undo();
    auto s = (_buf1->undo_mode() != FUndoMode::NONE && _buf1->undo_mode() != FUndoMode::FLTK) ? true : false;
    flw::menu::enable_item(_menu, menu::REDO, r);
    flw::menu::enable_item(_menu, menu::REDO_ALL, r);
    flw::menu::enable_item(_menu, menu::REDO_SAVEPOINT, r && s);
    flw::menu::enable_item(_menu, menu::UNDO, u);
    flw::menu::enable_item(_menu, menu::UNDO_ALL, u);
    flw::menu::enable_item(_menu, menu::UNDO_SAVEPOINT, u && s);
    if (Fl::clipboard_contains(Fl::clipboard_plain_text) != 0) {
        flw::menu::enable_item(_menu, menu::EDIT_PASTE, true);
    }
    else {
        flw::menu::enable_item(_menu, menu::EDIT_PASTE, false);
    }
    if (_buf1->selected() != 0) {
        flw::menu::enable_item(_menu, menu::EDIT_COPY, true);
        flw::menu::enable_item(_menu, menu::EDIT_CUT, true);
        flw::menu::enable_item(_menu, menu::SORT_LINES_ASCENDING, true);
        flw::menu::enable_item(_menu, menu::SORT_LINES_DESCENDING, true);
        flw::menu::enable_item(_menu, menu::CASE_LOWER, true);
        flw::menu::enable_item(_menu, menu::CASE_UPPER, true);
        flw::menu::enable_item(_menu, menu::COMMENT_BLOCK, true);
    }
    else {
        flw::menu::enable_item(_menu, menu::EDIT_COPY, false);
        flw::menu::enable_item(_menu, menu::EDIT_CUT, false);
        flw::menu::enable_item(_menu, menu::SORT_LINES_ASCENDING, false);
        flw::menu::enable_item(_menu, menu::SORT_LINES_DESCENDING, false);
        flw::menu::enable_item(_menu, menu::CASE_LOWER, false);
        flw::menu::enable_item(_menu, menu::CASE_UPPER, false);
        flw::menu::enable_item(_menu, menu::COMMENT_BLOCK, false);
    }
    _menu->popup();
}
void Editor::show_output(FOutput foutput) {
    if (foutput == FOutput::SHOW_HORIZONTAL || foutput == FOutput::SHOW_VERTICAL) {
        auto dir = (foutput == FOutput::SHOW_HORIZONTAL) ? flw::SplitGroup::Pos::HORIZONTAL : flw::SplitGroup::Pos::VERTICAL;
        if (_main->pos() != dir) {
            _main->pos(dir);
            _main->split_pos(-1);
            _output->hide();
        }
    }
    if (static_cast<Fl_Widget*>(_output)->visible() == 0) {
        _output->show();
        if (_main->split_pos() == -1) {
            if (_main->pos() == flw::SplitGroup::Pos::VERTICAL) {
                _main->split_pos(w() - 200);
            }
            else {
                _main->split_pos(h() - 200);
            }
        }
        do_layout();
    }
    else if (foutput == FOutput::TOGGLE) {
        _output->hide();
        do_layout();
    }
}
void Editor::show_print() {
    auto t = text_get_buffer(FLineEnding::UNIX, FTrim::NO, FChecksum::NO);
    flw::dlg::print_text("Print Text To PostScript", t.c_str());
}
void Editor::style(Style* style) {
    delete _style;
    if (static_cast<size_t>(text_length()) > limits::STYLE_FILESIZE_VAL) {
        delete style;
        style = nullptr;
        statusbar_set_message(info::STYLE_OFF);
    }
    _style = (style == nullptr) ? new Style() : style;
    for (const auto& w : _style->words()) {
        _words.insert(w);
    }
    _editor_flags.tab_mode  = _config.tab_mode(_style->name());
    _editor_flags.tab_width = _config.tab_width(_style->name());
    style_resize_buffer();
    _style->set_buffers(_buf1, _buf2);
    _style->update();
    _view1->redisplay_range(0, _buf1->length());
    if (_view2 != nullptr) {
        _view2->redisplay_range(0, _buf1->length());
    }
    _findbar->statusbar().update_menus(this);
    update_pref();
    Fl::redraw();
}
void Editor::style_resize_buffer() {
    auto size   = (_style->name() == style::TEXT) ? 0 : _buf1->length();
    auto style1 = gnu::file::allocate(nullptr, size + 1);
    memset(style1, style::STYLE_INIT, size);
    _buf2->text(style1);
    free(style1);
}
void Editor::text_comment_block() {
    FLE_EDITOR_RETURN_IF_READONLY_0()
    auto wc  = flw::WaitCursor();
    auto pos = _buf1->comment_block(_style->block_start(), _style->block_end());
    cursor_move(pos);
}
void Editor::text_comment_line() {
    FLE_EDITOR_RETURN_IF_READONLY_0()
    auto pos = _buf1->comment_line(_style->line_comment());
    cursor_move(pos);
}
void Editor::text_convert_case(FCase transform) {
    FLE_EDITOR_RETURN_IF_READONLY_0()
    auto pos = _buf1->case_for_selection(transform);
    cursor_move(pos);
}
int Editor::text_count_selection_len(bool* bytes) const {
    auto length1 = _statusbar_info.end - _statusbar_info.start;
    if (bytes != nullptr && (size_t) length1 <= limits::COUNT_CHAR_VAL) {
        auto t = _buf1->text_range(_statusbar_info.start, _statusbar_info.end);
        auto l = gnu::str::utf_len(t);
        free(t);
        if (l == 0) {
            *bytes = true;
        }
        else {
            length1 = l;
            *bytes = false;
        }
    }
    else if (bytes != nullptr) {
        *bytes = true;
    }
    return length1;
}
void Editor::text_duplicate_line_or_selection() {
    FLE_EDITOR_RETURN_IF_READONLY_0()
    auto pos = _buf1->duplicate_text();
    cursor_move(pos);
}
void Editor::text_insert_tab_or_move_lines_left_right(FMoveH fmoveh) {
    FLE_EDITOR_RETURN_IF_READONLY_0()
    auto cur = cursor(true);
    if (_buf1->has_multiline_selection() == true) {
        cur = _buf1->insert_tab_multiline(cur, fmoveh, text_tab_mode(), text_tab_width());
    }
    else {
        cur = _buf1->insert_tab(cur, text_tab_mode(), text_tab_width());
    }
    cursor_move(cur);
}
void Editor::text_move_lines(FMoveV move) {
    FLE_EDITOR_RETURN_IF_READONLY_0()
    auto pos = _buf1->move_line(move);
    cursor_move(pos);
}
int Editor::text_remove_trailing() {
    FLE_EDITOR_RETURN_IF_READONLY_1(0)
    auto rx  = gnu::pcre8::PCRE("(\\s+)$");
    auto pos = _buf1->find_replace_regex_all(&rx, "", FSelection::NO, FNlTab::NO);
    cursor_move(pos);
    statusbar_set_message(gnu::str::format(info::REMOVED_TRAILING.c_str(), (unsigned) _buf1->count_changes()));
    return _buf1->count_changes();
}
void Editor::text_select_line() {
    auto pos = _buf1->select_line(false);
    cursor_move(pos);
}
void Editor::text_select_word() {
    CursorPos   pos = _buf1->select_word();
    std::string selected;
    if (pos.text_has_selection() == true) {
        selected = gnu::str::grab(_buf1->text_range(pos.start, pos.end));
        _findbar->findreplace().find_string(selected);
        cursor_move(pos);
        statusbar_set_message("");
    }
}
void Editor::text_set(const char* TEXT, FLineEnding flineending, FChecksum fchecksum) {
    FLE_EDITOR_RETURN_IF_READONLY_0()
    assert(TEXT);
    style(nullptr);
    _buf1->set(TEXT, fchecksum);
    _view1->insert_position(0);
    _view1->show_insert_position();
    if (_view2 != nullptr) {
        _view2->insert_position(0);
        _view2->show_insert_position();
    }
    _file_info             = FileInfo();
    _file_info.flineending = flineending;
    _statusbar_info        = StatusBarInfo();
    text_set_dirty(false, true);
}
void Editor::text_set_readonly(bool value) {
    _editor_flags.ro = value;
    if (value == true) {
        _menu->deactivate();
    }
    else {
        _menu->activate();
    }
    update_pref();
}
void Editor::text_sort_lines(FSort order) {
    FLE_EDITOR_RETURN_IF_READONLY_0()
    if (_buf1->selected() == 0) {
        fl_beep(FL_BEEP_NOTIFICATION);
        return;
    }
    auto wc  = flw::WaitCursor();
    auto pos = _buf1->sort(order);
    cursor_move(pos);
}
void Editor::text_to_space() {
    FLE_EDITOR_RETURN_IF_READONLY_0()
    auto count = find_replace_all("\t", strings::SOFT_TABS[text_tab_width()], FNlTab::NO, FSelection::NO, FCaseCompare::NO, FWordCompare::NO, FRegex::NO, FSaveWord::NO, FHideFind::NO, true);
    if (count == 0) {
        statusbar_set_message(info::NO_TABS_REPLACED);
    }
    else {
        statusbar_set_message(gnu::str::format(info::TABS_REPLACED.c_str(), (int) count));
    }
}
void Editor::text_to_tab() {
    FLE_EDITOR_RETURN_IF_READONLY_0()
    auto count = find_replace_all(strings::SOFT_TABS[text_tab_width()], "\t", FNlTab::NO, FSelection::NO, FCaseCompare::NO, FWordCompare::NO, FRegex::NO, FSaveWord::NO, FHideFind::NO, true);
    if (count == 0) {
        statusbar_set_message(info::NO_SPACES_REPLACED);
    }
    else {
        statusbar_set_message(gnu::str::format(info::SPACES_REPLACED.c_str(), (int) count));
    }
}
int Editor::undo(FUndoRange fundocount) {
    auto count = 0;
    FLE_EDITOR_RETURN_IF_READONLY_1(count)
    if (_buf1->undo() != nullptr) {
        if (fundocount == FUndoRange::SAVEPOINT && _buf1->undo_check_save_point() == true) {
            return 0;
        }
        auto cur = _buf1->undo(fundocount, cursor(false));
        if (_buf1->count_changes() == 0) {
            statusbar_set_message("");
        }
        else {
            cursor_move(cur);
            statusbar_set_message(gnu::str::format(info::UNDID_CHANGES.c_str(), _buf1->count_changes()));
            _buf1->undo_check_save_point();
            count = _buf1->count_changes();
        }
    }
    else if (_buf1->undo_mode() == FUndoMode::FLTK) {
        if (fundocount == FUndoRange::ALL) {
            flw::WaitCursor wc;
            while (_buf1->can_undo() == true) {
                count += Fl_Text_Editor::kf_undo(0, _view);
            }
        }
        else {
            count = Fl_Text_Editor::kf_undo(0, _view);
        }
    }
    return count;
}
void Editor::update_after_focus() {
    file_check_reload();
    if (_config.active != this) {
        _config.active = this;
        _findbar->statusbar().update_menus(this);
        _findbar->findreplace().callback(Editor::CallbackFind, this);
        _config.send_message(message::EDITOR_FOCUS, "", "", this);
        update_statusbar();
    }
}
void Editor::update_autocomplete(const char* text) {
    _words.clear();
    if (_config.pref_autocomplete == false || _buf1->length() > static_cast<int>(limits::AUTOCOMPLETE_FILESIZE_VAL) || _file_info.binary == true) {
        return;
    }
    char* tmp = nullptr;
    if (text == nullptr) {
        text = _buf1->text();
        tmp  = const_cast<char*>(text);
    }
    _words = _style->words();
    string::make_word_list(text, _words, _config.custom_words);
    free(tmp);
}
void Editor::update_pref() {
    labelsize(flw::PREF_FONTSIZE);
    _menu->labelfont(flw::PREF_FONT);
    _menu->labelsize(flw::PREF_FONTSIZE);
    _menu->textfont(flw::PREF_FONT);
    _menu->textsize(flw::PREF_FONTSIZE);
    _output->textfont(flw::PREF_FIXED_FONT);
    _output->textsize(flw::PREF_FONTSIZE);
    if (_config.active == this) {
        _findbar->statusbar().update_menus(this);
    }
    auto wrap_for_view2 = _view1->update_pref(false);
    if (_view2 != nullptr) {
        _view2->update_pref(wrap_for_view2);
    }
    if (_config.pref_statusbar == true) {
        _findbar->statusbar().show();
    }
    else {
        _findbar->statusbar().hide();
    }
    if (_config.pref_autocomplete == false) {
        _words.clear();
    }
    else if (_words.size() == 0 && _config.pref_autocomplete == true) {
        update_autocomplete();
    }
    _buf1->undo_set_mode_using_config();
    build_menu();
    Fl_Group::resize(x(), y(), w(), h());
    Fl::redraw();
}
void Editor::update_statusbar() {
    if (_view == nullptr || _view->buffer() == nullptr) {
        return;
    }
    std::string label;
    update_textinfo();
    if (_statusbar_info.has_selection() == true) {
        auto bytes = false;
        auto len   = text_count_selection_len(&bytes);
        auto unit  = (bytes == true) ? "Bytes" : "Chars";
        auto r     = gnu::str::format_int(_statusbar_info.rows, '\'');
        auto l     = gnu::str::format_int(len, '\'');
        if (_statusbar_info.rows > 1) {
            label = gnu::str::format("Lines: %s %s: %s", r.c_str(), unit, l.c_str());
        }
        else {
            label = gnu::str::format("%s: %s", unit, l.c_str());
        }
    }
    else {
        auto r = gnu::str::format_int(_statusbar_info.row, '\'');
        auto c = gnu::str::format_int(_statusbar_info.col + 1, '\'');
        auto p = gnu::str::format_int(_statusbar_info.pos + 1, '\'');
        label = gnu::str::format("Ln: %s  Col: %s  Pos: %s", r.c_str(), c.c_str(), p.c_str());
    }
    _findbar->statusbar().label_cursor(label);
    _findbar->statusbar().label_cursor_mode((_view->insert_mode() == 0) ? "OVR" : "INS");
    if (_buf1->undo() != nullptr && _buf1->undo()->capacity() > (int64_t) limits::UNDO_WARNING) {
        statusbar_set_message(gnu::str::format(info::UNDO_MEMORY.c_str(), (long long int) _buf1->undo()->capacity()));
    }
    if ((size_t) text_length() > limits::STYLE_FILESIZE_VAL && _style->name() != style::TEXT) {
        style(nullptr);
        statusbar_set_message(info::STYLE_OFF);
    }
}
void Editor::update_textinfo() {
    auto start = 0;
    auto end   = 0;
    auto row   = 0;
    auto col   = 0;
    _statusbar_info.pos = _view->insert_position();
    if (cursor_pos_to_line_and_col(_statusbar_info.pos, row, col) > 0) {
        _statusbar_info.row = row;
        _statusbar_info.col = col;
    }
    if (_buf1->selection_position(&start, &end) != 0) {
        if (_statusbar_info.start != start || _statusbar_info.end != end) {
            _statusbar_info.rows  = _buf1->count_lines(start, end);
            _statusbar_info.start = start;
            _statusbar_info.end   = end;
            if (_buf1->line_start(end) < end) {
                _statusbar_info.rows++;
            }
        }
    }
    else {
        _statusbar_info.start = 0;
        _statusbar_info.end   = 0;
        _statusbar_info.rows  = 0;
    }
}
void Editor::view_set_split(FSplitView fsplit) {
    if (fsplit == FSplitView::VERTICAL || fsplit == FSplitView::HORIZONTAL) {
        if (_view2 == nullptr) {
            _view2 = new View(_config, this);
            _editors->add(_view2, false);
            _view2->init(_view1);
        }
        _editors->pos((fsplit == FSplitView::HORIZONTAL) ? flw::SplitGroup::Pos::HORIZONTAL : flw::SplitGroup::Pos::VERTICAL);
        _editor_flags.fsplitview = fsplit;
    }
    else if (_view2 != nullptr) {
        _editors->add(nullptr, false);
        _view2 = nullptr;
        _view = _view1;
    }
    _editors->do_layout();
    Fl::redraw();
}
void Editor::wrap_toggle_mode() {
    wrap_set_mode(flw::menu::item_value(_menu, menu::WRAP) ? FWrap::YES : FWrap::NO);
}
}
static const char * icon_xpm[] = {
"48 48 134 2",
"  	c None",
". 	c #000000",
"+ 	c #010101",
"@ 	c #666666",
"# 	c #A3A3A3",
"$ 	c #5D5D5D",
"% 	c #4B4B4B",
"& 	c #FFFFFF",
"* 	c #FDFDFD",
"= 	c #222222",
"- 	c #646464",
"; 	c #343434",
"> 	c #FEFEFE",
", 	c #D9D9D9",
"' 	c #2C2C2C",
") 	c #141414",
"! 	c #A4A4A4",
"~ 	c #FCFCFC",
"{ 	c #1B1B1B",
"] 	c #262626",
"^ 	c #E9E9E9",
"/ 	c #535353",
"( 	c #0D0D0D",
"_ 	c #676767",
": 	c #D5D5D5",
"< 	c #686868",
"[ 	c #FBFBFB",
"} 	c #292929",
"| 	c #8B8B8B",
"1 	c #A9A9A9",
"2 	c #151515",
"3 	c #C6C6C6",
"4 	c #909090",
"5 	c #AEAEAE",
"6 	c #A6A6A6",
"7 	c #3A3A3A",
"8 	c #D8D8D8",
"9 	c #555555",
"0 	c #050505",
"a 	c #DCDCDC",
"b 	c #4C4C4C",
"c 	c #030303",
"d 	c #EEEEEE",
"e 	c #ADADAD",
"f 	c #0A0A0A",
"g 	c #8D8D8D",
"h 	c #A8A8A8",
"i 	c #161616",
"j 	c #131313",
"k 	c #AFAFAF",
"l 	c #F8F8F8",
"m 	c #0E0E0E",
"n 	c #373737",
"o 	c #747474",
"p 	c #020202",
"q 	c #3B3B3B",
"r 	c #E5E5E5",
"s 	c #4E4E4E",
"t 	c #505050",
"u 	c #E7E7E7",
"v 	c #C2C2C2",
"w 	c #7B7B7B",
"x 	c #BFBFBF",
"y 	c #232323",
"z 	c #090909",
"A 	c #878787",
"B 	c #121212",
"C 	c #7D7D7D",
"D 	c #F3F3F3",
"E 	c #6D6D6D",
"F 	c #353535",
"G 	c #D7D7D7",
"H 	c #D6D6D6",
"I 	c #E6E6E6",
"J 	c #393939",
"K 	c #0B0B0B",
"L 	c #F7F7F7",
"M 	c #242424",
"N 	c #BBBBBB",
"O 	c #F2F2F2",
"P 	c #EFEFEF",
"Q 	c #060606",
"R 	c #494949",
"S 	c #E8E8E8",
"T 	c #DBDBDB",
"U 	c #F9F9F9",
"V 	c #282828",
"W 	c #B1B1B1",
"X 	c #8E8E8E",
"Y 	c #3F3F3F",
"Z 	c #656565",
"` 	c #6C6C6C",
" .	c #D2D2D2",
"..	c #606060",
"+.	c #F6F6F6",
"@.	c #9E9E9E",
"#.	c #707070",
"$.	c #181818",
"%.	c #757575",
"&.	c #080808",
"*.	c #999999",
"=.	c #CDCDCD",
"-.	c #3D3D3D",
";.	c #E2E2E2",
">.	c #5B5B5B",
",.	c #414141",
"'.	c #212121",
").	c #CBCBCB",
"!.	c #1D1D1D",
"~.	c #F0F0F0",
"{.	c #9F9F9F",
"].	c #ECECEC",
"^.	c #838383",
"/.	c #040404",
"(.	c #BCBCBC",
"_.	c #595959",
":.	c #E3E3E3",
"<.	c #989898",
"[.	c #7F7F7F",
"}.	c #BABABA",
"|.	c #F1F1F1",
"1.	c #D0D0D0",
"2.	c #B6B6B6",
"3.	c #EDEDED",
"4.	c #CFCFCF",
"5.	c #9A9A9A",
"6.	c #A7A7A7",
"7.	c #B2B2B2",
"8.	c #2F2F2F",
"9.	c #F4F4F4",
"0.	c #101010",
"a.	c #313131",
"b.	c #737373",
"c.	c #2B2B2B",
"                                                                                                ",
"                                                                                                ",
"                                                                                                ",
"                                                                                                ",
"    . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .       ",
"  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   ",
"  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   ",
". . . + @ # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # $ . . . . ",
". . . % & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & * = . . . ",
". . . - & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & ; . . . ",
". . . - & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & ; . . . ",
". . . - & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & ; . . . ",
". . . - & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & ; . . . ",
". . . - & & & & & & & & & & & & & & & & & & & & & > * & & & & & & & & & & & & & & & & & ; . . . ",
". . . - & & & & & & & & & & & & & & & & & & & & , ' ) ! & & & & & & & & & & & & & & & & ; . . . ",
". . . - & & & & & & & & & & & & & & & & & & & & $ . . ) * & & & & & & & & & & & & & & & ; . . . ",
". . . - & & & & & & & & & & & & ~ & & & & & & > { . . ] & & & & & & & & & & & & & & & & ; . . . ",
". . . - & & & & & & & & & & ^ / ( _ > & & & & : . . . < & [ _ } | ~ & & & & & & & & & & ; . . . ",
". . . - & & & & & & & & & 1 2 . . . 3 & & & & 4 . . . 5 & 6 . . . 7 8 & & & & & & & & & ; . . . ",
". . . - & & & & & & & ^ 9 . . . . 0 a & & & & b . . c d & e . . . . f g ~ & & & & & & & ; . . . ",
". . . - & & & & & & h i . . . . j k & & & & l m . . n & & * o p . . . . q 8 & & & & & & ; . . . ",
". . . - & & & & r s . . . . . t u & & & & & v . . . w & & & & x y . . . . z A [ & & & & ; . . . ",
". . . - & & & h B . . . . j ! & & & & & & & C . . . x & & & & & D E p . . . . F G & & & ; . . . ",
". . . - & & H c . . . . t I & & & & & & & & J . . K L & & & & & & & x M . . . . { L & & ; . . . ",
". . . - & & N . . . . ' O & & & & & & & & P Q . . R & & & & & & & & & S 2 . . . . T & & ; . . . ",
". . . - & & U 7 . . . . V : & & & & & & & W . . . X & & & & & & & & 8 ' . . . . Y * & & ; . . . ",
". . . - & & & L Z . . . . ( h & & & & & & ` . . .  .& & & & & & & e m . . . . ..+.& & & ; . . . ",
". . . - & & & & & @.f . . . . #.U & & & & ] . . $.* & & & & & [ %.+ . . . &.*.& & & & & ; . . . ",
". . . - & & & & & & =.y . . . . -.r & & ;.+ . . >.& & & & & u ,.. . . . '.).& & & & & & ; . . . ",
". . . - & & & & & & & d % . . . . !.~.& {.. . . {.& & & & r !.. . . . R ].& & & & & & & ; . . . ",
". . . - & & & & & & & & * ^./.. . . (.& _.. . + :.& & & & <.. . . c [.* & & & & & & & & ; . . . ",
". . . - & & & & & & & & & & }.2 . !.|.* $.. . V & & & & & 1.Q . B 2.& & & & & & & & & & ; . . . ",
". . . - & & & & & & & & & & & 3.2.P & 1.. . . E & & & & & & 4.5.r & & & & & & & & & & & ; . . . ",
". . . - & & & & & & & & & & & & & & & 6.. . . 7.& & & & & & & & & & & & & & & & & & & & ; . . . ",
". . . - & & & & & & & & & & & & & & & 3.= . 8.L & & & & & & & & & & & & & & & & & & & & ; . . . ",
". . . - & & & & & & & & & & & & & & & & 9.=.l & & & & & & & & & & & & & & & & & & & & & ; . . . ",
". . . - & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & ; . . . ",
". . . - & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & ; . . . ",
". . . - & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & ; . . . ",
". . . } L & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & & d 0.. . . ",
". . . . a.b.b.b.b.b.b.b.b.o b.b.o b.b.o b.b.o b.b.b.b.b.b.b.b.b.b.b.b.b.b.b.b.b.b.b.b.c.. . . . ",
"  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   ",
"    . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .     ",
"      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .       ",
"                                                                                                ",
"                                                                                                ",
"                                                                                                ",
"                                                                                                "};
constexpr static const char* MENU_DEBUG                         = "&Debug/Debug";
constexpr static const char* MENU_DEBUG_COMPARE                 = "&Debug/Compare Buffer with File";
constexpr static const char* MENU_DEBUG_PGO                     = "&PGO";
constexpr static const char* MENU_DEBUG_PGO_RUN                 = "&PGO/Run";
constexpr static const char* MENU_DEBUG_PGO_UNDO                = "&PGO/Undo";
constexpr static const char* MENU_DEBUG_SIZE                    = "&Debug/Debug Size";
constexpr static const char* MENU_FILE_CLOSE                    = "&File/Close File";
constexpr static const char* MENU_FILE_CLOSE_ALL                = "&File/Close All Files";
constexpr static const char* MENU_FILE_NEW                      = "&File/New File";
constexpr static const char* MENU_FILE_NEW_WINDOW               = "&File/New Window";
constexpr static const char* MENU_FILE_OPEN                     = "&File/Open File...";
constexpr static const char* MENU_FILE_OPEN_BACKUP              = "&File/Open Other/Todays Backup File";
constexpr static const char* MENU_FILE_OPEN_HEX                 = "&File/Open Other/File As Hex...";
constexpr static const char* MENU_FILE_OPEN_RECENT              = "&File/Open Recent";
constexpr static const char* MENU_FILE_OPEN_RELOAD              = "&File/Open Other/Reload File...";
constexpr static const char* MENU_FILE_READONLY                 = "&File/Read Only mode";
constexpr static const char* MENU_FILE_QUIT                     = "&File/Quit";
constexpr static const char* MENU_FILE_SAVE                     = "&File/Save";
constexpr static const char* MENU_FILE_SAVE_ALL                 = "&File/Save All Unsaved";
constexpr static const char* MENU_FILE_SAVE_AS                  = "&File/Save As...";
constexpr static const char* MENU_FILE_TERMINATE                = "&File/Terminate";
constexpr static const char* MENU_FIND                          = "F&ind/";
constexpr static const char* MENU_FIND_LINES                    = "F&ind/Find Lines in All Files...";
constexpr static const char* MENU_FIND_REPLACE                  = "F&ind/Replace in All Files...";
constexpr static const char* MENU_FIND_SHOW                     = "F&ind/Show Find";
constexpr static const char* MENU_FIND_TRAILING                 = "F&ind/Remove Trailing Whitespace in All Files";
constexpr static const char* MENU_HELP_ABOUT                    = "&Help/About...";
constexpr static const char* MENU_HELP_EDITOR                   = "&Help/Editor...";
constexpr static const char* MENU_HELP_FLEDIT                   = "&Help/Help...";
constexpr static const char* MENU_HELP_PCRE                     = "&Help/PCRE...";
constexpr static const char* MENU_PROJECT_CLOSE                 = "&Project/Close Project";
constexpr static const char* MENU_PROJECT_CLOSE2                = "&Project/Close Project Without Saving";
constexpr static const char* MENU_PROJECT_DB_CLOSE              = "&Project/Close Database";
constexpr static const char* MENU_PROJECT_DB_DEFRAG             = "&Project/Defrag Database";
constexpr static const char* MENU_PROJECT_DB_OPEN               = "&Project/Open Database...";
constexpr static const char* MENU_PROJECT_DIR                   = "&Project/Set Project Directory...";
constexpr static const char* MENU_PROJECT_LOAD                  = "&Project/Load Project...";
constexpr static const char* MENU_PROJECT_RENAME                = "&Project/Rename Project...";
constexpr static const char* MENU_PROJECT_SAVE                  = "&Project/Save Project";
constexpr static const char* MENU_PROJECT_SAVEAS                = "&Project/Save Project As...";
constexpr static const char* MENU_PROJECT_WORDFILE              = "&Project/Set Custom Autocomplete Wordfile...";
constexpr static const char* MENU_SETTINGS_BACKUP               = "&Settings/Set Backup Directory...";
constexpr static const char* MENU_SETTINGS_EDITOR               = "&Settings/Editor...";
constexpr static const char* MENU_SETTINGS_LOAD_PREF            = "&Settings/Reload Preferences";
constexpr static const char* MENU_SETTINGS_OUTPUT_CLEAR         = "&Settings/Output Group/Clear terminal Every Time";
constexpr static const char* MENU_SETTINGS_OUTPUT_HORIZONTAL    = "&Settings/Output Group/Horizontal";
constexpr static const char* MENU_SETTINGS_OUTPUT_SWAP          = "&Settings/Output Group/Swap Side";
constexpr static const char* MENU_SETTINGS_OUTPUT_UNKNOWN       = "&Settings/Output Group/Show Unknown Characters in Terminal";
constexpr static const char* MENU_SETTINGS_OUTPUT_VERTICAL      = "&Settings/Output Group/Vertical";
constexpr static const char* MENU_SETTINGS_SAVE_PREF            = "&Settings/Save Preferences";
constexpr static const char* MENU_SETTINGS_SCHEME               = "&Settings/Color Scheme...";
constexpr static const char* MENU_SETTINGS_SPLIT_HORIZONTAL     = "&Settings/Split Group/Horizontal";
constexpr static const char* MENU_SETTINGS_SPLIT_VERTICAL       = "&Settings/Split Group/Vertical";
constexpr static const char* MENU_SETTINGS_TAB_G11              = "&Settings/Tabs Group 1/Top";
constexpr static const char* MENU_SETTINGS_TAB_G12              = "&Settings/Tabs Group 1/Bottom";
constexpr static const char* MENU_SETTINGS_TAB_G13              = "&Settings/Tabs Group 1/Left";
constexpr static const char* MENU_SETTINGS_TAB_G14              = "&Settings/Tabs Group 1/Right";
constexpr static const char* MENU_SETTINGS_TAB_G21              = "&Settings/Tabs Group 2/Top";
constexpr static const char* MENU_SETTINGS_TAB_G22              = "&Settings/Tabs Group 2/Bottom";
constexpr static const char* MENU_SETTINGS_TAB_G23              = "&Settings/Tabs Group 2/Left";
constexpr static const char* MENU_SETTINGS_TAB_G24              = "&Settings/Tabs Group 2/Right";
constexpr static const char* MENU_SETTINGS_TAB_DEF              = "&Settings/Tabs Look/Default Tab";
constexpr static const char* MENU_SETTINGS_TAB_BORDER           = "&Settings/Tabs Look/Border Tab";
constexpr static const char* MENU_SETTINGS_TAB_FLAT             = "&Settings/Tabs Look/Flat Tab";
constexpr static const char* MENU_SETTINGS_THEME                = "&Settings/Theme...";
constexpr static const char* MENU_TOOLS_CLEAR_OUTPUT            = "&Tools/Clear Output";
constexpr static const char* MENU_TOOLS_CMD                     = "&Tools/Run Command...";
constexpr static const char* MENU_TOOLS_CMDREPEAT               = "&Tools/Run Last Command";
constexpr static const char* MENU_TOOLS_NEXTOUTPUT              = "&Tools/Next Row in List Output";
constexpr static const char* MENU_TOOLS_PREVOUTPUT              = "&Tools/Previous Row in List Output";
constexpr static const char* MENU_TOOLS_SAVE_CLIPBOARD          = "&Tools/Save Clipboard As Snippet...";
constexpr static const char* MENU_TOOLS_SAVE_SELECTION          = "&Tools/Save Selection As Snippet...";
constexpr static const char* MENU_TOOLS_SAVE_TEXT               = "&Tools/Save Current Text As Snippet";
constexpr static const char* MENU_TOOLS_SNIPPETS                = "&Tools/Snippets...";
constexpr static const char* MENU_VIEW_ACTIVATE_ONE             = "&View/Activate Group 1";
constexpr static const char* MENU_VIEW_ACTIVATE_TWO             = "&View/Activate Group 2";
constexpr static const char* MENU_VIEW_MOVE_TO_LEFT             = "&View/Move All From Right to Left";
constexpr static const char* MENU_VIEW_MOVE_TO_RIGHT            = "&View/Move All From Left to Right";
constexpr static const char* MENU_VIEW_MOVE_OPPOSITE            = "&View/Move File to Opposite Group";
constexpr static const char* MENU_VIEW_SORT_LEFT_TABS_ASC       = "&View/Sort Left Tabs Ascending";
constexpr static const char* MENU_VIEW_SORT_LEFT_TABS_DESC      = "&View/Sort Left Tabs Descending";
constexpr static const char* MENU_VIEW_SORT_RIGHT_TABS_ASC      = "&View/Sort Right Tabs Ascending";
constexpr static const char* MENU_VIEW_SORT_RIGHT_TABS_DESC     = "&View/Sort Right Tabs Descending";
constexpr static const char* MENU_VIEW_TOGGLE_BROWSER           = "&View/Toggle Directory Browser";
constexpr static const char* MENU_VIEW_TOGGLE_FULL              = "&View/Toggle full screen";
constexpr static const char* MENU_VIEW_TOGGLE_MENU              = "&View/Toggle Menu";
constexpr static const char* MENU_VIEW_TOGGLE_ONE               = "&View/Toggle Group 1";
constexpr static const char* MENU_VIEW_TOGGLE_OUTPUT            = "&View/Toggle Output Panel";
constexpr static const char* MENU_VIEW_TOGGLE_TABS              = "&View/Toggle Tabs";
constexpr static const char* MENU_VIEW_TOGGLE_TWO               = "&View/Toggle Group 2";
#ifdef DEBUG
constexpr static const char*    USER_NAME                       = "gnuwimp_test";
#else
constexpr static const char*    USER_NAME                       = "gnuwimp";
#endif
static const bool           ASK_SAVE                            = true;
static const bool           DONT_ASK_SAVE                       = false;
static const bool           CLOSE_EDITOR                        = true;
static const bool           DONT_CLOSE_EDITOR                   = false;
static const bool           OPEN_FILE_USING_REAL_NAME           = false;
static const std::string    NS_PROJECTS                         = "projects";
static const std::string    NS_SNIPPETS                         = "snippets";
static std::string FLEDIT_ABOUT = R"(flEdit r9

Copyright 2024 - 2025 gnuwimp@gmail.com.
Released under the GNU General Public License 3.0
https://github.com/gnuwimp/flEdit.

flEdit is a basic text editor.
Use flEdit with caution and at your own risk.

Third-Party open source code that have been used:
FLTK:   https://www.fltk.org
SQLite: http://www.sqlite.org
PCRE:   https://www.pcre.org
rain:   https://github.com/DOSAYGO-Research/rain

)";
static std::string FLEDIT_HELP = R"(Manage editor tabs with keyboard:
alt + '0' - '9'        select edit view 1 to 10
alt + 'left'           switch to previous editor
alt + 'right'          switch to next editor
alt + shift + 'left'   move current editor to the left/up
alt + shift + 'right'  move current editor to the right/down

shift + ctrl + space to show a list of opened files.

Projects:
Files can be saved to a project and be restored later.
All projects are stored in an sqlite3 database.
So open/create the database first.
To use the built in file browser set a directory first for the project.

Autocomplete:
If it is turned on it will create a word list when the file is opened.
And then every time it is saved.
If custom wordfile has been set (only for projects),
  then those words will be added to each files word list.

Backup files:
If a backup path has been set then the file is also saved there.
If a file has the filename /home/user/world.txt,
  the backup file name will be /backupdir/_home_user_world.txt,
  or something similar for windows.
Also a copy of the file will be saved to /backupdir/_home_user_world.txt.YYYY-MM-DD.

Command:
Run external commands directly from flEdit by using the command menu.
You can either run commands in their own processes or capture the output.

)";
static std::string COMMAND_HELP = R"(Run a command as an external process.
Or run and capture output from an command.
Capturing output is done by appending 2>&1 to your command.
The command is executed in an thread in the background,
  and only one command can be run at the same time.
Display the result in a listbox or a (read only) terminal widget.

Warning:
If you are running an command and it doesn't stop you have to kill it manually!
Either by using some kind of task manager or kill the command from the terminal.

Name:
Enter a unique name to describe the command.

Command:
Enter command to execute.
Use $FILE to replace it with full path of active file.
Use $NAME to replace it with active filename.
Use $PARENT to replace it with directory of active file.
Use $PROJECT to replace it with project directory (if it has been set).
Use $SELECTION to replace it with selected text in current editor (if it has been set).
Use "" around paths that contains spaces.

Work directory:
Optional value.
Enter work directory or use empty to use current.
Use $FILE to use directory of active file.
Use $PARENT to use parent directory of active file.
Use $PROJECT for project directory.
Relative path can be added ($FILE/..).
Use "" around paths that contains spaces.

Run:
Run command in background as an seperate process.
It does no capturing.

Capture:
Run command and capture output to a listbox.
Use optional regular expressions to filter and capture file/line/columns.

Terminal:
Capture all output and send it to terminal widget.

Stream To Terminal:
Read output in chunks and append it to terminal widget.

Filter parser:
Optional value.
Enter a word or regular expression to filter what lines should be captured.
Use "error:" to capture only error lines from gcc.

Line parser:
Optional value.
Enter regular expression to capture filename/line/column data.
They should be named ('file' and optional 'line' and/or 'col').

Use this expression for parsing the output from a compiler like gcc:
(?<file>.+):(?<line>\d+):(?<col>\d+).*
If colors are shown or there are other format problems use -fdiagnostics-plain-output flag.

Parse output from a lua interpreter:
(lua:\s*)(?<file>.*):(?<line>\d+):.*
(.*)\s+(?<file>.*):(?<line>\d+):.*

)";
#include <FL/Fl_File_Chooser.H>
#include <FL/Fl_Input.H>
#include <FL/Fl_Radio_Round_Button.H>
#include <FL/Fl_Return_Button.H>
#include <FL/Fl_Sys_Menu_Bar.H>
#include <FL/Fl_Terminal.H>
#include <FL/fl_ask.H>
#include <thread>
enum class Split {
    SHOW_ONE = 1,
    SHOW_TWO = 2,
    HIDE_ONE = 4,
    HIDE_TWO = 8,
    HOR     = 16,
    VER     = 32,
};
enum class Output {
    RUN,
    CAPTURE_EDITOR,
    CAPTURE_LIST,
    CAPTURE_TERMINAL,
    STREAM_TERMINAL,
    INVALID,
};
struct Command;
typedef std::vector<Command*> CommandVector;
extern fle::Config CONFIG;
extern int KLUDGE;
struct Command {
    static Command*             CURRENT;
    static CommandVector        COMMANDS;
    static gnu::file::Buf       BUF;
    static int                  SELECT_LINE;
    static std::string          LINE_REGEX;
    static std::string          WORKDIR;
    static std::thread*         THREAD;
    static std::vector<std::string> LINES;
    std::string                 name;
    std::string                 command;
    Output                      output;
    std::string                 workpath;
    std::string                 filter_regex;
    std::string                 line_regex;
                                Command()
                                    { output = Output::RUN ; }
                                Command(const std::string& name, const std::string& command, Output output, const std::string& workpath, const std::string& filter_regex, const std::string& line_regex) {
                                    this->name         = name;
                                    this->command      = command;
                                    this->output       = output;
                                    this->workpath     = workpath;
                                    this->filter_regex = filter_regex;
                                    this->line_regex   = line_regex;
                                }
    static Command*             Current(int command);
    static inline bool          Sort(const Command* a, const Command* b) { return a->name < b->name; }
};
class CommandDialog : public Fl_Double_Window {
public:
                                CommandDialog(CommandVector& commands, Command* select);
                                ~CommandDialog();
    Command*                    run(Fl_Window* parent);
    static void                 Callback(Fl_Widget* w, void* o);
private:
    bool                        data_delete();
    void                        data_load();
    void                        data_new(Command* copy = nullptr);
    void                        data_select(Command* select);
    void                        data_set(Output radio = Output::INVALID);
    bool                        data_save(bool force = false);
    int                         row(const Command* command) const;
    void                        test();
    Command*                    _current;
    CommandVector&              _commands;
    Fl_Box*                     _label;
    Fl_Button*                  _copy;
    Fl_Button*                  _delete;
    Fl_Button*                  _execute;
    Fl_Button*                  _help;
    Fl_Button*                  _new;
    Fl_Button*                  _test;
    Fl_Hold_Browser*            _list;
    Fl_Input*                   _command;
    Fl_Input*                   _filter;
    Fl_Input*                   _line;
    Fl_Input*                   _name;
    Fl_Input*                   _string;
    Fl_Input*                   _workpath;
    Fl_Radio_Round_Button*      _capture_list;
    Fl_Radio_Round_Button*      _capture_editor;
    Fl_Radio_Round_Button*      _run;
    Fl_Radio_Round_Button*      _stream_terminal;
    Fl_Radio_Round_Button*      _capture_terminal;
    Fl_Return_Button*           _close;
    bool                        _loop;
    flw::GridGroup*             _grid;
    int                         _last;
    int                         _res;
};
class CommandOutput : public flw::TabsGroup {
public:
    static const int            MAX_BUFFER_SIZE    = 10'000'000;
    static const int            MAX_LIST_LINES     =    100'000;
    static const int            MAX_TERMINAL_LINES =     10'000;
                                CommandOutput(fle::Config& config, fle::FindBar* findbar);
                                ~CommandOutput();
    void                        clear_all()
                                    { clear_editor(); clear_list(); reset_terminal(true); }
    void                        clear_editor()
                                    { _editor->buffer().text(""); Fl::redraw(); }
    void                        clear_list()
                                    { _list->clear(); Fl::redraw(); }
    void                        create_command_thread(std::string workpath, std::string filename, std::string selection);
    fle::Editor*                editor() const
                                    { return _editor; }
    void                        join();
    flw::ScrollBrowser*         list()
                                    { return _list; }
    void                        list_next()
                                    { auto row = (_list->value() == 0) ? 1 : _list->value() + 1; _list->value((row > _list->size()) ? 1 : row); _list->do_callback(); }
    void                        list_prev()
                                    { auto row = (_list->value() == 0) ? _list->size() : _list->value() - 1; _list->value((row < 1) ? _list->size() : row); _list->do_callback(); }
    gnu::pcre8::PCRE&           list_rx()
                                    { return _list_rx; }
    void                        reset_terminal(bool force);
    void                        run_command(const std::string& workpath, const std::string& filename, const std::string& selection, bool repeat);
    void                        set_editor_data(const gnu::file::Buf& buf);
    void                        set_list_data(const std::vector<std::string>& lines, std::string parser, int select);
    void                        set_terminal_data(const gnu::file::Buf& buf);
    void                        show_editor()
                                    { show(); value(_editor); }
    void                        show_list()
                                    { show(); value(_list); }
    void                        show_main_editor();
    void                        show_terminal()
                                    { show(); value(_terminal); }
    void                        update_pref();
    static void                 Join(void* message);
    static void                 ThreadFuncForEditor(std::string cmd, std::string work, CommandOutput* self);
    static void                 ThreadFuncForList(std::string cmd, std::string work, gnu::pcre8::PCRE* filter_regex, std::string line_regex, CommandOutput* self);
    static void                 ThreadFuncForTerminal(std::string cmd, std::string work, CommandOutput* self);
    static void                 ThreadFuncForTerminalStream(std::string cmd, std::string work, CommandOutput* self);
private:
    flw::ScrollBrowser*         _list;
    Fl_Terminal*                _terminal;
    fle::Editor*                _editor;
    gnu::pcre8::PCRE            _list_rx;
};
class DirBrowser : public Fl_Group {
public:
                                DirBrowser();
    std::string                 file() const
                                    { return _file; }
    void                        load_dir(std::string path);
    void                        load_root(std::string path);
    std::string                 path() const
                                    { return _path; }
    void                        resize(int X, int Y, int W, int H) override;
    std::string                 root() const
                                    { return _root; }
    void                        select_file();
    void                        update_pref();
    static void                 Callback(Fl_Widget* w, void* o);
private:
    Fl_Button*                  _refresh;
    Fl_File_Browser*            _browser;
    std::string                 _path;
    std::string                 _root;
    std::string                 _file;
};
class ProjectDialog : public Fl_Double_Window {
public:
                                ProjectDialog(gnu::db2::DB& db);
                                ~ProjectDialog();
    std::string                 run(Fl_Window* parent);
    static void                 Callback(Fl_Widget* w, void* o);
private:
    Fl_Button*                  _cancel;
    Fl_Button*                  _load;
    Fl_Button*                  _remove;
    Fl_Hold_Browser*            _projects;
    flw::GridGroup*             _grid;
    gnu::db2::DB&               _db;
    std::string                 _name;
    bool                        _run;
};
class TextDialog : public Fl_Double_Window {
public:
                                TextDialog(gnu::db2::DB& db);
                                ~TextDialog();
    void                        close();
    void                        delete_text();
    void                        load_text();
    void                        rename_text();
    std::string                 run(Fl_Window* parent);
    void                        update_text();
    static void                 Callback(Fl_Widget* w, void* o);
private:
    Fl_Button*                  _cancel;
    Fl_Button*                  _close;
    Fl_Button*                  _delete;
    Fl_Button*                  _rename;
    Fl_Button*                  _update;
    Fl_Hold_Browser*            _names;
    Fl_Text_Buffer*             _buffer;
    Fl_Text_Editor*             _editor;
    flw::GridGroup*             _grid;
    flw::SplitGroup*            _split;
    gnu::db2::DB&               _db;
    std::string                 _res;
    bool                        _run;
};
class FlEdit : public Fl_Double_Window, fle::Message {
public:
    constexpr static size_t     MAX_SNIPPET_LENGTH = 1'000'000;
    enum class SNIPPET {
                                CLIPBOARD,
                                SELECTION,
                                TEXT,
    };
    std::string                 executable;
                                FlEdit(int W, int H);
                                ~FlEdit();
    void                        callback_list();
    void                        debug();
    void                        debug_compare();
    void                        debug_size()
                                    { flw::debug::print(this); _tabs.tabs1->debug(); }
    void                        do_layout()
                                    { _rect = Fl_Rect(); resize(x(), y(), w(), h()); Fl::redraw(); Fl::check(); }
    bool                        editor_close(fle::Editor* editor, bool ask);
    void                        editor_set_style(fle::Editor* editor, std::string override_style = "");
    void                        editor_take_focus()
                                    { if (_editor != nullptr) _editor->take_focus(); }
    void                        editor_update_status(fle::Editor* editor);
    void                        file_backup();
    void                        file_close();
    void                        file_close_all();
    fle::Editor*                file_load(Fl_Widget* after, const std::string& filename, bool add_recent = true, int line = 0, bool as_hex = false);
    std::vector<std::string>    file_load_dialog();
    void                        file_load_list(Fl_Widget* after, std::vector<std::string> files, std::vector<int> filelines = std::vector<int>(), bool as_hex = false);
    void                        file_new(const std::string& filename);
    void                        file_open(bool as_hex = false)
                                    { file_load_list(_editor, file_load_dialog(), std::vector<int>(), as_hex); }
    void                        file_readonly_mode();
    void                        file_reload()
                                    { file_reload(_editor); }
    void                        file_reload(fle::Editor* editor);
    void                        file_save()
                                    { file_save(_editor); }
    bool                        file_save(fle::Editor* editor);
    bool                        file_save_as()
                                    { return file_save_as(_editor); }
    bool                        file_save_as(fle::Editor* editor);
    void                        file_terminate()
                                    { ::exit(1); }
    int                         handle(int event) override;
    void                        help_about();
    void                        help_editor()
                                    { flw::dlg::list("flEdit - Keyboard Shortcuts", fle::help::general(CONFIG), true, 60, 50); }
    void                        help_fledit();
    void                        help_pcre()
                                    { flw::dlg::list("flEdit - PCRE", fle::help::pcre(), true, 60, 50); }
    void                        new_window();
    void                        pref_load(bool all = true);
    void                        pref_save();
    void                        pref_set_tabslook(Fl_Boxtype boxtype);
    void                        pref_set_tabspos1(flw::TabsGroup::Pos value);
    void                        pref_set_tabspos2(flw::TabsGroup::Pos value);
    bool                        project_close(bool save);
    bool                        project_close_db();
    void                        project_defrag_db();
    bool                        project_exist_in_db(const std::string& project_name);
    void                        project_load_from_db(const std::string& project_name);
    std::vector<std::string>    project_load_list_from_pile(const std::string& key, gnu::pile::Pile& data);
    void                        project_load_snippet_from_db();
    void                        project_open_db();
    void                        project_path();
    void                        project_save_as_to_db(bool rename);
    void                        project_save_list_to_pile(const std::string& key, const std::vector<std::string>& list, gnu::pile::Pile& data);
    void                        project_save_snippet_to_db(SNIPPET snippet, const std::string& clip = "");
    bool                        project_save_to_db()
                                    { return project_save_to_db(_project.name); }
    bool                        project_save_to_db(const std::string& name, const std::string& old_name = "");
    void                        project_wordlist();
    bool                        quit();
    fle::Message::CTRL          message(const std::string& message, const std::string& s1, const std::string& s2, void* p) override;
    void                        resize(int X, int Y, int W, int H) override;
    void                        settings_backup();
    void                        settings_editor()
                                    { fle::dlg::config(CONFIG); }
    void                        settings_load_pref()
                                    { pref_load(false); }
    void                        settings_output_horizontal();
    void                        settings_output_swap()
                                    { _split_edit->swap(); }
    void                        settings_output_vertical();
    void                        settings_save_pref()
                                    { pref_save(); }
    void                        settings_scheme()
                                    { fle::dlg::scheme(CONFIG); }
    void                        settings_split_horizontal()
                                    { flw::menu::setonly_item(_menu, MENU_SETTINGS_SPLIT_HORIZONTAL); split_view(Split::HOR); }
    void                        settings_split_vertical()
                                    { flw::menu::setonly_item(_menu, MENU_SETTINGS_SPLIT_VERTICAL); split_view(Split::VER); }
    void                        settings_tab_g11()
                                    { pref_set_tabspos1(flw::TabsGroup::Pos::TOP); }
    void                        settings_tab_g12()
                                    { pref_set_tabspos1(flw::TabsGroup::Pos::BOTTOM); }
    void                        settings_tab_g13()
                                    { pref_set_tabspos1(flw::TabsGroup::Pos::LEFT); }
    void                        settings_tab_g14()
                                    { pref_set_tabspos1(flw::TabsGroup::Pos::RIGHT); }
    void                        settings_tab_g21()
                                    { pref_set_tabspos2(flw::TabsGroup::Pos::TOP); }
    void                        settings_tab_g22()
                                    { pref_set_tabspos2(flw::TabsGroup::Pos::BOTTOM); }
    void                        settings_tab_g23()
                                    { pref_set_tabspos2(flw::TabsGroup::Pos::LEFT); }
    void                        settings_tab_g24()
                                    { pref_set_tabspos2(flw::TabsGroup::Pos::RIGHT); }
    void                        settings_theme()
                                    { flw::dlg::theme(true, true); CONFIG.send_message(fle::message::PREF_CHANGED); }
    void                        show_find()
                                    { CONFIG.send_message(fle::message::SHOW_FIND, "", "", &_findbar->findreplace()); }
    void                        show_one()
                                    { split_view(Split::SHOW_ONE); }
    void                        show_two()
                                    { split_view(Split::SHOW_TWO); }
    void                        split_view(Split value);
    void                        tabs_activate(fle::Editor* editor);
    void                        tabs_activate_cursor(const std::string& workpath, const std::string& filename, int row = 0, int col = 0);
    int                         tabs_changed() const;
    void                        tabs_check_empty();
    void                        tabs_check_external_update();
    void                        tabs_close_all();
    int                         tabs_count() const;
    void                        tabs_delete(fle::Editor* editor);
    fle::Editor*                tabs_editor_by_index(int& index);
    fle::Editor*                tabs_editor_by_path(const std::string& path);
    void                        tabs_find_lines();
    void                        tabs_list();
    void                        tabs_move_editor()
                                    { tabs_move(_editor); do_layout(); }
    void                        tabs_move_all(bool to_left);
    void                        tabs_move(fle::Editor* editor);
    void                        tabs_pgo();
    void                        tabs_pgo_undo();
    void                        tabs_replace_all();
    void                        tabs_reset_split_size();
    void                        tabs_restore_visibility();
    bool                        tabs_save_all(bool ask);
    void                        tabs_save_visibility();
    void                        tabs_sort(bool left, bool ascending);
    void                        tabs_trailing_all();
    void                        tools_next_output();
    void                        tools_prev_output();
    void                        tools_run_command(bool repeat);
    void                        toggle_dir_browser();
    void                        toggle_fullscreen()
                                    { if (fullscreen_active() == 0) fullscreen(); else fullscreen_off(); }
    void                        toggle_menu()
                                    { if (_menu->visible() != 0) _menu->hide(); else _menu->show(); do_layout(); }
    void                        toggle_one()
                                    { if (_tabs.tabs1->visible()) split_view(Split::HIDE_ONE); else split_view(Split::SHOW_ONE); }
    void                        toggle_output()
                                    { if (_output->visible() != 0) _output->hide(); else _output->show(); do_layout(); }
    void                        toggle_tabs()
                                    { if (_tabs.tabs1->is_tabs_visible() == false) { _tabs.tabs1->show_tabs(); _tabs.tabs2->show_tabs(); } else { _tabs.tabs1->hide_tabs(); _tabs.tabs2->hide_tabs(); } }
    void                        toggle_two()
                                    { if (_tabs.tabs2->visible()) split_view(Split::HIDE_TWO); else split_view(Split::SHOW_TWO); }
    void                        update_menu();
    void                        update_pref();
    static void                 CallbackFileBrowser(Fl_Widget* sender, void* data);
    static void                 CallbackList(Fl_Widget* sender, void* data);
    static void                 CallbackRecent(Fl_Widget* sender, void* data);
    static void                 CallbackWindow(Fl_Widget* sender, void* data);
    static inline void          CheckExternalUpdate()
                                    { SELF->tabs_check_external_update(); }
    static inline void          ShowOutputEditor()
                                    { SELF->_output->show_editor(); SELF->do_layout(); Fl::redraw(); Fl::check(); }
    static inline void          ShowOutputList()
                                    { SELF->_output->show_list(); SELF->do_layout(); Fl::redraw(); Fl::check(); }
    static inline void          ShowOutputTerminal()
                                    { SELF->_output->show_terminal(); SELF->do_layout(); Fl::redraw(); Fl::check(); }
    static inline bool          SettingsClearTerminal()
                                    { return flw::menu::item_value(SELF->_menu, MENU_SETTINGS_OUTPUT_CLEAR); }
    static inline bool          settingsShowUnknown()
                                    { return flw::menu::item_value(SELF->_menu, MENU_SETTINGS_OUTPUT_UNKNOWN); }
    static Fl_Rect              COMMAND_RECT;
    static Fl_Rect              PROJECT_RECT;
    static Fl_Rect              TEXT_RECT;
private:
    static FlEdit*              SELF;
    CommandOutput*              _output;
    DirBrowser*                 _dir_browser;
    Fl_Menu_Bar*                _menu;
    Fl_Rect                     _rect;
    fle::Editor*                _editor;
    fle::FindBar*               _findbar;
    flw::util::RecentMenu*      _recent;
    flw::SplitGroup*            _split_edit;
    flw::SplitGroup*            _split_main;
    gnu::db2::DB                _db;
    gnu::pcre8::PCRE            _list_rx;
    std::string                 _search;
    std::string                 _search_all;
    std::vector<std::string>    _old_find_list;
    std::vector<std::string>    _old_recent_list;
    std::vector<std::string>    _old_replace_list;
    struct {
        Fl_Boxtype              boxtype;
        bool                    tabs1_vis;
        bool                    tabs2_vis;
        flw::SplitGroup*        split;
        flw::TabsGroup*         active;
        flw::TabsGroup*         tabs1;
        flw::TabsGroup*         tabs2;
        flw::TabsGroup::Pos     pos1;
        flw::TabsGroup::Pos     pos2;
    }                           _tabs;
    struct {
        std::string             path;
        std::string             name;
        std::string             wordfile;
    }                           _project;
    struct {
        std::string             start_path;
        std::string             open_path;
    }                           _paths;
};
#include <algorithm>
CommandDialog::CommandDialog(CommandVector& commands, Command* select) :
Fl_Double_Window(0, 0, flw::PREF_FONTSIZE * 68, flw::PREF_FONTSIZE * 46, "flEdit - Command Settings"),
_commands(commands) {
    end();
    _capture_editor   = new Fl_Radio_Round_Button(0, 0, 0, 0, "Capture to editor");
    _capture_list     = new Fl_Radio_Round_Button(0, 0, 0, 0, "Capture to list");
    _capture_terminal = new Fl_Radio_Round_Button(0, 0, 0, 0, "Capture to terminal");
    _close            = new Fl_Return_Button(0, 0, 0, 0, "&Close");
    _command          = new Fl_Input(0, 0, 0, 0, "Command");
    _copy             = new Fl_Button(0, 0, 0, 0, "&Copy");
    _delete           = new Fl_Button(0, 0, 0, 0, "Delete");
    _execute          = new Fl_Button(0, 0, 0, 0, "&Execute");
    _filter           = new Fl_Input(0, 0, 0, 0, "Filter parser");
    _grid             = new flw::GridGroup(0, 0, w(), h());
    _help             = new Fl_Button(0, 0, 0, 0, "&Help");
    _label            = new Fl_Box(0, 0, 0, 0);
    _line             = new Fl_Input(0, 0, 0, 0, "Line parser");
    _list             = new Fl_Hold_Browser(0, 0, 0, 0);
    _name             = new Fl_Input(0, 0, 0, 0, "Name");
    _new              = new Fl_Button(0, 0, 0, 0, "&New");
    _run              = new Fl_Radio_Round_Button(0, 0, 0, 0, "Run in background");
    _stream_terminal  = new Fl_Radio_Round_Button(0, 0, 0, 0, "Stream to terminal");
    _string           = new Fl_Input(0, 0, 0, 0, "Test string for line regex");
    _test             = new Fl_Button(0, 0, 0, 0, "&Test");
    _workpath         = new Fl_Input(0, 0, 0, 0, "Work directory");
    _current          = nullptr;
    _res              = -1;
    _last             = 0;
    _loop             = false;
    _grid->add(_list,                  1,   1,  42,  -6);
    _grid->add(_name,                 44,   3,  -1,   4);
    _grid->add(_command,              44,  10,  -1,   4);
    _grid->add(_workpath,             44,  17,  -1,   4);
    _grid->add(_run,                  44,  23,  -1,   4);
    _grid->add(_capture_list,         44,  28,  -1,   4);
    _grid->add(_capture_editor,       44,  33,  -1,   4);
    _grid->add(_capture_terminal,     44,  38,  -1,   4);
    _grid->add(_stream_terminal,      44,  43,  -1,   4);
    _grid->add(_filter,               44,  50,  -1,   4);
    _grid->add(_line,                 44,  57,  -1,   4);
    _grid->add(_string,               44,  64,  -1,   4);
    _grid->add(_label,                44,  70,  -1,   8);
    _grid->add(_help,                  1,  -5,  16,   4);
    _grid->add(_delete,             -102,  -5,  16,   4);
    _grid->add(_copy,                -85,  -5,  16,   4);
    _grid->add(_new,                 -68,  -5,  16,   4);
    _grid->add(_test,                -51,  -5,  16,   4);
    _grid->add(_execute,             -34,  -5,  16,   4);
    _grid->add(_close,               -17,  -5,  16,   4);
    add(_grid);
    _capture_editor->callback(CommandDialog::Callback, this);
    _capture_editor->tooltip("Capture output from command to editor.");
    _capture_list->callback(CommandDialog::Callback, this);
    _capture_list->setonly();
    _capture_list->tooltip("Capture output from command to listbox.");
    _capture_terminal->callback(CommandDialog::Callback, this);
    _capture_terminal->tooltip("Capture output from command to terminal widget.");
    _close->callback(CommandDialog::Callback, this);
    _command->align(FL_ALIGN_LEFT | FL_ALIGN_TOP);
    _command->textfont(flw::PREF_FIXED_FONT);
    _command->textsize(flw::PREF_FONTSIZE);
    _command->tooltip("Enter command to execute.");
    _copy->callback(CommandDialog::Callback, this);
    _copy->tooltip("Copy current command to new command.");
    _delete->callback(CommandDialog::Callback, this);
    _execute->callback(CommandDialog::Callback, this);
    _filter->align(FL_ALIGN_LEFT | FL_ALIGN_TOP);
    _filter->textfont(flw::PREF_FIXED_FONT);
    _filter->textsize(flw::PREF_FONTSIZE);
    _filter->tooltip(
        "Enter a word for filtering captured lines.\n"
        "Or a PCRE compatible regular expression.\n"
        "Leave empty for all lines."
    );
    _help->callback(CommandDialog::Callback, this);
    _label->align(FL_ALIGN_INSIDE | FL_ALIGN_LEFT| FL_ALIGN_TOP);
    _label->box(FL_BORDER_BOX);
    _label->color(FL_BACKGROUND2_COLOR);
    _label->labelfont(FL_COURIER);
    _line->align(FL_ALIGN_LEFT | FL_ALIGN_TOP);
    _line->textfont(flw::PREF_FIXED_FONT);
    _line->textsize(flw::PREF_FONTSIZE);
    _line->tooltip("Enter a PCRE regular compatible expression to retrieve file and line number.");
    _list->callback(CommandDialog::Callback, this);
    _list->textfont(flw::PREF_FONT);
    _list->textsize(flw::PREF_FONTSIZE);
    _name->align(FL_ALIGN_LEFT | FL_ALIGN_TOP);
    _name->textfont(flw::PREF_FIXED_FONT);
    _name->textsize(flw::PREF_FONTSIZE);
    _name->tooltip("Give command a unique name.");
    _new->callback(CommandDialog::Callback, this);
    _new->tooltip("Create new empty command.");
    _run->callback(CommandDialog::Callback, this);
    _run->tooltip("Run command as seperate process.");
    _stream_terminal->callback(CommandDialog::Callback, this);
    _stream_terminal->tooltip("Stream output from command to terminal widget.");
    _string->align(FL_ALIGN_LEFT | FL_ALIGN_TOP);
    _string->textfont(flw::PREF_FIXED_FONT);
    _string->textsize(flw::PREF_FONTSIZE);
    _string->tooltip("Enter test string to check regular expressions on.");
    _test->callback(CommandDialog::Callback, this);
    _test->tooltip("Test regular expressions.");
    _workpath->align(FL_ALIGN_LEFT | FL_ALIGN_TOP);
    _workpath->textfont(flw::PREF_FIXED_FONT);
    _workpath->textsize(flw::PREF_FONTSIZE);
    _workpath->tooltip("Enter work directory or leave empty to use current.");
    flw::util::labelfont(this);
    data_load();
    data_select(select);
    data_set();
    callback(CommandDialog::Callback, this);
    set_modal();
    resizable(_grid);
    if (FlEdit::COMMAND_RECT.w() > 0 && FlEdit::COMMAND_RECT.h() > 0) {
        CommandDialog::resize(FlEdit::COMMAND_RECT.x(), FlEdit::COMMAND_RECT.y(), FlEdit::COMMAND_RECT.w(), FlEdit::COMMAND_RECT.h());
    }
    _grid->do_layout();
}
CommandDialog::~CommandDialog() {
    FlEdit::COMMAND_RECT = Fl_Rect(this);
}
void CommandDialog::Callback(Fl_Widget* w, void* o) {
    auto self = static_cast<CommandDialog*>(o);
    if (w == self || w == self->_close) {
        self->data_save(true);
        self->_current = nullptr;
        self->_loop = false;
        self->_res = -1;
        self->hide();
    }
    else if (w == self->_delete) {
        self->data_delete();
        self->data_set();
    }
    else if (w == self->_execute) {
        self->_res = self->row(self->_current);
        self->_res--;
        if (self->_res >= 0 && self->data_save() == true) {
            self->_loop = false;
            self->hide();
        }
    }
    else if (w == self->_list) {
        if (self->data_save() == true) {
            auto row = self->_list->value();
            if (row > 0) {
                self->_current = static_cast<Command*>(self->_list->data(row));
                self->data_set();
            }
        }
        else if (self->_last > 0) {
            self->_list->value(self->_last);
        }
        if (Fl::event_clicks() > 0) {
            CommandDialog::Callback(self->_execute, self);
        }
    }
    else if (w == self->_copy) {
        if (self->data_save() == true) {
            self->data_new(self->_current);
            self->data_set();
            self->_name->take_focus();
        }
    }
    else if (w == self->_new) {
        if (self->data_save() == true) {
            self->data_new();
            self->data_set();
            self->_name->take_focus();
        }
    }
    else if (w == self->_test) {
        self->test();
        self->_string->take_focus();
    }
    else if (w == self->_run) {
        self->data_save();
        self->data_set(Output::RUN);
    }
    else if (w == self->_capture_editor) {
        self->data_save();
        self->data_set(Output::CAPTURE_EDITOR);
    }
    else if (w == self->_capture_list) {
        self->data_save();
        self->data_set(Output::CAPTURE_LIST);
    }
    else if (w == self->_capture_terminal) {
        self->data_save();
        self->data_set(Output::CAPTURE_TERMINAL);
    }
    else if (w == self->_stream_terminal) {
        self->data_save();
        self->data_set(Output::STREAM_TERMINAL);
    }
    else if (w == self->_help) {
        flw::dlg::list("flEdit - Command Help", COMMAND_HELP + fle::help::pcre(), true, 60, 40);
    }
}
bool CommandDialog::data_delete() {
    if (_current != nullptr) {
        for (auto it = _commands.begin(); it != _commands.end(); ++it) {
            if (*it == _current) {
                delete *it;
                _current = nullptr;
                _commands.erase(it);
                data_load();
                return true;
            }
        }
    }
    return true;
}
void CommandDialog::data_load() {
    _current = nullptr;
    _list->clear();
    std::sort(_commands.begin(), _commands.end(), &Command::Sort);
    for (auto c : _commands) {
        _list->add(c->name.c_str(), c);
    }
}
void CommandDialog::data_new(Command* copy) {
    _current = new Command(gnu::str::format("new command %d", rand() % 256'000), "", Output::RUN, "", "", "");
    if (copy != nullptr) {
        _current->command      = copy->command;
        _current->filter_regex = copy->filter_regex;
        _current->line_regex   = copy->line_regex;
        _current->name         = copy->name + gnu::str::format(" %d", rand() % 256'000);
        _current->output       = copy->output;
        _current->workpath     = copy->workpath;
    }
    _commands.push_back(_current);
    _list->add(_current->name.c_str(), _current);
    _list->value(_list->size());
    _list->show(_list->size());
}
bool CommandDialog::data_save(bool force) {
    if (_current != nullptr) {
        auto r        = row(_current);
        auto name     = gnu::str::to_string(_name->value());
        auto command  = gnu::str::to_string(_command->value());
        auto workpath = gnu::str::to_string(_workpath->value());
        auto filter   = gnu::str::to_string(_filter->value());
        auto line     = gnu::str::to_string(_line->value());
        auto output   = Output::RUN;
        if (_capture_editor->value() != 0) {
            output = Output::CAPTURE_EDITOR;
        }
        else if (_capture_list->value() != 0) {
            output = Output::CAPTURE_LIST;
        }
        else if (_capture_terminal->value() != 0) {
            output = Output::CAPTURE_TERMINAL;
        }
        else if (_stream_terminal->value() != 0) {
            output = Output::STREAM_TERMINAL;
        }
        gnu::pcre8::PCRE re1(filter);
        gnu::pcre8::PCRE re2(line);
        if (name == "" && force == false) {
            _label->copy_label("error: name is empty");
            _name->take_focus();
            fl_beep(FL_BEEP_ERROR);
            return false;
        }
        else if (filter != "" && re1.is_compiled() == false && force == false) {
            _label->copy_label(re1.err().c_str());
            _filter->take_focus();
            fl_beep(FL_BEEP_ERROR);
            return false;
        }
        else if (line != "" && re2.is_compiled() == false && force == false) {
            _label->copy_label(re2.err().c_str());
            _line->take_focus();
            fl_beep(FL_BEEP_ERROR);
            return false;
        }
        else if (r == 0 && force == false) {
            _label->copy_label("error: internal problem CommandDialog::data_save()");
            fl_beep(FL_BEEP_ERROR);
            return false;
        }
        else {
            _list->text(r, name.c_str());
            _label->copy_label("");
            _current->name         = gnu::str::trim(name);
            _current->command      = gnu::str::trim(command);
            _current->workpath     = gnu::str::trim(workpath);
            _current->filter_regex = gnu::str::trim(filter);
            _current->line_regex   = gnu::str::trim(line);
            _current->output       = output;
        }
    }
    return true;
}
void CommandDialog::data_select(Command* select) {
    auto r = 1;
    for (const auto c : _commands) {
        if (c == select) {
            _list->value(r);
            _list->show(r);
            _list->do_callback();
            if (_list->size() > 25) {
                _list->topline(r - 25);
            }
            else {
                _list->topline(1);
            }
            return;
        }
        r++;
    }
}
void CommandDialog::data_set(Output radio) {
    if (_current != nullptr) {
        _last = _list->value();
        _name->value(_current->name.c_str());
        _command->value(_current->command.c_str());
        _workpath->value(_current->workpath.c_str());
        _filter->value(_current->filter_regex.c_str());
        _line->value(_current->line_regex.c_str());
        if (radio == Output::RUN) {
            _run->setonly();
        }
        else if (radio == Output::CAPTURE_EDITOR) {
            _capture_editor->setonly();
        }
        else if (radio == Output::CAPTURE_LIST) {
            _capture_list->setonly();
        }
        else if (radio == Output::CAPTURE_TERMINAL) {
            _capture_terminal->setonly();
        }
        else if (radio == Output::STREAM_TERMINAL) {
            _stream_terminal->setonly();
        }
        else if (_current->output == Output::RUN) {
            _run->setonly();
        }
        else if (_current->output == Output::CAPTURE_EDITOR) {
            _capture_editor->setonly();
        }
        else if (_current->output == Output::CAPTURE_LIST) {
            _capture_list->setonly();
        }
        else if (_current->output == Output::CAPTURE_TERMINAL) {
            _capture_terminal->setonly();
        }
        else if (_current->output == Output::STREAM_TERMINAL) {
            _stream_terminal->setonly();
        }
        _capture_list->activate();
        _command->activate();
        _copy->activate();
        _delete->activate();
        _capture_editor->activate();
        _execute->activate();
        _name->activate();
        _run->activate();
        _capture_terminal->activate();
        _stream_terminal->activate();
        _workpath->activate();
        if (_capture_list->value() != 0) {
            _filter->activate();
            _label->activate();
            _line->activate();
            _string->activate();
            _test->activate();
        }
        else {
            _filter->deactivate();
            _label->deactivate();
            _line->deactivate();
            _string->deactivate();
            _test->deactivate();
        }
    }
    else {
        _last = 0;
        _command->value("");
        _name->value("");
        _filter->value("");
        _label->label("");
        _line->value("");
        _workpath->value("");
        _capture_list->deactivate();
        _command->deactivate();
        _copy->deactivate();
        _delete->deactivate();
        _capture_editor->deactivate();
        _execute->deactivate();
        _filter->deactivate();
        _label->deactivate();
        _line->deactivate();
        _name->deactivate();
        _run->deactivate();
        _stream_terminal->deactivate();
        _string->deactivate();
        _capture_terminal->deactivate();
        _test->deactivate();
        _workpath->deactivate();
    }
    redraw();
}
int CommandDialog::row(const Command* command) const {
    for (int f = 1; command && f <= _list->size(); f++) {
        if (_list->data(f) == command) {
            return f;
        }
    }
    return 0;
}
Command* CommandDialog::run(Fl_Window* parent) {
    _loop = true;
    _list->take_focus();
    flw::util::center_window(this, parent);
    show();
    while (_loop == true) {
        Fl::wait();
        Fl::flush();
    }
    return (_res >= 0 && _res < static_cast<int>(_commands.size())) ? _commands[_res] : nullptr;
}
void CommandDialog::test() {
    auto filter = gnu::str::to_string(_filter->value());
    auto cursor = gnu::str::to_string(_line->value());
    auto string = gnu::str::to_string(_string->value());
    auto names  = std::vector<std::string>{"file", "line", "col"};
    std::string      info;
    gnu::pcre8::PCRE re1(filter);
    gnu::pcre8::PCRE re2(cursor);
    info += "Filter: ";
    if (re1.is_compiled() == false) {
        info += re1.err();
    }
    else if (string == "") {
        info += "regex ok but empty test string!";
    }
    else if (re1.exec(string).size() == 0) {
        info += "no match";
    }
    else {
        info += "matches string";
    }
    info += "\n";
    info += "File: ";
    if (re2.is_compiled() == false) {
        info += re2.err();
    }
    else if (string == "") {
        info += "regex ok but empty test string!";
    }
    else if (re2.set_names(names).exec(string).size() == 0) {
        info += "no match";
    }
    else {
        auto f = re2.match("file");
        auto l = re2.match("line");
        auto c = re2.match("col");
        info += "filename=";
        info += f.word();
        info += ", line=";
        info += l.word();
        info += ", col=";
        info += c.word();
    }
    _label->copy_label(info.c_str());
}
Command*                    Command::CURRENT        = nullptr;
int                         Command::SELECT_LINE    = 0;
std::thread*                Command::THREAD         = nullptr;
CommandVector               Command::COMMANDS;
gnu::file::Buf              Command::BUF;
std::string                 Command::LINE_REGEX;
std::string                 Command::WORKDIR;
std::vector<std::string>    Command::LINES;
CommandOutput::CommandOutput(fle::Config& config, fle::FindBar* findbar) : flw::TabsGroup(0, 0, 0, 0) {
    end();
    _editor   = new fle::Editor(config, findbar);
    _list     = new flw::ScrollBrowser();
    _terminal = new Fl_Terminal(0, 0, 0, 0);
    add("List", _list);
    add("Editor", _editor);
    add("Terminal", _terminal);
    tab_pos(flw::TabsGroup::Pos::LEFT);
    _list->callback(FlEdit::CallbackList, this);
    _list->when(FL_WHEN_ENTER_KEY_CHANGED);
    _terminal->tooltip("Terminal is output only.");
    value(_list);
}
CommandOutput::~CommandOutput() {
}
void CommandOutput::create_command_thread(std::string workpath, std::string filename, std::string selection) {
    auto work   = Command::CURRENT->workpath;
    auto cmd    = Command::CURRENT->command;
    auto fi     = gnu::file::File(filename);
    auto parent = gnu::file::File(fi.path());
    if (filename != "" && work.find("$FILE") != std::string::npos) {
        gnu::str::replace(work, "$FILE", fi.path());
    }
    else if (filename == "" && work.find("$FILE") != std::string::npos) {
        flw::dlg::msg_alert("flEdit", "Error: file has not been set!");
        return;
    }
    else if (filename != "" && work.find("$PARENT") != std::string::npos) {
        gnu::str::replace(work, "$PARENT", parent.path());
    }
    else if (filename == "" && work.find("$PARENT") != std::string::npos) {
        flw::dlg::msg_alert("flEdit", "Error: file has not been set!");
        return;
    }
    else if (workpath != "" && work.find("$PROJECT") != std::string::npos) {
        gnu::str::replace(work, "$PROJECT", workpath);
    }
    else if (workpath == "" && work.find("$PROJECT") != std::string::npos) {
        flw::dlg::msg_alert("flEdit", "Error: project directory has not been set!");
        return;
    }
    if (filename != "" && cmd.find("$FILE") != std::string::npos) {
        gnu::str::replace(cmd, "$FILE", filename);
    }
    else if (filename == "" && cmd.find("$FILE") != std::string::npos) {
        flw::dlg::msg_alert("flEdit", "Error: file has not been set!");
        return;
    }
    if (filename != "" && cmd.find("$NAME") != std::string::npos) {
        gnu::str::replace(cmd, "$NAME", fi.name());
    }
    else if (filename == "" && cmd.find("$NAME") != std::string::npos) {
        flw::dlg::msg_alert("flEdit", "Error: file has not been set!");
        return;
    }
    if (filename != "" && cmd.find("$PARENT") != std::string::npos) {
        gnu::str::replace(cmd, "$PARENT", fi.path());
    }
    else if (filename == "" && cmd.find("$PARENT") != std::string::npos) {
        flw::dlg::msg_alert("flEdit", "Error: file has not been set!");
        return;
    }
    if (workpath != "" && cmd.find("$PROJECT") != std::string::npos) {
        gnu::str::replace(cmd, "$PROJECT", workpath);
    }
    else if (workpath == "" && cmd.find("$PROJECT") != std::string::npos) {
        flw::dlg::msg_alert("flEdit", "Error: project has not been set!");
        return;
    }
    if (selection != "" && cmd.find("$SELECTION") != std::string::npos) {
        if (selection.length() > 0 && selection.front() != '"') {
            selection = "\"" + selection;
        }
        if (selection.length() > 0 && selection.back() != '"') {
            selection += "\"";
        }
        gnu::str::replace(cmd, "$SELECTION", selection);
    }
    else if (selection == "" && cmd.find("$SELECTION") != std::string::npos) {
        flw::dlg::msg_alert("flEdit", "Error: selection has not been set!");
        return;
    }
#ifdef _WIN32
    cmd = std::string("CMD.EXE /C ") + cmd + " 2>&1";
#else
    cmd = cmd + " 2>&1";
#endif
    if (Command::CURRENT->output == Output::CAPTURE_EDITOR) {
        FlEdit::ShowOutputEditor();
        Command::THREAD = new std::thread(CommandOutput::ThreadFuncForEditor, cmd, work, this);
    }
    else if (Command::CURRENT->output == Output::CAPTURE_LIST) {
        auto rx = new gnu::pcre8::PCRE(Command::CURRENT->filter_regex, true);
        if (Command::CURRENT->filter_regex.empty() == false && rx->is_compiled() == false) {
            flw::dlg::msg_alert("flEdit", flw::util::format("Error: regex expression!\n%s\n%s", rx->err().c_str(), rx->pattern().c_str()));
            delete rx;
        }
        else {
            _list_rx.clear();
            _list->clear();
            _list->add(gnu::str::format("executing %s", cmd.c_str()).c_str());
            _list->deactivate();
            FlEdit::ShowOutputList();
            Command::THREAD = new std::thread(CommandOutput::ThreadFuncForList, cmd, work, rx, Command::CURRENT->line_regex, this);
        }
    }
    else if (Command::CURRENT->output == Output::CAPTURE_TERMINAL) {
        FlEdit::ShowOutputTerminal();
        reset_terminal(false);
        Command::THREAD = new std::thread(CommandOutput::ThreadFuncForTerminal, cmd, work, this);
    }
    else if (Command::CURRENT->output == Output::STREAM_TERMINAL) {
        FlEdit::ShowOutputTerminal();
        reset_terminal(false);
        Command::THREAD = new std::thread(CommandOutput::ThreadFuncForTerminalStream, cmd, work, this);
    }
    else {
        auto ret = gnu::file::run(cmd.c_str(), true, false);
        if (ret != 0) {
            flw::dlg::msg_alert("flEdit", flw::util::format("Failed to execute '%s'\nreturn code is %d", cmd.c_str(), ret));
        }
    }
}
void CommandOutput::join() {
    if (Command::THREAD == nullptr) {
        return;
    }
    Command::THREAD->join();
    delete Command::THREAD;
    Command::THREAD = nullptr;
    if (Command::CURRENT->output == Output::CAPTURE_EDITOR) {
        show_main_editor();
    }
    else if (Command::CURRENT->output == Output::CAPTURE_LIST) {
        set_list_data(Command::LINES, Command::LINE_REGEX, Command::SELECT_LINE);
        show_main_editor();
    }
    else if (Command::CURRENT->output == Output::CAPTURE_TERMINAL) {
        show_main_editor();
    }
    else if (Command::CURRENT->output == Output::STREAM_TERMINAL) {
        show_main_editor();
    }
    Command::LINES.clear();
    Command::LINE_REGEX = "";
    Command::SELECT_LINE = 0;
    Command::BUF.clear();
    FlEdit::CheckExternalUpdate();
}
void CommandOutput::Join(void* o) {
    auto self = static_cast<CommandOutput*>(o);
    self->join();
}
void CommandOutput::reset_terminal(bool force) {
    if (FlEdit::SettingsClearTerminal() == true || force == true) {
        _terminal->reset_terminal();
        _terminal->history_lines(CommandOutput::MAX_TERMINAL_LINES);
        _terminal->margin_left(3);
        _terminal->margin_right(3);
        _terminal->margin_top(3);
        _terminal->margin_bottom(3);
        _terminal->ansi(true);
        _terminal->scrollbar->linesize(6);
    }
    _terminal->show_unknown(FlEdit::settingsShowUnknown());
}
void CommandOutput::run_command(const std::string& workpath, const std::string& filename, const std::string& selection, bool repeat) {
    if (Command::THREAD != nullptr) {
        flw::dlg::msg_alert("flEdit", "Previous command is still running...");
    }
    else if (repeat == true && Command::CURRENT != nullptr) {
        create_command_thread(workpath, filename, selection);
    }
    else {
        auto dialog  = CommandDialog(Command::COMMANDS, Command::CURRENT);
        auto command = dialog.run(top_window());
        if (command != nullptr) {
            Command::CURRENT = command;
            create_command_thread(workpath, filename, selection);
        }
    }
}
void CommandOutput::set_editor_data(const gnu::file::Buf& buf) {
    _editor->text_set(buf.c_str(), fle::FLineEnding::UNIX, fle::FChecksum::NO);
    value(_editor);
}
void CommandOutput::set_list_data(const std::vector<std::string>& lines, std::string parser, int select) {
    _list->clear();
    _list->activate();
    for (const auto& line : lines) {
        if (line.length() > fle::limits::OUTPUT_LINE_LENGTH_VAL) {
            auto l = line;
            l.resize(fle::limits::OUTPUT_LINE_LENGTH_VAL);
            l += "|";
            _list->add(l.c_str());
        }
        else {
            _list->add(line.c_str());
        }
    }
    _list_rx.compile(parser);
    if (select > 0) {
        _list->value(select);
    }
    value(_list);
}
void CommandOutput::set_terminal_data(const gnu::file::Buf& buf) {
    reset_terminal(false);
    _terminal->append(buf.c_str(), buf.size());
    value(_terminal);
}
void CommandOutput::show_main_editor() {
    static_cast<FlEdit*>(top_window())->editor_take_focus();
}
void CommandOutput::ThreadFuncForEditor(const std::string cmd, const std::string work, CommandOutput* self) {
    static const size_t BUFFER_READ = 16'384;
    auto old = gnu::file::work_dir().filename();
    gnu::file::chdir(work);
    Command::WORKDIR = gnu::file::work_dir().filename();
    auto handle = gnu::file::popen(cmd);
    std::string message;
    if (handle == nullptr) {
        message = "error: failed to execute command " + cmd + " in " + Command::WORKDIR + "\n";
    }
    else {
        while (true) {
            char buffer[BUFFER_READ];
            auto read = fread(buffer, 1, BUFFER_READ, handle);
            if (read > 0) {
                Command::BUF.add(buffer, read);
            }
            else if (feof(handle) != 0) {
                break;
            }
            if (Command::BUF.size() >= CommandOutput::MAX_BUFFER_SIZE) {
                message = gnu::str::format("error: max read bytes limits has been reached (%d)!\n", (int) Command::BUF.size());
                break;
            }
        }
        pclose(handle);
    }
    Command::BUF.add(message.c_str(), message.length());
    Fl::lock();
    self->_editor->text_set(Command::BUF.c_str(), fle::FLineEnding::UNIX, fle::FChecksum::NO);
    Fl::unlock();
    Fl::awake(CommandOutput::Join, self);
    gnu::file::chdir(old);
}
void CommandOutput::ThreadFuncForList(const std::string cmd, const std::string work, gnu::pcre8::PCRE* filter_regex, std::string line_regex, CommandOutput* self) {
    static const size_t BUFFER_READ = 16'384;
    auto start  = gnu::Time::Milli();
    auto handle = static_cast<FILE*>(nullptr);
    auto old    = gnu::file::work_dir().filename();
    gnu::file::chdir(work);
    Command::WORKDIR = gnu::file::work_dir().filename();
    Command::SELECT_LINE = 0;
    Command::LINE_REGEX = line_regex;
    Command::BUF.clear();
    Command::LINES.clear();
    Command::LINES.push_back(gnu::str::format("running in directory %s", Command::WORKDIR.c_str()));
    Command::LINES.push_back(gnu::str::format("executing %s", cmd.c_str()));
    handle = gnu::file::popen(cmd);
    if (handle == nullptr) {
        Command::LINES.push_back("error: failed to execute command");
    }
    else {
        while (true) {
            char buffer[BUFFER_READ];
            auto read = fread(buffer, 1, BUFFER_READ, handle);
            if (read > 0) {
                Command::BUF.add(buffer, read);
            }
            else if (feof(handle) != 0) {
                break;
            }
            else if (Command::BUF.size() >= CommandOutput::MAX_BUFFER_SIZE) {
                Command::LINES.push_back("error: max read bytes limits has been reached!");
                break;
            }
        }
        pclose(handle);
        Command::BUF.add("\0", 1);
        Command::LINES.push_back("Output:");
        Command::SELECT_LINE = (int) Command::LINES.size();
        for (const auto& line : gnu::str::split(Command::BUF.c_str(), "\n")) {
            if (filter_regex->is_compiled() == false || filter_regex->exec(line).size() > 0) {
                if (Command::LINES.size() == CommandOutput::MAX_LIST_LINES) {
                    Command::LINES.push_back("error: line limits have been reached!");
                    break;
                }
                else {
                    auto tmp = gnu::str::replace_const(line, "\r");
                    Command::LINES.push_back(tmp);
                }
            }
        }
        Command::LINES.push_back(std::string("Finished in ") + gnu::Time::FormatMilliToTime((gnu::Time::Milli() - start) / 1000));
    }
    delete filter_regex;
    Fl::awake(CommandOutput::Join, self);
    gnu::file::chdir(old);
}
void CommandOutput::ThreadFuncForTerminal(const std::string cmd, const std::string work, CommandOutput* self) {
    static const size_t BUFFER_READ = 16'384;
    auto old = gnu::file::work_dir().filename();
    gnu::file::chdir(work);
    Command::WORKDIR = gnu::file::work_dir().filename();
    auto handle = gnu::file::popen(cmd);
    std::string message;
    if (handle == nullptr) {
        message = "error: failed to execute command " + cmd + " in " + Command::WORKDIR + "\n";
    }
    else {
        while (true) {
            char buffer[BUFFER_READ];
            auto read = fread(buffer, 1, BUFFER_READ, handle);
            if (read > 0) {
                Command::BUF.add(buffer, read);
            }
            else if (feof(handle) != 0) {
                break;
            }
            if (Command::BUF.size() >= CommandOutput::MAX_BUFFER_SIZE) {
                message = gnu::str::format("error: max read bytes limits has been reached (%d)!\n", (int) Command::BUF.size());
                break;
            }
        }
        pclose(handle);
    }
    Command::BUF.add(message.c_str(), message.length());
    Fl::lock();
    self->_terminal->append(Command::BUF.c_str(), Command::BUF.size());
    self->_terminal->append(nullptr);
    Fl::unlock();
    Fl::awake(CommandOutput::Join, self);
    gnu::file::chdir(old);
}
void CommandOutput::ThreadFuncForTerminalStream(const std::string cmd, const std::string work, CommandOutput* self) {
    static const size_t BUFFER_READ = 128;
    auto old = gnu::file::work_dir().filename();
    gnu::file::chdir(work);
    Command::WORKDIR = gnu::file::work_dir().filename();
    auto handle = gnu::file::popen(cmd);
    auto tot = 0;
    std::string message;
    if (handle == nullptr) {
        message = "error: failed to execute command " + cmd + " in " + Command::WORKDIR + "\n";
    }
    else {
        while (true) {
            char buffer[BUFFER_READ + 1];
            memset(buffer, 0, BUFFER_READ + 1);
            auto read = fread(buffer, 1, BUFFER_READ, handle);
            if (read > 0) {
                Fl::lock();
                self->_terminal->append(buffer, read);
                Fl::check();
                Fl::unlock();
                tot += read;
            }
            else if (feof(handle) != 0) {
                break;
            }
            if (tot >= CommandOutput::MAX_BUFFER_SIZE) {
                message = gnu::str::format("error: max read bytes limits has been reached (%d)!\n", (int) tot);
                break;
            }
        }
        pclose(handle);
    }
    Command::BUF.add(message.c_str(), message.length());
    Fl::lock();
    self->_terminal->append(message.c_str(), message.length());
    self->_terminal->append(nullptr);
    Fl::unlock();
    Fl::awake(CommandOutput::Join, self);
    gnu::file::chdir(old);
}
void CommandOutput::update_pref() {
    TabsGroup::update_pref();
    _editor->update_pref();
    _list->textfont(flw::PREF_FIXED_FONT);
    _list->textsize(flw::PREF_FIXED_FONTSIZE);
    _terminal->textfont(flw::PREF_FIXED_FONT);
    _terminal->textsize(flw::PREF_FIXED_FONTSIZE);
}
DirBrowser::DirBrowser() : Fl_Group(0, 0, 0, 0) {
    end();
    _browser = new Fl_File_Browser(0, 0, 0, 0);
    _refresh = new Fl_Button(0, 0, 0, 0, "Refresh");
    add(_browser);
    add(_refresh);
    _browser->callback(DirBrowser::Callback, this);
    _browser->tooltip("Only files in project directory or child directories can be used.\nDouble click a file to open it.");
    _browser->type(FL_HOLD_BROWSER);
    _refresh->callback(DirBrowser::Callback, this);
    _refresh->tooltip("Refresh directory");
}
void DirBrowser::Callback(Fl_Widget* w, void* o) {
    auto self = static_cast<DirBrowser*>(o);
    if (w == self->_browser) {
        if (Fl::event_clicks() > 0) {
            self->select_file();
        }
    }
    else if (w == self->_refresh) {
        self->load_dir(self->_path);
    }
}
void DirBrowser::load_dir(std::string path) {
    _browser->load(path.c_str());
    _path = path;
}
void DirBrowser::load_root(std::string path) {
     gnu::file::File f(path);
     if (f.is_dir() == true) {
        _file = "";
        _root = f.filename();
        load_dir(_root);
     }
     else {
        _browser->clear();
        _path = "";
        _root = "";
        _file = "";
     }
}
void DirBrowser::resize(int X, int Y, int W, int H) {
    int fs = flw::PREF_FONTSIZE;
    Fl_Widget::resize(X,  Y,               W,  H);
    _browser->resize (X,  Y,               W,  H - fs * 2);
    _refresh->resize (X,  Y + H - fs * 2,  W,  fs * 2);
}
void DirBrowser::select_file() {
    auto row = _browser->value();
    if (row > 0) {
        std::string     name = _browser->text(row);
        gnu::file::File f(_path + "/" + name);
        if (f.name() == "..") {
            f = gnu::file::File(f.path());
            if (f.filename() != _root) {
                load_dir(f.path());
            }
        }
        else if (f.is_dir() == true) {
            load_dir(f.filename());
        }
        else if (f.is_file() == true) {
            _file = f.filename();
            do_callback();
        }
    }
}
void DirBrowser::update_pref() {
    flw::util::labelfont(this);
    _browser->textfont(flw::PREF_FONT);
    _browser->textsize(flw::PREF_FONTSIZE);
}
ProjectDialog::ProjectDialog(gnu::db2::DB& db) :
Fl_Double_Window(0, 0, flw::PREF_FONTSIZE * 30, flw::PREF_FONTSIZE * 40, "flEdit - Load Project"),
_db(db) {
    end();
    _cancel   = new Fl_Button(0, 0, 0, 0, flw::label::CANCEL.c_str());
    _grid     = new flw::GridGroup(0, 0, w(), h());
    _load     = new Fl_Button(0, 0, 0, 0, "&Load");
    _projects = new Fl_Hold_Browser(0, 0, 0, 0);
    _remove   = new Fl_Button(0, 0, 0, 0, flw::label::DEL.c_str());
    _run      = false;
    _grid->add(_projects,   1,   1,  -1,  -6);
    _grid->add(_cancel,   -51,  -5,  16,   4);
    _grid->add(_remove,   -34,  -5,  16,   4);
    _grid->add(_load,     -17,  -5,  16,   4);
    add(_grid);
    for (auto& row : db.get_keys(NS_PROJECTS)) {
        _projects->add(row.key().c_str());
    }
    _cancel->callback(ProjectDialog::Callback, this);
    _load->callback(ProjectDialog::Callback, this);
    _load->deactivate();
    _projects->callback(ProjectDialog::Callback, this);
    _projects->textfont(flw::PREF_FONT);
    _projects->textsize(flw::PREF_FONTSIZE);
    _remove->callback(ProjectDialog::Callback, this);
    _remove->deactivate();
    flw::util::labelfont(this);
    callback(ProjectDialog::Callback, this);
    set_modal();
    resizable(_grid);
    if (FlEdit::PROJECT_RECT.w() > 0 && FlEdit::PROJECT_RECT.h() > 0) {
        ProjectDialog::resize(FlEdit::PROJECT_RECT.x(), FlEdit::PROJECT_RECT.y(), FlEdit::PROJECT_RECT.w(), FlEdit::PROJECT_RECT.h());
    }
    _grid->do_layout();
}
ProjectDialog::~ProjectDialog() {
    FlEdit::PROJECT_RECT = Fl_Rect(this);
}
void ProjectDialog::Callback(Fl_Widget* w, void* o) {
    auto self = static_cast<ProjectDialog*>(o);
    if (w == self || w == self->_cancel) {
        self->_run = false;
        self->hide();
    }
    else if (w == self->_load) {
        self->_name = gnu::str::to_string(self->_projects->text(self->_projects->value()));
        if (self->_name != "") {
            self->_run = false;
            self->hide();
        }
        else {
            fl_beep(FL_BEEP_NOTIFICATION);
        }
    }
    else if (w == self->_remove) {
        auto row = self->_projects->value();
        if (row > 0) {
            auto name = gnu::str::to_string(self->_projects->text(row));
            if (self->_db.remove(NS_PROJECTS, name) == false) {
                flw::dlg::msg_alert("flEdit", flw::util::format("Failed to delete project from database!\n%s", self->_db.err_msg.c_str()));
                return;
            }
            self->_projects->remove(row);
        }
    }
    else if (w == self->_projects) {
        auto row = self->_projects->value();
        if (row > 0) {
            self->_load->activate();
            self->_remove->activate();
        }
        if (row > 0 && Fl::event_clicks() > 0) {
            Fl::event_clicks(0);
            Callback(self->_load, self);
        }
    }
}
std::string ProjectDialog::run(Fl_Window* parent) {
    _run = true;
    _projects->take_focus();
    flw::util::center_window(this, parent);
    show();
    while (_run == true) {
        Fl::wait();
        Fl::flush();
    }
    return _name;
}
static int _TextDialog_LAST_SPLIT = 0;
TextDialog::TextDialog(gnu::db2::DB& db) :
Fl_Double_Window(0, 0, flw::PREF_FONTSIZE * 80, flw::PREF_FONTSIZE * 50, "flEdit - Copy Snippet To Clipboard"),
_db(db) {
    end();
    _buffer = new Fl_Text_Buffer();
    _cancel = new Fl_Button(0, 0, 0, 0, flw::label::CLOSE.c_str());
    _close  = new Fl_Button(0, 0, 0, 0, flw::label::OK.c_str());
    _delete = new Fl_Button(0, 0, 0, 0, flw::label::DEL.c_str());
    _editor = new Fl_Text_Editor(0, 0, 0, 0);
    _grid   = new flw::GridGroup(0, 0, w(), h());
    _names  = new Fl_Hold_Browser(0, 0, 0, 0);
    _rename = new Fl_Button(0, 0, 0, 0, "&Rename");
    _split  = new flw::SplitGroup();
    _update = new Fl_Button(0, 0, 0, 0, "&Update");
    _run    = false;
    _split->add(_names, true);
    _split->add(_editor, false);
    _split->pos(flw::SplitGroup::Pos::VERTICAL);
    _split->split_pos(_TextDialog_LAST_SPLIT > 0 ? _TextDialog_LAST_SPLIT : flw::PREF_FONTSIZE * 20);
    _grid->add(_split,    1,   1,  -1,  -6);
    _grid->add(_delete, -85,  -5,  16,   4);
    _grid->add(_update, -68,  -5,  16,   4);
    _grid->add(_rename, -51,  -5,  16,   4);
    _grid->add(_cancel, -34,  -5,  16,   4);
    _grid->add(_close,  -17,  -5,  16,   4);
    add(_grid);
    _cancel->callback(TextDialog::Callback, this);
    _close->callback(TextDialog::Callback, this);
    _close->tooltip("Copy selected text to clipboard and close dialog.");
    _delete->callback(TextDialog::Callback, this);
    _delete->tooltip("Delete selected text.");
    _rename->callback(TextDialog::Callback, this);
    _rename->tooltip("Rename selected text.");
    _editor->buffer(_buffer);
    _editor->labelsize(flw::PREF_FONTSIZE);
    _editor->linenumber_align(FL_ALIGN_RIGHT);
    _editor->linenumber_bgcolor(FL_BACKGROUND_COLOR);
    _editor->linenumber_font(flw::PREF_FIXED_FONT);
    _editor->linenumber_format("%4d");
    _editor->linenumber_size(flw::PREF_FONTSIZE);
    _editor->linenumber_width(flw::PREF_FIXED_FONTSIZE * 3);
    _editor->textfont(flw::PREF_FIXED_FONT);
    _editor->textsize(flw::PREF_FIXED_FONTSIZE);
    _names->callback(TextDialog::Callback, this);
    _names->textfont(flw::PREF_FONT);
    _names->textsize(flw::PREF_FONTSIZE);
    _update->callback(TextDialog::Callback, this);
    _update->tooltip("Save and update current text.");
    for (auto& row : _db.get_keys(NS_SNIPPETS)) {
        _names->add(row.key().c_str());
    }
    flw::util::labelfont(this);
    callback(TextDialog::Callback, this);
    set_modal();
    resizable(_grid);
    if (FlEdit::TEXT_RECT.w() > 0 && FlEdit::TEXT_RECT.h() > 0) {
        TextDialog::resize(FlEdit::TEXT_RECT.x(), FlEdit::TEXT_RECT.y(), FlEdit::TEXT_RECT.w(), FlEdit::TEXT_RECT.h());
    }
    _grid->do_layout();
}
TextDialog::~TextDialog() {
    _editor->buffer(nullptr);
    delete _buffer;
    FlEdit::TEXT_RECT = Fl_Rect(this);
    _TextDialog_LAST_SPLIT = _split->split_pos();
}
void TextDialog::Callback(Fl_Widget* w, void* o) {
    auto self = static_cast<TextDialog*>(o);
    if (w == self || w == self->_cancel) {
        self->_run = false;
        self->hide();
    }
    else if (w == self->_close) {
        self->close();
    }
    else if (w == self->_delete) {
        self->delete_text();
    }
    else if (w == self->_names) {
        self->load_text();
    }
    else if (w == self->_rename) {
        self->rename_text();
    }
    else if (w == self->_update) {
        self->update_text();
    }
}
void TextDialog::close() {
    auto name = gnu::str::to_string(_names->text(_names->value()));
    auto row  = _db.get(NS_SNIPPETS, name);
    if (row.c_str() != nullptr) {
        _res = row.c_str();
    }
    else {
        _res = "";
    }
    if (_res != "") {
        _run = false;
        hide();
    }
}
void TextDialog::delete_text() {
    auto row = _names->value();
    if (row < 1) {
        return;
    }
    auto name =_names->text(row);
    if (_db.remove(NS_SNIPPETS, name) == false) {
        flw::dlg::msg_alert("flEdit", flw::util::format("Failed to delete text from database!\n%s", _db.err_msg.c_str()));
        return;
    }
    else {
        _names->remove(row);
        _buffer->text("");
        _names->take_focus();
        _names->value(row <= _names->size() ? row : _names->size());
        TextDialog::Callback(_names, this);
    }
}
void TextDialog::load_text() {
    auto r = _names->value();
    if (r < 1) {
        _buffer->text("");
        _close->deactivate();
        _delete->deactivate();
        _rename->deactivate();
        _update->deactivate();
        return;
    }
    else if (Fl::event_clicks() > 0) {
        Fl::event_clicks(0);
        TextDialog::Callback(_close, this);
        return;
    }
    auto name = gnu::str::to_string(_names->text(r));
    auto row  = _db.get(NS_SNIPPETS, name);
    if (row.time() != -1) {
        _buffer->text(row.c_str());
        _close->activate();
        _delete->activate();
        _rename->activate();
        _update->activate();
    }
    else {
        _buffer->text("");
        _close->deactivate();
        _delete->deactivate();
        _rename->deactivate();
        _update->deactivate();
    }
}
void TextDialog::rename_text() {
    auto r = _names->value();
    if (r < 1) {
        return;
    }
    auto name   = gnu::str::to_string(_names->text(r));
    auto rename = name;
    if (flw::dlg::input("flEdit", "Enter new name.", rename) == flw::label::CANCEL) {
        return;
    }
    gnu::str::trim(rename);
    if (rename == "" || rename == name) {
        return;
    }
    auto row = _db.get(NS_SNIPPETS, rename);
    if (row.c_str() != nullptr) {
        flw::dlg::msg_alert("flEdit", "Name exist in database!");
    }
    else if (_db.rename(NS_SNIPPETS, name, rename) == false) {
        flw::dlg::msg_alert("flEdit", flw::util::format("Failed to rename snippet!\n%s", _db.err_msg.c_str()));
    }
    else {
        _names->text(r, rename.c_str());
    }
}
std::string TextDialog::run(Fl_Window* parent) {
    _run = true;
    _names->take_focus();
    TextDialog::Callback(_names, this);
    flw::util::center_window(this, parent);
    show();
    while (_run == true) {
        Fl::wait();
        Fl::flush();
    }
    return _res;
}
void TextDialog::update_text() {
    auto r = _names->value();
    if (r < 1) {
        return;
    }
    auto name = gnu::str::to_string(_names->text(r));
    auto text = gnu::str::grab(_buffer->text());
    if (text.length() > FlEdit::MAX_SNIPPET_LENGTH) {
        flw::dlg::msg_alert("flEdit", flw::util::format("Text is too large (max %u bytes) (%u)", (unsigned) FlEdit::MAX_SNIPPET_LENGTH, (unsigned) text.length()));
        return;
    }
    else if (_db.put(NS_SNIPPETS, name, text, -1) == false) {
        flw::dlg::msg_alert("flEdit", flw::util::format("Failed to save snippet!\n%s", _db.err_msg.c_str()));
    }
}
#define FLEDIT_CB1(X) [](Fl_Widget*, void* o) { static_cast<FlEdit*>(o)->X; static_cast<FlEdit*>(o)->update_menu(); }, this
#define FLEDIT_CB2(X,Y) [](Fl_Widget*, void* o) { static_cast<FlEdit*>(o)->X; static_cast<FlEdit*>(o)->Y; static_cast<FlEdit*>(o)->update_menu(); }, this
#ifdef DEBUG_PGO
    static bool _PGO = true;
#else
    static bool _PGO = false;
#endif
FlEdit*     FlEdit::SELF  = nullptr;
Fl_Rect     FlEdit::COMMAND_RECT;
Fl_Rect     FlEdit::PROJECT_RECT;
Fl_Rect     FlEdit::TEXT_RECT;
fle::Config CONFIG;
int         KLUDGE = 0;
FlEdit::FlEdit(int W, int H) : Fl_Double_Window(W, H, "flEdit"), Message(CONFIG) {
    end();
    flw::dlg::options(this);
    FlEdit::SELF      = this;
    _dir_browser      = new DirBrowser();
    _findbar          = new fle::FindBar(CONFIG);
    _menu             = new Fl_Sys_Menu_Bar(0, 0, 0, 0);
    _output           = new CommandOutput(CONFIG, _findbar);
    _split_edit       = new flw::SplitGroup();
    _split_main       = new flw::SplitGroup();
    _tabs.split       = new flw::SplitGroup();
    _tabs.tabs1       = new flw::TabsGroup();
    _tabs.tabs2       = new flw::TabsGroup();
    _tabs.active      = _tabs.tabs1;
    _editor           = nullptr;
    _tabs.boxtype     = FL_MAX_BOXTYPE;
    _tabs.pos1        = flw::TabsGroup::Pos::TOP;
    _tabs.pos2        = flw::TabsGroup::Pos::TOP;
    _project          = { "", "", "" };
    _paths.start_path = gnu::file::work_dir().filename();
    add(_menu);
    add(_split_main);
    add(_findbar);
    _dir_browser->hide();
    _dir_browser->callback(FlEdit::CallbackFileBrowser, this);
    _split_main->add(_dir_browser, true);
    _split_main->add(_split_edit, false);
    _split_main->pos(flw::SplitGroup::Pos::VERTICAL);
    _split_main->split_pos(flw::PREF_FONTSIZE * 12);
    _split_main->min_split_pos(14 * 8);
    _split_edit->add(_tabs.split, true);
    _split_edit->add(_output, false);
    _split_edit->pos(flw::SplitGroup::Pos::HORIZONTAL);
    _split_edit->min_split_pos(14 * 3);
    _output->hide();
    _tabs.split->add(_tabs.tabs1, true);
    _tabs.split->add(_tabs.tabs2, false);
    _tabs.split->pos(flw::SplitGroup::Pos::VERTICAL);
    _tabs.split->min_split_pos(14 * 10);
    _tabs.tabs1->tab_pos(_tabs.pos1);
    _tabs.tabs2->tab_pos(_tabs.pos2);
    _tabs.tabs1->hide();
    _tabs.tabs2->hide();
    _menu->global();
    _menu->add(MENU_FILE_NEW,                   FL_COMMAND + 'n',               FLEDIT_CB1(file_new("")));
    _menu->add(MENU_FILE_OPEN,                  FL_COMMAND + 'o',               FLEDIT_CB1(file_open()));
    _recent = new flw::util::RecentMenu(_menu, FlEdit::CallbackRecent, this, MENU_FILE_OPEN_RECENT);
    _menu->add(MENU_FILE_OPEN_RELOAD,           0,                              FLEDIT_CB1(file_reload()));
    _menu->add(MENU_FILE_OPEN_HEX,              0,                              FLEDIT_CB1(file_open(true)));
    _menu->add(MENU_FILE_OPEN_BACKUP,           0,                              FLEDIT_CB1(file_backup()));
    _menu->add(MENU_FILE_READONLY,              0,                              FLEDIT_CB1(file_readonly_mode()), FL_MENU_DIVIDER | FL_MENU_TOGGLE);
    _menu->add(MENU_FILE_SAVE,                  FL_COMMAND + 's',               FLEDIT_CB1(file_save()));
    _menu->add(MENU_FILE_SAVE_AS,               0,                              FLEDIT_CB1(file_save_as()));
    _menu->add(MENU_FILE_SAVE_ALL,              0,                              FLEDIT_CB1(tabs_save_all(false)), FL_MENU_DIVIDER);
    _menu->add(MENU_FILE_CLOSE,                 FL_COMMAND + 'w',               FLEDIT_CB1(file_close()));
    _menu->add(MENU_FILE_CLOSE_ALL,             0,                              FLEDIT_CB1(file_close_all()), FL_MENU_DIVIDER);
    _menu->add(MENU_FILE_NEW_WINDOW,            0,                              FLEDIT_CB1(new_window()), FL_MENU_DIVIDER);
    _menu->add(MENU_FILE_TERMINATE,             0,                              FLEDIT_CB1(file_terminate()));
    _menu->add(MENU_FILE_QUIT,                  FL_COMMAND + 'q',               FLEDIT_CB1(quit()));
    _menu->add(MENU_FIND_SHOW,                  FL_CTRL + 'f',                  FLEDIT_CB1(show_find()));
    _menu->add(MENU_FIND_LINES,                 FL_CTRL + 'j',                  FLEDIT_CB1(tabs_find_lines()), FL_MENU_DIVIDER);
    _menu->add(MENU_FIND_REPLACE,               FL_CTRL + FL_SHIFT + 'j',       FLEDIT_CB1(tabs_replace_all()));
    _menu->add(MENU_FIND_TRAILING,              0,                              FLEDIT_CB1(tabs_trailing_all()));
    _menu->add(MENU_TOOLS_CMDREPEAT,            FL_F + 8,                       FLEDIT_CB1(tools_run_command(true)));
    _menu->add(MENU_TOOLS_CMD,                  FL_SHIFT + FL_F + 8,            FLEDIT_CB1(tools_run_command(false)), FL_MENU_DIVIDER);
    _menu->add(MENU_TOOLS_NEXTOUTPUT,           FL_F + 10,                      FLEDIT_CB1(_output->list_next()));
    _menu->add(MENU_TOOLS_PREVOUTPUT,           FL_F + FL_SHIFT + 10,           FLEDIT_CB1(_output->list_prev()));
    _menu->add(MENU_TOOLS_CLEAR_OUTPUT,         FL_F + FL_CTRL + FL_SHIFT + 10, FLEDIT_CB1(_output->clear_all()), FL_MENU_DIVIDER);
    _menu->add(MENU_TOOLS_SNIPPETS,             FL_F + 7,                       FLEDIT_CB1(project_load_snippet_from_db()));
    _menu->add(MENU_TOOLS_SAVE_CLIPBOARD,       0,                              FLEDIT_CB1(project_save_snippet_to_db(SNIPPET::CLIPBOARD)));
    _menu->add(MENU_TOOLS_SAVE_SELECTION,       0,                              FLEDIT_CB1(project_save_snippet_to_db(SNIPPET::SELECTION)));
    _menu->add(MENU_TOOLS_SAVE_TEXT,            0,                              FLEDIT_CB1(project_save_snippet_to_db(SNIPPET::TEXT)));
#ifndef __APPLE__
    _menu->add(MENU_VIEW_TOGGLE_FULL,           FL_F + 11,                      FLEDIT_CB1(toggle_fullscreen()));
    _menu->add(MENU_VIEW_TOGGLE_MENU,           FL_F + 11 + FL_SHIFT,           FLEDIT_CB1(toggle_menu()));
#endif
    _menu->add(MENU_VIEW_TOGGLE_TABS,           FL_F + 11 + FL_SHIFT + FL_CTRL, FLEDIT_CB1(toggle_tabs()));
    _menu->add(MENU_VIEW_TOGGLE_BROWSER,        FL_CTRL + '5',                  FLEDIT_CB1(toggle_dir_browser()));
    _menu->add(MENU_VIEW_TOGGLE_OUTPUT,         FL_CTRL + '4',                  FLEDIT_CB1(toggle_output()), FL_MENU_DIVIDER);
    _menu->add(MENU_VIEW_TOGGLE_ONE,            FL_CTRL + FL_SHIFT + '1',       FLEDIT_CB1(toggle_one()));
    _menu->add(MENU_VIEW_TOGGLE_TWO,            FL_CTRL + FL_SHIFT + '2',       FLEDIT_CB1(toggle_two()));
    _menu->add(MENU_VIEW_ACTIVATE_ONE,          FL_CTRL + '1',                  FLEDIT_CB1(show_one()));
    _menu->add(MENU_VIEW_ACTIVATE_TWO,          FL_CTRL + '2',                  FLEDIT_CB1(show_two()), FL_MENU_DIVIDER);
    _menu->add(MENU_VIEW_MOVE_OPPOSITE,         FL_CTRL + '3',                  FLEDIT_CB1(tabs_move_editor()));
    _menu->add(MENU_VIEW_MOVE_TO_RIGHT,         0,                              FLEDIT_CB1(tabs_move_all(false)));
    _menu->add(MENU_VIEW_MOVE_TO_LEFT,          0,                              FLEDIT_CB1(tabs_move_all(true)), FL_MENU_DIVIDER);
    _menu->add(MENU_VIEW_SORT_LEFT_TABS_ASC,    0,                              FLEDIT_CB1(tabs_sort(true, true)));
    _menu->add(MENU_VIEW_SORT_LEFT_TABS_DESC,   0,                              FLEDIT_CB1(tabs_sort(true, false)));
    _menu->add(MENU_VIEW_SORT_RIGHT_TABS_ASC,   0,                              FLEDIT_CB1(tabs_sort(false, true)));
    _menu->add(MENU_VIEW_SORT_RIGHT_TABS_DESC,  0,                              FLEDIT_CB1(tabs_sort(false, false)));
    _menu->add(MENU_PROJECT_LOAD,               0,                              FLEDIT_CB1(project_load_from_db("")));
    _menu->add(MENU_PROJECT_SAVE,               0,                              FLEDIT_CB1(project_save_to_db()));
    _menu->add(MENU_PROJECT_SAVEAS,             0,                              FLEDIT_CB1(project_save_as_to_db(false)));
    _menu->add(MENU_PROJECT_RENAME,             0,                              FLEDIT_CB1(project_save_as_to_db(true)), FL_MENU_DIVIDER);
    _menu->add(MENU_PROJECT_CLOSE,              0,                              FLEDIT_CB1(project_close(true)));
    _menu->add(MENU_PROJECT_CLOSE2,             0,                              FLEDIT_CB1(project_close(false)), FL_MENU_DIVIDER);
    _menu->add(MENU_PROJECT_DIR,                0,                              FLEDIT_CB1(project_path()));
    _menu->add(MENU_PROJECT_WORDFILE,           0,                              FLEDIT_CB1(project_wordlist()), FL_MENU_DIVIDER);
    _menu->add(MENU_PROJECT_DB_OPEN,            0,                              FLEDIT_CB1(project_open_db()));
    _menu->add(MENU_PROJECT_DB_DEFRAG,          0,                              FLEDIT_CB1(project_defrag_db()));
    _menu->add(MENU_PROJECT_DB_CLOSE,           0,                              FLEDIT_CB1(project_close_db()));
    _menu->add(MENU_SETTINGS_THEME,             0,                              FLEDIT_CB1(settings_theme()));
    _menu->add(MENU_SETTINGS_EDITOR,            0,                              FLEDIT_CB1(settings_editor()));
    _menu->add(MENU_SETTINGS_SCHEME,            0,                              FLEDIT_CB1(settings_scheme()), FL_MENU_DIVIDER);
    _menu->add(MENU_SETTINGS_BACKUP,            0,                              FLEDIT_CB1(settings_backup()));
    _menu->add(MENU_SETTINGS_LOAD_PREF,         0,                              FLEDIT_CB1(settings_load_pref()));
    _menu->add(MENU_SETTINGS_SAVE_PREF,         0,                              FLEDIT_CB1(settings_save_pref()), FL_MENU_DIVIDER);
    _menu->add(MENU_SETTINGS_SPLIT_VERTICAL,    0,                              FLEDIT_CB1(settings_split_vertical()), FL_MENU_RADIO);
    _menu->add(MENU_SETTINGS_SPLIT_HORIZONTAL,  0,                              FLEDIT_CB1(settings_split_horizontal()), FL_MENU_RADIO);
    _menu->add(MENU_SETTINGS_OUTPUT_SWAP,       0,                              FLEDIT_CB1(settings_output_swap()));
    _menu->add(MENU_SETTINGS_OUTPUT_VERTICAL,   0,                              FLEDIT_CB1(settings_output_vertical()), FL_MENU_RADIO);
    _menu->add(MENU_SETTINGS_OUTPUT_HORIZONTAL, 0,                              FLEDIT_CB1(settings_output_horizontal()), FL_MENU_RADIO | FL_MENU_DIVIDER);
    _menu->add(MENU_SETTINGS_OUTPUT_CLEAR,      0,                              nullptr, nullptr, FL_MENU_TOGGLE);
    _menu->add(MENU_SETTINGS_OUTPUT_UNKNOWN,    0,                              nullptr, nullptr, FL_MENU_TOGGLE);
    _menu->add(MENU_SETTINGS_TAB_G11,           0,                              FLEDIT_CB1(settings_tab_g11()), FL_MENU_RADIO);
    _menu->add(MENU_SETTINGS_TAB_G12,           0,                              FLEDIT_CB1(settings_tab_g12()), FL_MENU_RADIO);
    _menu->add(MENU_SETTINGS_TAB_G13,           0,                              FLEDIT_CB1(settings_tab_g13()), FL_MENU_RADIO);
    _menu->add(MENU_SETTINGS_TAB_G14,           0,                              FLEDIT_CB1(settings_tab_g14()), FL_MENU_RADIO);
    _menu->add(MENU_SETTINGS_TAB_G21,           0,                              FLEDIT_CB1(settings_tab_g21()), FL_MENU_RADIO);
    _menu->add(MENU_SETTINGS_TAB_G22,           0,                              FLEDIT_CB1(settings_tab_g22()), FL_MENU_RADIO);
    _menu->add(MENU_SETTINGS_TAB_G23,           0,                              FLEDIT_CB1(settings_tab_g23()), FL_MENU_RADIO);
    _menu->add(MENU_SETTINGS_TAB_G24,           0,                              FLEDIT_CB1(settings_tab_g24()), FL_MENU_RADIO | FL_MENU_DIVIDER);
    _menu->add(MENU_SETTINGS_TAB_DEF,           0,                              FLEDIT_CB1(pref_set_tabslook(FL_MAX_BOXTYPE)), FL_MENU_RADIO);
    _menu->add(MENU_SETTINGS_TAB_BORDER,        0,                              FLEDIT_CB1(pref_set_tabslook(FL_BORDER_BOX)), FL_MENU_RADIO);
    _menu->add(MENU_SETTINGS_TAB_FLAT,          0,                              FLEDIT_CB1(pref_set_tabslook(FL_FLAT_BOX)), FL_MENU_RADIO);
    _menu->add(MENU_HELP_ABOUT,                 0,                              FLEDIT_CB1(help_about()), FL_MENU_DIVIDER);
    _menu->add(MENU_HELP_FLEDIT,                FL_F + 1,                       FLEDIT_CB1(help_fledit()));
    _menu->add(MENU_HELP_EDITOR,                0,                              FLEDIT_CB1(help_editor()));
    _menu->add(MENU_HELP_PCRE,                  0,                              FLEDIT_CB1(help_pcre()));
#ifdef DEBUG
    _menu->add(MENU_DEBUG,                      0,                              FLEDIT_CB1(debug()));
    _menu->add(MENU_DEBUG_SIZE,                 0,                              FLEDIT_CB1(debug_size()));
    _menu->add(MENU_DEBUG_COMPARE,              0,                              FLEDIT_CB1(debug_compare()), FL_MENU_DIVIDER);
#endif
    _menu->add(MENU_DEBUG_PGO_RUN,              0,                              FLEDIT_CB1(tabs_pgo()));
    _menu->add(MENU_DEBUG_PGO_UNDO,             0,                              FLEDIT_CB1(tabs_pgo_undo()));
    if (_PGO == false) {
        flw::menu::get_item(_menu, MENU_DEBUG_PGO)->hide();
    }
    _recent->max_items(20);
    resizable(this);
    size_range(320, 240);
    flw::theme::load_icon(this, 666, icon_xpm, "flEdit");
    callback(FlEdit::CallbackWindow, this);
    tabs_check_empty();
    pref_load();
    split_view(Split::SHOW_ONE);
    update_menu();
}
FlEdit::~FlEdit() {
    for (auto c : Command::COMMANDS) {
        delete c;
    }
    delete _recent;
}
void FlEdit::CallbackFileBrowser(Fl_Widget*, void*) {
    FlEdit::SELF->file_load(FlEdit::SELF->_editor, FlEdit::SELF->_dir_browser->file());
    FlEdit::SELF->tabs_check_empty();
    FlEdit::SELF->do_layout();
}
void FlEdit::CallbackList(Fl_Widget*, void*) {
    FlEdit::SELF->callback_list();
}
void FlEdit::callback_list() {
    auto  list = _output->list();
    auto& rx   = _output->list_rx();
    auto  row  = list->value();
    if (row == 0) {
        return;
    }
    else if (rx.pattern() == "") {
        return;
    }
    else if (rx.is_compiled() == false) {
        flw::dlg::msg_alert("flEdit", flw::util::format("Regex expression error!\n%s\n%s", _list_rx.err().c_str(), _list_rx.pattern().c_str()));
        return;
    }
    auto text    = list->text(row);
    auto matches = rx.set_names({"file", "line", "col"}).exec(text, strlen(text));
    if (matches.size() > 1) {
        gnu::pcre8::Match f    = rx.match("file");
        gnu::pcre8::Match l    = rx.match("line");
        gnu::pcre8::Match c    = rx.match("col");
        int               line = (int) gnu::str::to_int(l.word(), 1);
        int               col  = (int) gnu::str::to_int(c.word(), 1);
        if (f.word() != "") {
            return tabs_activate_cursor(Command::WORKDIR, f.word(), line, col);
        }
    }
    if (_editor != nullptr) {
        _editor->view().take_focus();
    }
}
void FlEdit::CallbackRecent(Fl_Widget*, void*) {
    FlEdit::SELF->file_load(FlEdit::SELF->_editor, FlEdit::SELF->_menu->text(), true);
    FlEdit::SELF->tabs_check_empty();
    FlEdit::SELF->do_layout();
}
void FlEdit::CallbackWindow(Fl_Widget*, void*) {
    if (Fl::event() == FL_SHORTCUT && Fl::event_key() == FL_Escape) {
        return;
    }
    FlEdit::SELF->quit();
}
void FlEdit::debug() {
#ifdef DEBUG
    printf("\nFlEdit:\n");
    printf("Tabs1 has %02d editors, %s and is %s\n", _tabs.tabs1->children(), _tabs.active == _tabs.tabs1 ? "FOCUSED" : "UNFOCUSED", _tabs.tabs1->visible() ? "VISIBLE" : "HIDDEN");
    printf("Tabs2 has %02d editors, %s and is %s\n", _tabs.tabs2->children(), _tabs.active == _tabs.tabs2 ? "FOCUSED" : "UNFOCUSED", _tabs.tabs2->visible() ? "VISIBLE" : "HIDDEN");
    if (_editor != nullptr) {
        printf("_editor       = '%s'\n", _editor->filename_long().c_str());
        printf("editor_split  = '%s'\n", &_editor->view() == _editor->view1() ? "SPLIT1" : "SPLIT2");
        printf("backup1       = '%s'\n", _editor->filename_backup().c_str());
        printf("backup2       = '%s'\n", _editor->filename_backup_today().c_str());
    }
    printf("start_path    = '%s'\n", _paths.start_path.c_str());
    printf("open_path     = '%s'\n", _paths.open_path.c_str());
    printf("_db           = '%s'\n", _db.filename().c_str());
    printf("_project.path = '%s'\n", _project.path.c_str());
    printf("_project.name = '%s'\n", _project.name.c_str());
    auto tabindex = 0;
    auto editor   = tabs_editor_by_index(tabindex);
    while (editor != nullptr) {
        printf("file_%02d       = %p| %s\n", tabindex, editor, editor->filename_long().c_str());
        editor = tabs_editor_by_index(tabindex);
    }
    fflush(stdout);
#endif
}
void FlEdit::debug_compare() {
#ifdef DEBUG
    if (_editor != nullptr) {
        _editor->file_compare_buffer();
    }
#endif
}
int FlEdit::handle(int event) {
    if (event == FL_PASTE) {
        if (Fl::clipboard_contains(Fl::clipboard_plain_text) != 0) {
            project_save_snippet_to_db(SNIPPET::CLIPBOARD, gnu::str::to_string(Fl::event_text()));
            return 1;
        }
    }
    return Fl_Double_Window::handle(event);
}
void FlEdit::help_about() {
    std::string text = FLEDIT_ABOUT;
    auto tabindex = 0;
    auto editor   = tabs_editor_by_index(tabindex);
    size_t        B = 0;
    size_t        S = 0;
    size_t        U = 0;
    size_t        T = 0;
    size_t        C = 0;
    size_t        L = 0;
    while (editor != nullptr) {
        size_t b = 0;
        size_t s = 0;
        size_t u = 0;
        T += editor->memory_usage(b, s, u);
        L += editor->count_lines();
        B += b;
        S += s;
        U += u;
        C += 1;
        editor = tabs_editor_by_index(tabindex);
    }
    text += gnu::str::format("Build info:\n");
    text += gnu::str::format("Date:   %s - %s\n", __DATE__, __TIME__);
#if __GNUC__
    text += gnu::str::format("GCC:    %s\n", __VERSION__);
#endif
    text += gnu::str::format("FLTK:   %d.%d.%d\n", FL_MAJOR_VERSION, FL_MINOR_VERSION, FL_PATCH_VERSION);
    text += gnu::str::format("SQLite: %s\n", gnu::db2::DB::Version().c_str());
    text += gnu::str::format("PCRE:   %s\n", gnu::pcre8::version().c_str());
    text += "\n";
    text += "Current session:\n";
    text += "Database name:       " + _db.filename() + "\n";
    text += "Project name:        " + _project.name + "\n";
    text += "Files:               " + gnu::str::format("%13s", gnu::str::format_int(C, '\'').c_str()) + "\n";
    text += "Lines:               " + gnu::str::format("%13s", gnu::str::format_int(L, '\'').c_str()) + "\n";
    text += "Buffer memory:       " + gnu::str::format("%13s", gnu::str::format_int(B, '\'').c_str()) + "\n";
    text += "Style memory:        " + gnu::str::format("%13s", gnu::str::format_int(S, '\'').c_str()) + "\n";
    if (CONFIG.has_fle_undo() == true) {
    text += "Undo capacity:       " + gnu::str::format("%13s", gnu::str::format_int(U, '\'').c_str()) + "\n";
    }
    text += "Total memory:        " + gnu::str::format("%13s", gnu::str::format_int(T, '\'').c_str()) + "\n";
    text += "\n";
    text += "Backup directory:    " + CONFIG.pref_backup.filename() + "\n";
    text += "Start directory:     " + _paths.start_path + "\n";
    text += "Project directory:   " + _project.path + "\n";
    text += "Open file directory: " + _paths.open_path + "\n";
    text += "Current directory:   " + gnu::file::work_dir().filename() + "\n";
    text += "\n";
    flw::dlg::list("flEdit - About", text, true, 45, 55);
}
void FlEdit::help_fledit() {
    std::string text = FLEDIT_HELP;
    text += fle::help::flags(CONFIG);
    flw::dlg::list("flEdit - Help", text, true, 60, 50);
}
fle::Message::CTRL FlEdit::message(const std::string& message, const std::string& s1, const std::string& s2, void* p) {
    if (message == fle::message::TEXT_CHANGED || message == fle::message::FILE_LOADED) {
        assert(p);
        auto editor = static_cast<fle::Editor*>(p);
        if (editor != _output->editor()) {
            editor_update_status(editor);
            update_menu();
        }
    }
    else if (message == fle::message::EDITOR_FOCUS) {
        assert(p);
        assert(_tabs.active);
        auto editor = static_cast<fle::Editor*>(p);
        if (editor != _output->editor()) {
            _editor      = editor;
            _tabs.active = static_cast<flw::TabsGroup*>(_editor->parent());
            update_menu();
        }
    }
    else if (message == fle::message::DND_EVENT) {
        auto lines   = gnu::str::split(s1, "\n");
        auto discard = static_cast<bool*>(p);
        auto files   = std::vector<std::string>();
        *discard = true;
        for (auto line : lines) {
            gnu::str::replace(line, "file://");
            line = fle::string::fix_dnd_filename(line);
            if (line != "") {
                auto file = gnu::file::File(line);
                if (file.is_file() == true) {
                    files.push_back(file.filename());
                }
            }
        }
        if (files.size() == 0) {
            *discard = false;
            return Message::CTRL::ABORT;
        }
        else {
            file_load_list(_editor, files);
            return Message::CTRL::ABORT;
        }
    }
    else if (message == fle::message::PREF_CHANGED) {
        update_pref();
    }
    else if (message == fle::message::HIDE_FIND) {
        _findbar->hide();
        _editor->take_focus();
        do_layout();
        return Message::CTRL::ABORT;
    }
    else if (message == fle::message::SHOW_FIND) {
        auto editor = _editor;
        _findbar->show();
        _findbar->focus();
        do_layout();
        _editor = editor;
        return Message::CTRL::ABORT;
    }
    else if (message == fle::message::SHOW_CUSTOM1) {
        tabs_list();
    }
    else if (message == fle::message::CUSTOM_CALLBACK) {
        if (s2 == "files") {
            tabs_activate_cursor("", s1);
            return Message::CTRL::ABORT;
        }
    }
    return Message::CTRL::CONTINUE;
}
void FlEdit::new_window() {
    if (gnu::file::run(executable, true) != 0) {
        flw::dlg::msg_alert("flEdit", "Failed to open a new window!");
    }
}
bool FlEdit::quit() {
    std::string answer;
    if (Command::THREAD != nullptr) {
        answer = flw::dlg::msg_ask(
            "flEdit",
            "Command is still running....\n"
            "It might continue to do that forever.\n"
            "If so you must kill it manually!\n"
            "If you quit now flEdit might freeze or crash.",
            "!Wait",
            "Quit"
        );
        if (answer == "Wait") {
            return false;
        }
    }
    if (project_close(true) == false) {
        return false;
    }
    pref_save();
    hide();
    return true;
}
void FlEdit::resize(int X, int Y, int W, int H) {
#ifdef DEBUG
#endif
#ifdef __APPLE__
    static bool v = false;
#else
    static bool v = true;
#endif
    Fl_Double_Window::resize(X, Y, W, H);
    if (W == _rect.w() && H == _rect.h()) {
        return;
    }
    auto fh = _findbar->height();
    if (_menu->visible() == 0 || v == false) {
        _split_main->resize(0, 0, W, H - fh);
    }
    else {
        _menu->resize(0, 0, W, flw::PREF_FONTSIZE * 2);
        _split_main->resize(0, flw::PREF_FONTSIZE * 2, W, H - flw::PREF_FONTSIZE * 2 - fh);
    }
    _findbar->resize(0, H - fh, W, fh);
    _rect = Fl_Rect(this);
    Fl::redraw();
#ifdef DEBUG
#endif
}
void FlEdit::settings_backup() {
    auto path = (CONFIG.pref_backup.is_dir() == true) ? CONFIG.pref_backup.c_str() : gnu::file::home_dir().c_str();
    auto dir  = gnu::str::to_string(fl_dir_chooser("Select Backup Directory Or Press Cancel To Disable Backup", path));
    CONFIG.pref_backup = gnu::file::File(dir);
}
void FlEdit::settings_output_horizontal() {
    flw::menu::setonly_item(_menu, MENU_SETTINGS_OUTPUT_HORIZONTAL);
    _split_edit->pos(flw::SplitGroup::Pos::HORIZONTAL);
    _split_edit->split_pos(h() - 200);
    _output->tab_pos(flw::TabsGroup::Pos::LEFT);
    do_layout();
}
void FlEdit::settings_output_vertical() {
    flw::menu::setonly_item(_menu, MENU_SETTINGS_OUTPUT_VERTICAL);
    _split_edit->pos(flw::SplitGroup::Pos::VERTICAL);
    _split_edit->split_pos(w() - 200);
    _output->tab_pos(flw::TabsGroup::Pos::TOP);
    do_layout();
}
void FlEdit::split_view(Split value) {
    bool r = false;
    if (value == Split::SHOW_ONE || value == Split::SHOW_TWO) {
        auto other = _tabs.tabs2;
        if (value == Split::SHOW_ONE) {
            _tabs.active = _tabs.tabs1;
        }
        else {
            _tabs.active = _tabs.tabs2;
            other        = _tabs.tabs1;
        }
        if (_tabs.active->visible() == false) {
            r = true;
            _tabs.active->show();
            if (other->visible() != 0) {
                _tabs.split->split_pos(-1);
            }
        }
        _tabs.active->take_focus();
    }
    else if (value == Split::HIDE_ONE) {
        if (_tabs.tabs1->visible() != 0 && _tabs.tabs2->visible() != 0) {
            _tabs.tabs1->hide();
            _tabs.active = _tabs.tabs2;
            r = true;
        }
    }
    else if (value == Split::HIDE_TWO) {
        if (_tabs.tabs2->visible() != 0 && _tabs.tabs1->visible() != 0) {
            _tabs.tabs2->hide();
            _tabs.active = _tabs.tabs1;
            r = true;
        }
    }
    else if (value == Split::VER && _tabs.split->pos() == flw::SplitGroup::Pos::HORIZONTAL) {
        _tabs.split->pos(flw::SplitGroup::Pos::VERTICAL);
        r = true;
    }
    else if (value == Split::HOR && _tabs.split->pos() == flw::SplitGroup::Pos::VERTICAL) {
        _tabs.split->pos(flw::SplitGroup::Pos::HORIZONTAL);
        r = true;
    }
    if (r == true) {
        do_layout();
    }
    else {
        redraw();
    }
}
void FlEdit::tools_run_command(bool repeat) {
    std::string filename;
    std::string selection;
    if (_editor != nullptr) {
        filename  = _editor->filename_long();
        selection = _editor->text_get_selection_string();
    }
    if (KLUDGE == 0) {
        KLUDGE++;
        _output->run_command(_project.path, filename, selection, repeat);
        gnu::Time::SleepMilli(100);
        KLUDGE--;
    }
}
void FlEdit::toggle_dir_browser() {
    if (_project.path == "") {
        _dir_browser->hide();
        _dir_browser->load_root("");
    }
    else {
        if (_dir_browser->visible() == 0) {
            _dir_browser->show();
        }
        else {
            _dir_browser->hide();
        }
        if (_dir_browser->root() == "") {
            _dir_browser->load_root(_project.path);
        }
    }
    do_layout();
}
void FlEdit::update_menu() {
    gnu::file::File file;
    std::string     changed_name;
    std::string     path;
    if (_editor != nullptr) {
        file         = gnu::file::File(_editor->filename_long());
        changed_name = _editor->filename_short_changed();
        path         = _editor->filename_path();
    }
    if (changed_name != "") {
        if (file.is_file() == true) {
            _paths.open_path = file.path();
        }
        if (_editor->text_is_readonly() == true) {
            flw::menu::enable_item(_menu, MENU_FILE_SAVE, false);
            flw::menu::enable_item(_menu, MENU_FILE_SAVE_AS, false);
        }
        else {
            flw::menu::enable_item(_menu, MENU_FILE_SAVE, _editor->text_is_dirty());
            flw::menu::enable_item(_menu, MENU_FILE_SAVE_AS, true);
        }
        flw::menu::enable_item(_menu, MENU_FILE_CLOSE, true);
        flw::menu::enable_item(_menu, MENU_FILE_OPEN_RELOAD, true);
        flw::menu::enable_item(_menu, MENU_FILE_READONLY, true);
        flw::menu::enable_item(_menu, MENU_VIEW_MOVE_OPPOSITE, true);
        flw::menu::set_item(_menu, MENU_FILE_READONLY, _editor->text_is_readonly());
    }
    else {
        flw::menu::enable_item(_menu, MENU_FILE_CLOSE, true);
        flw::menu::enable_item(_menu, MENU_FILE_SAVE, false);
        flw::menu::enable_item(_menu, MENU_FILE_SAVE_AS, false);
        flw::menu::enable_item(_menu, MENU_FILE_OPEN_RELOAD, false);
        flw::menu::enable_item(_menu, MENU_FILE_READONLY, false);
        flw::menu::enable_item(_menu, MENU_VIEW_MOVE_OPPOSITE, false);
        flw::menu::set_item(_menu, MENU_FILE_READONLY, false);
    }
    flw::menu::enable_item(_menu, MENU_FILE_SAVE_ALL, tabs_count());
    flw::menu::enable_item(_menu, MENU_FILE_CLOSE_ALL, tabs_count());
    flw::menu::enable_item(_menu, MENU_FIND_LINES, tabs_count());
    flw::menu::enable_item(_menu, MENU_FIND_REPLACE, tabs_count());
    flw::menu::enable_item(_menu, MENU_FIND_TRAILING, tabs_count());
    if (_db.is_open() == true) {
        flw::menu::enable_item(_menu, MENU_PROJECT_DB_OPEN, false);
        flw::menu::enable_item(_menu, MENU_PROJECT_DB_CLOSE, true);
        flw::menu::enable_item(_menu, MENU_PROJECT_DB_DEFRAG, true);
        flw::menu::enable_item(_menu, MENU_PROJECT_LOAD, true);
        flw::menu::enable_item(_menu, MENU_PROJECT_SAVEAS, true);
        flw::menu::enable_item(_menu, MENU_TOOLS_SNIPPETS, true);
        flw::menu::enable_item(_menu, MENU_TOOLS_SAVE_CLIPBOARD, true);
        flw::menu::enable_item(_menu, MENU_TOOLS_SAVE_SELECTION, true);
        flw::menu::enable_item(_menu, MENU_TOOLS_SAVE_TEXT, true);
    }
    else {
        flw::menu::enable_item(_menu, MENU_PROJECT_DB_OPEN, true);
        flw::menu::enable_item(_menu, MENU_PROJECT_DB_CLOSE, false);
        flw::menu::enable_item(_menu, MENU_PROJECT_DB_DEFRAG, false);
        flw::menu::enable_item(_menu, MENU_PROJECT_LOAD, false);
        flw::menu::enable_item(_menu, MENU_PROJECT_SAVEAS, false);
        flw::menu::enable_item(_menu, MENU_TOOLS_SNIPPETS, false);
        flw::menu::enable_item(_menu, MENU_TOOLS_SAVE_CLIPBOARD, false);
        flw::menu::enable_item(_menu, MENU_TOOLS_SAVE_SELECTION, false);
        flw::menu::enable_item(_menu, MENU_TOOLS_SAVE_TEXT, false);
    }
    if (changed_name == "**") {
        changed_name = "*untitled*";
    }
    if (_project.name != "") {
        flw::menu::enable_item(_menu, MENU_PROJECT_SAVE, true);
        flw::menu::enable_item(_menu, MENU_PROJECT_CLOSE, true);
        flw::menu::enable_item(_menu, MENU_PROJECT_CLOSE2, true);
        flw::menu::enable_item(_menu, MENU_PROJECT_DIR, true);
        flw::menu::enable_item(_menu, MENU_PROJECT_RENAME, true);
        flw::menu::enable_item(_menu, MENU_PROJECT_WORDFILE, true);
        flw::menu::enable_item(_menu, MENU_VIEW_TOGGLE_BROWSER, _project.path != "");
        if (changed_name != "") {
            copy_label(std::string("flEdit [" + _project.name + "] - " + changed_name + " - " + path).c_str());
        }
        else {
            copy_label(std::string("flEdit [" + _project.name + "]").c_str());
        }
    }
    else {
        flw::menu::enable_item(_menu, MENU_PROJECT_SAVE, false);
        flw::menu::enable_item(_menu, MENU_PROJECT_CLOSE, false);
        flw::menu::enable_item(_menu, MENU_PROJECT_CLOSE2, false);
        flw::menu::enable_item(_menu, MENU_PROJECT_DIR, false);
        flw::menu::enable_item(_menu, MENU_PROJECT_RENAME, false);
        flw::menu::enable_item(_menu, MENU_PROJECT_WORDFILE, false);
        flw::menu::enable_item(_menu, MENU_VIEW_TOGGLE_BROWSER, false);
        if (changed_name != "") {
            copy_label(std::string("flEdit - " + changed_name + " - " + path).c_str());
        }
        else {
            copy_label("flEdit");
        }
    }
    if (_tabs.tabs1->visible() != 0 && _tabs.tabs2->visible() == 0) {
        flw::menu::enable_item(_menu, MENU_VIEW_TOGGLE_ONE, false);
    }
    else if (_tabs.tabs1->visible() == 0 && _tabs.tabs2->visible() != 0) {
        flw::menu::enable_item(_menu, MENU_VIEW_TOGGLE_TWO, false);
    }
    else {
        flw::menu::enable_item(_menu, MENU_VIEW_TOGGLE_ONE, true);
        flw::menu::enable_item(_menu, MENU_VIEW_TOGGLE_TWO, true);
    }
}
void FlEdit::update_pref() {
    _output->update_pref();
    _findbar->update_pref();
    _dir_browser->update_pref();
    _menu->textfont(flw::PREF_FONT);
    _menu->textsize(flw::PREF_FONTSIZE);
    _tabs.tabs1->update_pref();
    _tabs.tabs2->update_pref();
    FlEdit::do_layout();
    Fl::redraw();
}
bool FlEdit::editor_close(fle::Editor* editor, bool ask) {
    if (editor == nullptr) return true;
    if (editor->text_is_dirty() == true && ask == ASK_SAVE) {
        tabs_activate(editor);
       std::string answer;
        if (editor->filename_long() == "") {
            answer = flw::dlg::msg_ask("flEdit", "New file is unsaved!", "&Save", "!&Cancel", "Discard");
        }
        else {
            answer = flw::dlg::msg_ask("flEdit", (editor->filename_long() + " has been changed"), "&Save", "!&Cancel", "Discard");
        }
        if (answer == "&Cancel") {
            return false;
        }
        else if (answer == "&Save" && file_save(editor) == false) {
            return false;
        }
    }
    _recent->insert(editor->filename_long());
    tabs_delete(editor);
    return true;
}
void FlEdit::editor_set_style(fle::Editor* editor, std::string override_style) {
    if (editor == nullptr) return;
    if (override_style != "") {
        editor->style_from_language(override_style);
    }
    else {
        editor->style_from_filename();
    }
}
void FlEdit::editor_update_status(fle::Editor* editor) {
    if (editor == nullptr) {
        return;
    }
    auto tabs = (flw::TabsGroup*) editor->parent();
    if (tabs == nullptr) {
        return;
    }
    auto name      = editor->filename_short_changed();
    auto do_resize = (name == "**") ? true : false;
    if (name == "**") {
        name = "*untitled*";
    }
    tabs->tab_label(name, editor);
    if (do_resize == true) {
        _tabs.active->do_layout();
    }
}
void FlEdit::file_backup() {
    if (_editor == nullptr) {
        return;
    }
    auto backup = gnu::file::File(_editor->filename_backup_today());
    if (backup.is_file() == false) {
        flw::dlg::msg_alert("flEdit", flw::util::format("There is no backup file for %s today!", _editor->filename_short().c_str()));
    }
    else {
        file_load(_editor, backup.filename(), false, 0);
        tabs_check_empty();
        do_layout();
    }
}
void FlEdit::file_close() {
    editor_close(_editor, ASK_SAVE);
    tabs_check_empty();
    _tabs.split->do_layout();
}
void FlEdit::file_close_all() {
    tabs_save_visibility();
    if (tabs_save_all(true) == true) {
        tabs_close_all();
        tabs_check_empty();
        tabs_restore_visibility();
        _tabs.split->do_layout();
    }
}
fle::Editor* FlEdit::file_load(Fl_Widget* after, const std::string& filename, bool add_recent, int line, bool as_hex) {
    auto fi     = gnu::file::File(filename, OPEN_FILE_USING_REAL_NAME);
    auto editor = tabs_editor_by_path(fi.filename());
    if (fi.is_dir() == true) {
        return nullptr;
    }
    else if (editor != nullptr && as_hex == false) {
        tabs_activate(editor);
        return editor;
    }
    editor   = new fle::Editor(CONFIG, _findbar, _tabs.active->x(), _tabs.active->y(), _tabs.active->w(), _tabs.active->h());
    auto err = editor->file_load(fi.filename(), as_hex);
    if (err != "") {
        flw::dlg::msg_alert("flEdit", err);
        delete editor;
        return nullptr;
    }
    if (add_recent == true) {
        _recent->insert(fi.filename());
    }
    if (line > 0) {
        editor->cursor_move_to_rowcol(line, 1);
    }
    _tabs.active->add(editor->filename_short_changed(), editor, after);
    _tabs.active->tooltip(editor->filename_long(), editor);
    editor_set_style(editor);
    editor_update_status(editor);
    return editor;
}
std::vector<std::string> FlEdit::file_load_dialog() {
    auto fc  = Fl_File_Chooser(_paths.open_path.c_str(), fle::strings::FILE_FILTER.c_str(), Fl_File_Chooser::MULTI, "Select Files");
    auto res = std::vector<std::string>();
    fc.show();
    while (fc.visible() != 0) {
        Fl::wait();
        Fl::flush();
    }
    for (int f = 1; f <= fc.count(); f++) {
        res.push_back(fc.value(f));
    }
    return res;
}
void FlEdit::file_load_list(Fl_Widget* after, std::vector<std::string> filenames, std::vector<int> filelines, bool as_hex) {
#ifdef DEBUG
    auto time = gnu::Time::Milli();
#endif
    auto wc = flw::WaitCursor();
    for (size_t f = 0; f < filenames.size(); f++) {
        file_load((f == 0) ? after : _editor, filenames[f], true, (filelines.size() > f) ? filelines[f] : 0, as_hex);
    }
    tabs_check_empty();
    _tabs.split->show();
    do_layout();
#ifdef DEBUG
    printf("loaded %d files in %d mS\n", (int) filenames.size(), (int) (gnu::Time::Milli() - time));
    fflush(stdout);
#endif
}
void FlEdit::file_new(const std::string& filename) {
    auto editor = new fle::Editor(CONFIG, _findbar);
    _tabs.active->add(editor->filename_short_changed(), editor, _editor);
    if (filename != "") {
        editor->filename_set_new(filename);
    }
    _tabs.active->tooltip(editor->filename_long(), editor);
    editor_set_style(editor);
    editor_update_status(editor);
    editor->view().take_focus();
    _tabs.split->do_layout();
}
void FlEdit::file_readonly_mode() {
    if (_editor != nullptr) {
        _editor->text_set_readonly(flw::menu::item_value(_menu, MENU_FILE_READONLY));
    }
}
void FlEdit::file_reload(fle::Editor* editor) {
    if (editor != nullptr) {
        auto info = std::string("Would you like to reload file ") + editor->filename_long() + " ?";
        if (flw::dlg::msg_ask("flEdit", info, "&Yes", "&No") == "&Yes") {
            fle::CursorPos pos = editor->cursor(true);
            editor->file_load(editor->filename_long());
            editor->cursor_move(pos);
            editor_set_style(editor);
            editor_update_status(editor);
        }
    }
}
bool FlEdit::file_save(fle::Editor* editor) {
    if (editor == nullptr) {
        return true;
    }
    if (editor->filename_long() == "") {
        if (_editor != editor) {
            tabs_activate(editor);
        }
        return file_save_as(editor);
    }
    auto err = editor->file_save();
    if (err != "") {
        flw::dlg::msg_alert("flEdit", err);
        if (_editor != editor) {
            tabs_activate(editor);
        }
        return false;
    }
    editor->update_autocomplete();
    editor_update_status(editor);
    return true;
}
bool FlEdit::file_save_as(fle::Editor* editor) {
    if (editor == nullptr) {
        return true;
    }
    auto filename = gnu::str::to_string(fl_file_chooser("Save File As", fle::strings::FILE_FILTER.c_str(), editor->filename_path() != "" ? editor->filename_long().c_str() : _paths.open_path.c_str()));
    auto new_file = gnu::file::File(filename, OPEN_FILE_USING_REAL_NAME);
    if (new_file.filename() == "" || new_file.filename() == editor->filename_long() || new_file.is_other() == true) {
        return false;
    }
    else if (new_file.is_dir() == true) {
        flw::dlg::msg_alert("flEdit", flw::util::format("Destination is a directory!\n%s", filename.c_str()));
        return false;
    }
    else if (tabs_editor_by_path(new_file.filename()) != nullptr) {
        flw::dlg::msg_alert("flEdit", flw::util::format("File with this name already opened!\n%s", filename.c_str()));
        return false;
    }
    auto err = editor->file_save_as(new_file.filename());
    if (err != "") {
        flw::dlg::msg_alert("flEdit", err);
        return false;
    }
    _tabs.active->tooltip(editor->filename_long(), editor);
    editor_set_style(editor);
    editor_update_status(editor);
    _recent->insert(editor->filename_long());
    return true;
}
void FlEdit::pref_load(bool all) {
    auto pref = Fl_Preferences(Fl_Preferences::USER_L, USER_NAME, "fledit");
    auto val  = 0;
    if (all == true) {
        std::string s;
        flw::theme::load_theme_from_pref(pref);
        flw::theme::load_win_from_pref(pref, "gui.", this);
        FlEdit::COMMAND_RECT = flw::theme::load_rect_from_pref(pref, "command.");
        FlEdit::PROJECT_RECT = flw::theme::load_rect_from_pref(pref, "project.");
        FlEdit::TEXT_RECT    = flw::theme::load_rect_from_pref(pref, "text.");
        pref.get("gui.path", s, "");
        gnu::file::File file(s);
        if (file.is_dir() == true) {
            _paths.open_path = file.filename();
        }
        else {
            _paths.open_path = gnu::file::work_dir().filename();
        }
        pref.get("gui.split", val, (int) flw::SplitGroup::Pos::VERTICAL);
        if (val == (int) flw::SplitGroup::Pos::HORIZONTAL) {
            _tabs.split->pos(flw::SplitGroup::Pos::HORIZONTAL);
            flw::menu::setonly_item(_menu, MENU_SETTINGS_SPLIT_HORIZONTAL);
        }
        else {
            _tabs.split->pos(flw::SplitGroup::Pos::VERTICAL);
            flw::menu::setonly_item(_menu, MENU_SETTINGS_SPLIT_VERTICAL);
        }
        pref.get("gui.output", val, (int) flw::SplitGroup::Pos::HORIZONTAL);
        if (val == (int) flw::SplitGroup::Pos::HORIZONTAL) {
            _split_edit->pos(flw::SplitGroup::Pos::HORIZONTAL);
            _split_edit->split_pos(h() - 200);
            flw::menu::setonly_item(_menu, MENU_SETTINGS_OUTPUT_HORIZONTAL);
        }
        else {
            _split_edit->pos(flw::SplitGroup::Pos::VERTICAL);
            _split_edit->split_pos(w() - 200);
            flw::menu::setonly_item(_menu, MENU_SETTINGS_OUTPUT_VERTICAL);
        }
        pref.get("gui.output.clear", val, (int) 0);
        flw::menu::set_item(_menu, MENU_SETTINGS_OUTPUT_CLEAR, val);
        pref.get("gui.output.show", val, (int) 0);
        flw::menu::set_item(_menu, MENU_SETTINGS_OUTPUT_UNKNOWN, val);
        pref.get("gui.tabspos1", val, 0);
        pref_set_tabspos1(
            val >= static_cast<int>(flw::TabsGroup::Pos::TOP) &&
            val <= static_cast<int>(flw::TabsGroup::Pos::LAST) ?
            static_cast<flw::TabsGroup::Pos>(val) :
            flw::TabsGroup::Pos::TOP
        );
        pref.get("gui.tabspos2", val, 0);
        pref_set_tabspos2(
            val >= static_cast<int>(flw::TabsGroup::Pos::TOP) &&
            val <= static_cast<int>(flw::TabsGroup::Pos::LAST) ?
            static_cast<flw::TabsGroup::Pos>(val) :
            flw::TabsGroup::Pos::TOP
        );
        pref.get("gui.tabsboxtype", val, FL_MAX_BOXTYPE);
        pref_set_tabslook(static_cast<Fl_Boxtype>(val));
        pref.get("project.db", s, "");
        if (s != "") {
            _db.open(s);
        }
        CONFIG.load_pref(pref, &_findbar->findreplace());
    }
    else {
        flw::theme::load_theme_from_pref(pref);
        CONFIG.load_pref(pref, &_findbar->findreplace());
    }
    _recent->load_pref(pref);
    _findbar->findreplace().update_lists(true, true, -1);
    val = 0;
    Command::COMMANDS.clear();
    while (true) {
        std::string name;
        std::string command;
        std::string workdir;
        std::string filter;
        std::string line;
        std::string s;
        auto output = Output::RUN;
        pref.get(gnu::str::format("cmd_name%d", val).c_str(), s, "");
        if (s == "") {
            break;
        }
        else {
            name = s;
        }
        pref.get(gnu::str::format("cmd_run%d", val).c_str(), s, "");
        command = s;
        pref.get(gnu::str::format("cmd_capture%d", val).c_str(), s, "");
        if (s == "1") {
            output = Output::CAPTURE_LIST;
        }
        else if (s == "2") {
            output = Output::CAPTURE_TERMINAL;
        }
        else if (s == "3") {
            output = Output::STREAM_TERMINAL;
        }
        else if (s == "4") {
            output = Output::CAPTURE_EDITOR;
        }
        pref.get(gnu::str::format("cmd_directory%d", val).c_str(), s, "");
        workdir = s;
        pref.get(gnu::str::format("cmd_filter%d", val).c_str(), s, "");
        filter = s;
        pref.get(gnu::str::format("cmd_line%d", val).c_str(), s, "");
        line = s;
        Command::COMMANDS.push_back(new Command(name, command, output, workdir, filter, line));
        val++;
    }
    CONFIG.send_message(fle::message::PREF_CHANGED);
}
void FlEdit::pref_save() {
    auto pref = Fl_Preferences(Fl_Preferences::USER_L, USER_NAME, "fledit");
    pref.clear();
    pref.set("gui.path", _paths.open_path);
    pref.set("gui.split", (int) _tabs.split->pos());
    pref.set("gui.output", (int) _split_edit->pos());
    pref.set("gui.output.clear", FlEdit::SettingsClearTerminal());
    pref.set("gui.output.show", FlEdit::settingsShowUnknown());
    pref.set("gui.tabspos1", (int) _tabs.pos1);
    pref.set("gui.tabspos2", (int) _tabs.pos2);
    pref.set("gui.tabsboxtype", (int) _tabs.boxtype);
    flw::theme::save_theme_to_pref(pref);
    flw::theme::save_rect_to_pref(pref, "command.", FlEdit::COMMAND_RECT);
    flw::theme::save_rect_to_pref(pref, "project.", FlEdit::PROJECT_RECT);
    flw::theme::save_rect_to_pref(pref, "text.", FlEdit::TEXT_RECT);
    flw::theme::save_win_to_pref(pref, "gui.", this);
    CONFIG.save_pref(pref, &_findbar->findreplace());
    _recent->save_pref(pref);
    if (_db.is_open() == true) {
        pref.set("project.db", _db.filename());
    }
    auto c = 0;
    for (const auto& command : Command::COMMANDS) {
        pref.set(gnu::str::format("cmd_name%d", c).c_str(), command->name);
        pref.set(gnu::str::format("cmd_run%d", c).c_str(), command->command);
        pref.set(gnu::str::format("cmd_directory%d", c).c_str(), command->workpath);
        pref.set(gnu::str::format("cmd_filter%d", c).c_str(), command->filter_regex);
        pref.set(gnu::str::format("cmd_line%d", c).c_str(), command->line_regex);
        if (command->output == Output::CAPTURE_LIST) {
            pref.set(gnu::str::format("cmd_capture%d", c).c_str(), "1");
        }
        else if (command->output == Output::CAPTURE_TERMINAL) {
            pref.set(gnu::str::format("cmd_capture%d", c).c_str(), "2");
        }
        else if (command->output == Output::STREAM_TERMINAL) {
            pref.set(gnu::str::format("cmd_capture%d", c).c_str(), "3");
        }
        else if (command->output == Output::CAPTURE_EDITOR) {
            pref.set(gnu::str::format("cmd_capture%d", c).c_str(), "4");
        }
        else if (command->output == Output::RUN) {
            pref.set(gnu::str::format("cmd_capture%d", c).c_str(), "0");
        }
        c++;
    }
}
void FlEdit::pref_set_tabslook(Fl_Boxtype boxtype) {
    _tabs.boxtype = boxtype;
    _tabs.tabs1->tab_box(boxtype, boxtype);
    _tabs.tabs2->tab_box(boxtype, boxtype);
    _output->tab_box(boxtype, boxtype);
    if (boxtype == FL_BORDER_BOX) {
        flw::menu::setonly_item(_menu, MENU_SETTINGS_TAB_BORDER);
    }
    else if (boxtype == FL_FLAT_BOX) {
        flw::menu::setonly_item(_menu, MENU_SETTINGS_TAB_FLAT);
    }
    else {
        flw::menu::setonly_item(_menu, MENU_SETTINGS_TAB_DEF);
    }
    do_layout();
}
void FlEdit::pref_set_tabspos1(flw::TabsGroup::Pos pos) {
    switch (pos) {
        case flw::TabsGroup::Pos::BOTTOM:
            _tabs.pos1 = pos;
            flw::menu::setonly_item(_menu, MENU_SETTINGS_TAB_G12);
            break;
        case flw::TabsGroup::Pos::LEFT:
            _tabs.pos1 = pos;
            flw::menu::setonly_item(_menu, MENU_SETTINGS_TAB_G13);
            break;
        case flw::TabsGroup::Pos::RIGHT:
            _tabs.pos1 = pos;
            flw::menu::setonly_item(_menu, MENU_SETTINGS_TAB_G14);
            break;
        default:
            _tabs.pos1 = flw::TabsGroup::Pos::TOP;
            flw::menu::setonly_item(_menu, MENU_SETTINGS_TAB_G11);
            break;
    }
    _tabs.tabs1->tab_pos(_tabs.pos1);
    do_layout();
}
void FlEdit::pref_set_tabspos2(flw::TabsGroup::Pos pos) {
    switch (pos) {
        case flw::TabsGroup::Pos::BOTTOM:
            _tabs.pos2 = pos;
            flw::menu::setonly_item(_menu, MENU_SETTINGS_TAB_G22);
            break;
        case flw::TabsGroup::Pos::LEFT:
            _tabs.pos2 = pos;
            flw::menu::setonly_item(_menu, MENU_SETTINGS_TAB_G23);
            break;
        case flw::TabsGroup::Pos::RIGHT:
            _tabs.pos2 = pos;
            flw::menu::setonly_item(_menu, MENU_SETTINGS_TAB_G24);
            break;
        default:
            _tabs.pos2 = flw::TabsGroup::Pos::TOP;
            flw::menu::setonly_item(_menu, MENU_SETTINGS_TAB_G21);
            break;
    }
    _tabs.tabs2->tab_pos(_tabs.pos2);
    do_layout();
}
bool FlEdit::project_close(bool save) {
    if (tabs_save_all(true) == false) {
        return false;
    }
    if (_db.is_open() == true && _project.name != "") {
        if (gnu::file::chdir(_paths.start_path) == false) {
            flw::dlg::msg_alert("flEdit", flw::util::format("Failed to restore original work directory to %s!\n%s", _paths.start_path.c_str()));
        }
        if (save == true && project_save_to_db(_project.name) == false) {
            return false;
        }
        CONFIG.find_list    = _old_find_list;
        CONFIG.replace_list = _old_replace_list;
        _findbar->findreplace().update_lists(true, true, -1);
        _recent->clear();
        _recent->items(_old_recent_list);
    }
    _project = { "", "", "" };
    CONFIG.load_custom_wordlist("");
    tabs_close_all();
    split_view(Split::HIDE_TWO);
    split_view(Split::SHOW_ONE);
    tabs_check_empty();
    _dir_browser->hide();
    _dir_browser->load_root("");
    do_layout();
    return true;
}
bool FlEdit::project_close_db() {
    if (_project.name != "" && project_close(true) == false) {
        return false;
    }
    _db.close();
    return true;
}
void FlEdit::project_defrag_db() {
    if (_db.defrag() == false) {
        flw::dlg::msg_alert("flEdit", flw::util::format("Failed to defrag database file!\n%s", _db.err_msg.c_str()));
    }
}
bool FlEdit::project_exist_in_db(const std::string& project_name) {
    if (_db.is_open() == false) {
        return false;
    }
    return _db.has_key(NS_PROJECTS, project_name);
}
void FlEdit::project_load_from_db(const std::string& project_name) {
    auto name = project_name;
    gnu::str::trim(name);
    {
        if (_db.is_open() == false) {
            flw::dlg::msg_alert("flEdit", "Database is closed!");
            return;
        }
        if (name == "") {
            auto dialog = ProjectDialog(_db);
            name = dialog.run(this);
            gnu::str::trim(name);
            if (name == "") {
                return;
            }
        }
        if (project_close(true) == false) {
            return;
        }
    }
    {
        auto wc   = flw::WaitCursor();
        auto time = gnu::Time::Milli();
        if (gnu::file::chdir(_paths.start_path) == false) {
            flw::dlg::msg_alert("flEdit", flw::util::format("Failed to restore original work directory to %s!", _paths.start_path.c_str()));
        }
        auto row = _db.get(NS_PROJECTS, name);
        if (row.c_str() == nullptr) {
            flw::dlg::msg_alert("flEdit", flw::util::format("Failed to load project!\n%s", _db.err_msg.c_str()));
            return;
        }
        auto pile = gnu::pile::Pile(row.c_str());
        if (pile.size() == 0) {
            flw::dlg::msg_alert("flEdit", "Missing data!");
            return;
        }
        _old_find_list    = CONFIG.find_list;
        _old_replace_list = CONFIG.replace_list;
        _old_recent_list  = _recent->items();
        CONFIG.find_list.clear();
        CONFIG.replace_list.clear();
        _recent->clear();
        for (auto& s : project_load_list_from_pile("find", pile)) {
            CONFIG.add_find_word(s, true);
        }
        for (auto& s : project_load_list_from_pile("replace", pile)) {
            CONFIG.add_replace_word(s, true);
        }
        for (auto& s : project_load_list_from_pile("recent", pile)) {
            _recent->append(s);
        }
        _findbar->findreplace().update_lists(true, true, -1);
        auto files = pile.get_int("gui", "files");
        for (auto f = 1; f <= files; f++) {
            auto section = gnu::pile::make_key(f);
            _tabs.active = (pile.get_string(section, "tabs") == "right") ? _tabs.tabs2 : _tabs.tabs1;
            auto filename = pile.get_string(section, "path");
            auto editor   = file_load(nullptr, filename, false, 0);
            if (editor != nullptr) {
                auto checksum = pile.get_string(section, "checksum");
                auto split    = pile.get_int(section, "split");
                auto cursor   = fle::CursorPos();
                if (split == (int) fle::FSplitView::HORIZONTAL) {
                    editor->view_set_split(fle::FSplitView::HORIZONTAL);
                }
                else if (split == (int) fle::FSplitView::VERTICAL) {
                    editor->view_set_split(fle::FSplitView::VERTICAL);
                }
                cursor.pos1  = pile.get_int(section, "cursor1");
                cursor.top1  = pile.get_int(section, "top1");
                cursor.pos2  = (editor->view2() != nullptr) ? pile.get_int(section, "cursor2") : -1;
                cursor.top2  = (editor->view2() != nullptr) ? pile.get_int(section, "top2") : -1;
                cursor.drag  = pile.get_int(section, "drag");
                cursor.start = pile.get_int(section, "start");
                cursor.end   = pile.get_int(section, "end");
                editor->view1()->take_focus();
                editor->wrap_set_mode(pile.get_int(section, "wrap") ? fle::FWrap::YES : fle::FWrap::NO);
                editor_set_style(editor, pile.get_string(section, "style", "Text"));
                if (editor->text_checksum() == checksum) {
                    editor->cursor_move(cursor);
                    editor->bookmarks() = fle::Bookmarks(editor, pile.get_string(section, "bookmarks"));
                }
                editor->cursor_save();
            }
        }
        time = gnu::Time::Milli() - time;
        auto left  = pile.get_int("gui", "left", 0);
        auto right = pile.get_int("gui", "right", 0);
        if (left == 0 && right == 1) {
            split_view(Split::SHOW_TWO);
        }
        else if (left == 1 && right == 1) {
            split_view(Split::SHOW_ONE);
            split_view(Split::SHOW_TWO);
        }
        else {
            split_view(Split::SHOW_ONE);
        }
        auto editor = tabs_editor_by_path(pile.get_string("active", "right"));
        if (editor != nullptr) {
            tabs_activate(editor);
        }
        editor = tabs_editor_by_path(pile.get_string("active", "left"));
        if (editor != nullptr) {
            tabs_activate(editor);
        }
        _project.name     = name;
        _project.path     = pile.get_string("gui", "dir");
        _project.wordfile = pile.get_string("project", "wordfile");
    #ifdef DEBUG
        printf("loaded project %s in %d mS with %d files\n", _project.name.c_str(), (int) time, (int) files);
        fflush(stdout);
    #endif
    }
    if (gnu::file::File(_project.path).is_dir() == false) {
        _project.path = "";
    }
    if (gnu::file::File(_project.wordfile).is_file() == false) {
        _project.wordfile = "";
    }
    else {
        CONFIG.load_custom_wordlist(_project.wordfile);
    }
    update_menu();
    if (_project.path != "" && gnu::file::chdir(_project.path) == false) {
        flw::dlg::msg_alert("flEdit", flw::util::format("Failed to restore project work directory to %s!", _project.path.c_str()));
    }
    tabs_check_empty();
    do_layout();
    tabs_reset_split_size();
}
std::vector<std::string> FlEdit::project_load_list_from_pile(const std::string& key, gnu::pile::Pile& pile) {
    auto count = 1;
    auto res   = std::vector<std::string>();
    while (true) {
        std::string s = pile.get_string(key, gnu::pile::make_key(count++));
        if (s == "") {
            break;
        }
        else {
            res.push_back(s);
        }
    }
    return res;
}
void FlEdit::project_load_snippet_from_db() {
    if (KLUDGE == 0) {
        KLUDGE++;
        if (_db.is_open() == false) {
            flw::dlg::msg_alert("flEdit", "Database is closed!");
            KLUDGE--;
            return;
        }
        auto dialog = TextDialog(_db);
        auto text   = dialog.run(this);
        if (text != "") {
            Fl::copy(text.c_str(), text.length(), 2);
        }
        KLUDGE--;
    }
}
void FlEdit::project_open_db() {
    auto filename = gnu::str::to_string(fl_file_chooser("Open/Create Project Database", "FlEdit Project Files (*.{fledit,db})", _paths.open_path.c_str()));
    if (filename == "") {
        return;
    }
    gnu::file::File file(filename);
    filename = file.filename();
    if (file.is_missing() == true && file.ext() == "") {
        filename += ".fledit";
    }
    _db = gnu::db2::DB(filename);
    if (_db.is_open() == false) {
        flw::dlg::msg_alert("flEdit", flw::util::format("Failed to open database file!\n%s", _db.err_msg.c_str()));
    }
}
void FlEdit::project_path() {
    auto start_path = _project.path;
    if (start_path == "") {
        if (_editor != nullptr) {
            start_path = _editor->filename_path();
        }
        else {
            start_path = _paths.start_path;
        }
    }
    auto path = fl_dir_chooser("Select Project Directory - Press Cancel To Remove Current", start_path.c_str());
    if (path == nullptr) {
        _project.path = "";
        _dir_browser->hide();
        _dir_browser->load_root("");
        do_layout();
        if (gnu::file::chdir(_paths.start_path) == false) {
            flw::dlg::msg_alert("flEdit", flw::util::format("Failed to restore previous work directory to %s!",  _paths.start_path.c_str()));
        }
    }
    else {
        _project.path = gnu::file::File(path).filename();
        if (_dir_browser->visible() != 0) {
            _dir_browser->load_root(path);
        }
        if (gnu::file::chdir(_project.path) == false) {
            flw::dlg::msg_alert("flEdit", flw::util::format("Failed to change work directory to %s!", _project.path.c_str()));
        }
    }
}
void FlEdit::project_save_as_to_db(bool rename) {
    auto name = std::string();
    if (flw::dlg::input("flEdit", "Enter name of the project.", name) == flw::label::CANCEL) {
        return;
    }
    gnu::str::trim(name);
    if (name != "") {
        project_save_to_db(name, rename == true ? _project.name : "");
    }
}
void FlEdit::project_save_list_to_pile(const std::string& key, const std::vector<std::string>& list, gnu::pile::Pile& pile) {
    auto count = 1;
    for (const auto& word : list) {
        pile.set_string(key, gnu::pile::make_key(count++), word);
    }
}
void FlEdit::project_save_snippet_to_db(SNIPPET snippet, const std::string& clip) {
    if (_db.is_open() == false) {
        flw::dlg::msg_alert("flEdit", "Database is closed!");
        return;
    }
    std::string text;
    std::string name;
    if (snippet == SNIPPET::CLIPBOARD) {
        if (clip != "") {
            text = clip;
        }
        else if (Fl::clipboard_contains(Fl::clipboard_plain_text) != 0) {
            Fl::paste(*this, 1, Fl::clipboard_plain_text);
            return;
        }
    }
    else if (snippet == SNIPPET::SELECTION && _editor != nullptr) {
        text = _editor->text_get_selection_string();
    }
    else if (snippet == SNIPPET::TEXT && _editor != nullptr) {
        text = gnu::str::grab(_editor->buffer().text());
        name = _editor->filename_short() + " " + gnu::Time::FormatUnixToISO(_editor->file_mtime());
    }
    if (text == "") {
        flw::dlg::msg_alert("flEdit", "Nothing to save!");
        return;
    }
    if (text.length() > FlEdit::MAX_SNIPPET_LENGTH) {
        flw::dlg::msg_alert("flEdit", "error: text is too large (max %u bytes) (%u)", (unsigned) FlEdit::MAX_SNIPPET_LENGTH, (unsigned) text.length());
        return;
    }
    if (name == "" && flw::dlg::input("flEdit", "Enter name of the snippet.", name) == flw::label::CANCEL) {
        return;
    }
    gnu::str::trim(name);
    if (name == "") {
        return;
    }
    if (_db.put(NS_SNIPPETS, name, text, -1) == false) {
        flw::dlg::msg_alert("flEdit", flw::util::format("Failed to save snippet!\n%s", _db.err_msg.c_str()));
    }
}
bool FlEdit::project_save_to_db(const std::string& name, const std::string& old_name) {
    if (_db.is_open() == false) {
        flw::dlg::msg_alert("flEdit", "Database is closed!");
        return false;
    }
    auto pile = gnu::pile::Pile();
    if (_tabs.tabs1->visible() != 0) {
        pile.set_int("gui", "left", 1);
    }
    if (_tabs.tabs2->visible() != 0) {
        pile.set_int("gui", "right", 1);
    }
    project_save_list_to_pile("find", CONFIG.find_list, pile);
    project_save_list_to_pile("replace", CONFIG.replace_list, pile);
    project_save_list_to_pile("recent", _recent->items(), pile);
    auto count    = 1;
    auto tabindex = 0;
    auto editor   = tabs_editor_by_index(tabindex);
    while (editor != nullptr) {
        if (editor->filename_long() != "") {
            auto cursor  = (editor->text_is_dirty() == true) ? editor->cursor_saved() : editor->cursor(true);
            auto section = gnu::pile::make_key(count);
            cursor.to_default();
            pile.set_string(section, "path", editor->filename_long());
            pile.set_string(section, "checksum", editor->text_checksum());
            pile.set_string(section, "tabs", editor->parent() == _tabs.tabs1 ? "left" : "right");
            pile.set_int(section, "split", (int) editor->view_split());
            pile.set_string(section, "style", editor->style().name());
            pile.set_int(section, "wrap", editor->wrap_mode() == fle::FWrap::YES ? 1 : 0);
            pile.set_string(section, "bookmarks", editor->bookmarks().tostring());
            pile.set_int(section, "cursor1", cursor.pos1);
            pile.set_int(section, "top1", cursor.top1);
            pile.set_int(section, "cursor2", cursor.pos2);
            pile.set_int(section, "top2", cursor.top2);
            pile.set_int(section, "drag", cursor.drag);
            pile.set_int(section, "start", cursor.start);
            pile.set_int(section, "end", cursor.end);
            count++;
            if (_tabs.tabs1->value() == editor) {
                pile.set_string("active", "left", editor->filename_long());
            }
            else if (_tabs.tabs2->value() == editor) {
                pile.set_string("active", "right", editor->filename_long());
            }
        }
        editor = tabs_editor_by_index(tabindex);
    }
    pile.set_int("gui", "files", count - 1);
    pile.set_string("gui", "dir", _project.path);
    pile.set_string("project", "wordfile", _project.wordfile);
    auto str = pile.export_data();
    if (_db.put(NS_PROJECTS, name, str, -1) == false) {
        flw::dlg::msg_alert("flEdit", flw::util::format("Failed to save project!\n%s", _db.err_msg.c_str()));
        return false;
    }
    if (old_name != "" && old_name != name) {
        _db.remove(NS_PROJECTS, old_name);
    }
    _project.name = name;
    return true;
}
void FlEdit::project_wordlist() {
    auto start_path = _project.path;
    if (start_path == "") {
        if (_editor != nullptr) {
            start_path = _editor->filename_path();
        }
        else {
            start_path = _paths.start_path;
        }
    }
    auto file = fl_file_chooser("Select Wordfile - Press Cancel To Remove Current", "", (_project.wordfile != "") ? _project.wordfile.c_str() : start_path.c_str(), 0);
    auto wc   = flw::WaitCursor();
    if (file == nullptr) {
        CONFIG.load_custom_wordlist("");
        _project.wordfile = "";
    }
    else {
        CONFIG.load_custom_wordlist(file);
        _project.wordfile = file;
    }
}
#include <algorithm>
void FlEdit::tabs_activate(fle::Editor* editor) {
    if (editor == nullptr) {
        _editor = nullptr;
    }
    else if (_tabs.tabs1->find(editor) != -1) {
        if (_tabs.active != _tabs.tabs1 || _tabs.tabs1->visible() == 0) {
            _tabs.active = _tabs.tabs1;
            split_view(Split::SHOW_ONE);
        }
        if (_editor != editor) {
            _editor = editor;
            if (_tabs.active->value() != _editor) {
                _tabs.active->value(_editor);
            }
        }
    }
    else if (_tabs.tabs2->find(editor) != -1) {
        if (_tabs.active != _tabs.tabs2 || _tabs.active->visible() == 0) {
            _tabs.active = _tabs.tabs2;
            split_view(Split::SHOW_TWO);
        }
        if (_editor != editor) {
            _editor = editor;
            if (_tabs.active->value() != _editor) {
                _tabs.active->value(_editor);
            }
        }
    }
    if (_editor != nullptr && Fl::focus() != _editor) {
        _editor->view().take_focus();
    }
    redraw();
}
void FlEdit::tabs_activate_cursor(const std::string& workpath, const std::string& filename, int row, int col) {
    auto wpath     = gnu::file::File(workpath);
    auto find_file = filename;
    if (wpath.is_dir() == false) {
        wpath = gnu::file::work_dir();
    }
    if (find_file.find("..") == 0 || find_file.find("/") != 0) {
        find_file = wpath.filename() + "/" + find_file;
    }
    auto tabindex = 0;
    auto fi       = gnu::file::File(find_file, OPEN_FILE_USING_REAL_NAME);
    auto editor   = tabs_editor_by_index(tabindex);
    auto found    = (fle::Editor*) nullptr;
    auto partly   = (fle::Editor*) nullptr;
    while (editor != nullptr) {
        auto tmp = gnu::file::File(editor->filename_long(), OPEN_FILE_USING_REAL_NAME);
        if (fi.filename() == tmp.filename()) {
            found = editor;
            break;
        }
        else if (partly == nullptr && fi.name() == tmp.name()) {
            partly = editor;
        }
        editor = tabs_editor_by_index(tabindex);
    }
    if (found != nullptr) {
        if (row > 0) {
            found->cursor_move_to_rowcol(row, col);
        }
        tabs_activate(found);
    }
    else if (partly != nullptr) {
        if (row > 0) {
            partly->cursor_move_to_rowcol(row, col);
        }
        tabs_activate(partly);
    }
    else if (_editor != nullptr) {
        _editor->view().take_focus();
    }
}
int FlEdit::tabs_changed() const {
    auto res      = 0;
    auto tabindex = 0;
    auto editor   = const_cast<FlEdit*>(this)->tabs_editor_by_index(tabindex);
    while (editor != nullptr) {
        if (editor->text_is_readonly() == false && editor->text_is_dirty() == true) {
            res++;
        }
        editor = const_cast<FlEdit*>(this)->tabs_editor_by_index(tabindex);
    }
    return res;
}
void FlEdit::tabs_check_empty() {
    auto t1 = (_tabs.tabs1->visible() != 0) ? true : false;
    auto e1 = (fle::Editor*) _tabs.tabs1->value();
    auto t2 = (_tabs.tabs2->visible() != 0) ? true : false;
    auto e2 = (fle::Editor*) _tabs.tabs2->value();
    auto t  = (_tabs.active == _tabs.tabs1) ? 1 : 2;
    if (_tabs.tabs1->children() == 0) {
        auto editor = new fle::Editor(CONFIG, _findbar);
        _tabs.tabs1->add("", editor);
        if (_tabs.active == _tabs.tabs1) {
            editor->view().take_focus();
            e1 = editor;
        }
    }
    else if (_tabs.tabs1->children() > 1) {
        auto editor = (fle::Editor*) _tabs.tabs1->child(0);
        if (editor->filename_short_changed() == "" && _tabs.tabs1->remove(editor) != nullptr) {
            delete editor;
        }
    }
    if (_tabs.tabs2->children() == 0) {
        auto editor = new fle::Editor(CONFIG, _findbar);
        _tabs.tabs2->add("", editor);
    }
    else if (_tabs.tabs2->children() > 1) {
        auto editor = (fle::Editor*) _tabs.tabs2->child(0);
        if (editor->filename_short_changed() == "" && _tabs.tabs2->remove(editor) != nullptr) {
            delete editor;
        }
    }
    if (e1 != nullptr && t == 1) {
        tabs_activate(e1);
    }
    else if (e2 != nullptr && t == 2) {
        tabs_activate(e2);
    }
    if (t1 == false && _tabs.tabs1->visible() != 0) {
        _tabs.tabs1->hide();
    }
    if (t2 == false && _tabs.tabs2->visible() != 0) {
        _tabs.tabs2->hide();
    }
}
void FlEdit::tabs_check_external_update() {
    auto tabindex = 0;
    auto editor   = tabs_editor_by_index(tabindex);
    while (editor != nullptr) {
        editor->file_check_reload();
        editor = tabs_editor_by_index(tabindex);
    }
}
void FlEdit::tabs_close_all() {
    auto wc = flw::WaitCursor();
    _editor = nullptr;
    _tabs.tabs1->clear();
    _tabs.tabs2->clear();
    tabs_activate(nullptr);
}
int FlEdit::tabs_count() const {
    auto res      = 0;
    auto tabindex = 0;
    auto editor   = const_cast<FlEdit*>(this)->tabs_editor_by_index(tabindex);
    while (editor != nullptr) {
        if (editor->filename_short_changed() != "") {
            res++;
        }
        editor = const_cast<FlEdit*>(this)->tabs_editor_by_index(tabindex);
    }
    return res;
}
void FlEdit::tabs_delete(fle::Editor* editor) {
    if (_tabs.tabs1->remove(editor)) {
        delete editor;
    }
    else if (_tabs.tabs2->remove(editor)) {
        delete editor;
    }
    if (_editor == editor) {
        _editor = nullptr;
    }
    do_layout();
}
fle::Editor* FlEdit::tabs_editor_by_index(int& index) {
    while (index >= 0 && index < _tabs.tabs1->children()) {
        auto editor = static_cast<fle::Editor*>(_tabs.tabs1->child(index++));
        if (editor->file_is_empty() == false) {
            return editor;
        }
    }
    auto index2 = index - _tabs.tabs1->children();
    while (index2 >= 0 && index2 < _tabs.tabs2->children()) {
        auto editor = static_cast<fle::Editor*>(_tabs.tabs2->child(index2));
        index++;
        index2++;
        if (editor->file_is_empty() == false) {
            return editor;
        }
    }
    return nullptr;
}
fle::Editor* FlEdit::tabs_editor_by_path(const std::string& path) {
    if (path == "") {
        return nullptr;
    }
    auto tabindex = 0;
    auto editor   = tabs_editor_by_index(tabindex);
    while (editor != nullptr) {
        if (path == editor->filename_long()) {
            return editor;
        }
        editor = tabs_editor_by_index(tabindex);
    }
    return nullptr;
}
void FlEdit::tabs_find_lines() {
    if (Command::THREAD != nullptr) {
        flw::dlg::msg_alert("flEdit", "Can't search for text while running an command!");
        return;
    }
    tabs_check_external_update();
    auto find = std::string();
    {
        auto list   = CONFIG.find_list;
        auto dialog = fle::FindDialog("Find Lines In All Files", list);
        find        = dialog.run();
        if (find == "") {
            return;
        }
    }
    {
        auto tabindex = 0;
        auto editor   = tabs_editor_by_index(tabindex);
        auto lines    = std::vector<std::string>();
        auto files    = (size_t) 0;
        while (editor != nullptr) {
            if (editor->find_lines(find, fle::FindDialog::REGEX, fle::FindDialog::TRIM, lines) > 0) {
                files++;
            }
            editor = tabs_editor_by_index(tabindex);
        }
        if (lines.size() > 0) {
            _findbar->findreplace().add_find_word(find);
            _findbar->statusbar().label_message(gnu::str::format("found %u lines in %u files", (unsigned) lines.size(), (unsigned) files));
        }
        else {
            _findbar->statusbar().label_message(gnu::str::format("unable to find <%s>", find.c_str()));
        }
        _output->set_list_data(lines, "(?<file>.+):\\s+(?<line>\\d+)\\s+-\\s+(?<col>\\d+).*", 0);
        _output->show();
        _output->show_main_editor();
        do_layout();
    }
}
void FlEdit::tabs_list() {
    if (_editor == nullptr) {
        return;
    }
    auto list     = std::set<std::string>();
    auto tabindex = 0;
    auto tmp      = tabs_editor_by_index(tabindex);
    while (tmp != nullptr) {
        list.insert(tmp->filename_short());
        tmp = tabs_editor_by_index(tabindex);
    }
    _editor->take_focus();
    _editor->custom_show(list, "files", "");
}
void FlEdit::tabs_move(fle::Editor* editor) {
    if (editor == nullptr || editor->file_is_empty() == true) {
        return;
    }
    auto tabs = static_cast<flw::TabsGroup*>(editor->parent());
    if (tabs == nullptr) {
        return;
    }
    auto tip = tabs->tooltip(editor);
    if (tabs->remove(editor) == nullptr) {
        return;
    }
    if (tabs == _tabs.tabs1) {
        _tabs.tabs2->add(editor->filename_short_changed(), editor, _tabs.tabs2->value(), tip);
    }
    else if (tabs == _tabs.tabs2) {
        _tabs.tabs1->add(editor->filename_short_changed(), editor, _tabs.tabs1->value(), tip);
    }
    tabs_check_empty();
    editor_update_status(editor);
    tabs_activate(editor);
}
void FlEdit::tabs_move_all(bool to_left) {
    auto wc     = flw::WaitCursor();
    auto from   = (to_left == true) ? _tabs.tabs2 : _tabs.tabs1;
    auto to     = (to_left == true) ? _tabs.tabs1 : _tabs.tabs2;
    auto editor = (fle::Editor*) nullptr;
    auto old    = (fle::Editor*) _editor;
    while (from->children() > 0) {
        editor = static_cast<fle::Editor*>(from->child(0));
        auto tip = from->tooltip(editor);
        from->remove(editor);
        to->add(editor->filename_short_changed(), editor, to->value(), tip);
    }
    if (old != nullptr) {
        editor = old;
    }
    tabs_check_empty();
    editor_update_status(editor);
    tabs_activate(editor);
    from->do_layout();
    to->do_layout();
}
void FlEdit::tabs_pgo() {
    auto tabindex = 0;
    auto tmp      = tabs_editor_by_index(tabindex);
    while (tmp != nullptr) {
        tmp->find_replace_all(" ", "XX", fle::FNlTab::NO, fle::FSelection::NO, fle::FCaseCompare::YES, fle::FWordCompare::NO, fle::FRegex::NO, fle::FSaveWord::NO, fle::FHideFind::YES);
        tmp->find_replace_all("^X", "y", fle::FNlTab::NO, fle::FSelection::NO, fle::FCaseCompare::YES, fle::FWordCompare::NO, fle::FRegex::YES, fle::FSaveWord::NO, fle::FHideFind::YES);
        tmp->cursor_move_to_pos(tmp->text_length() / 2, true);
        tmp->text_select_line();
        for (int f = 0; f < 100; f++) {
            tmp->text_move_lines(fle::FMoveV::DOWN);
        }
        tmp = tabs_editor_by_index(tabindex);
    }
}
void FlEdit::tabs_pgo_undo() {
    auto tabindex = 0;
    auto tmp      = tabs_editor_by_index(tabindex);
    while (tmp != nullptr) {
        tmp->undo(fle::FUndoRange::ALL);
        tmp = tabs_editor_by_index(tabindex);
    }
}
void FlEdit::tabs_replace_all() {
    tabs_check_external_update();
    auto find    = std::string();
    auto replace = std::string();
    auto dialog  = fle::ReplaceDialog("Replace Text In All Files", find, replace, CONFIG.find_list, CONFIG.replace_list);
    if (dialog.run() == false) {
        return;
    }
    auto time     = gnu::Time::Milli();
    auto tabindex = 0;
    auto editor   = tabs_editor_by_index(tabindex);
    auto files    = 0;
    auto replaces = 0;
    auto org      = _editor;
    auto wc       = flw::WaitCursor();
    while (editor != nullptr) {
        auto count = editor->find_replace_all(find, replace,
            fle::ReplaceDialog::NLTAB,
            fle::ReplaceDialog::SELECTION,
            fle::ReplaceDialog::CASECOMPARE,
            fle::ReplaceDialog::WORDCOMPARE,
            fle::ReplaceDialog::REGEX,
            fle::FSaveWord::YES,
            fle::FHideFind::NO);
        editor    = tabs_editor_by_index(tabindex);
        replaces += count;
        if (count > 0) {
            files++;
        }
    }
    if (org != nullptr) {
        org->view().take_focus();
    }
    if (replaces == 0) {
        _findbar->statusbar().label_message(gnu::str::format("unable to find <%s> in any file!", find.c_str()));
    }
    else {
        time = gnu::Time::Milli() - time;
        _findbar->statusbar().label_message(gnu::str::format("replaced %d strings in %d files in %d mS", replaces, files, time));
    }
}
void FlEdit::tabs_reset_split_size() {
    auto tabindex = 0;
    auto editor   = tabs_editor_by_index(tabindex);
    while (editor != nullptr) {
        editor->view_reset_split_size();
        editor->do_layout();
        editor = tabs_editor_by_index(tabindex);
    }
}
void FlEdit::tabs_restore_visibility() {
    if (_tabs.tabs1_vis == true) {
        _tabs.tabs1->take_focus();
        _tabs.tabs1->show();
    }
    else {
        _tabs.tabs1->hide();
    }
    if (_tabs.tabs2_vis == true) {
        _tabs.tabs2->take_focus();
        _tabs.tabs2->show();
    }
    else {
        _tabs.tabs2->hide();
    }
}
bool FlEdit::tabs_save_all(bool ask) {
    auto unsaved_files = tabs_changed();
    if (unsaved_files == 0) {
        return true;
    }
    else if (ask == true) {
        auto answer = flw::dlg::msg_ask(
            "flEdit",
            flw::util::format("You have %d unsaved file%s!\nWould you like to save them?", unsaved_files, unsaved_files == 1 ? "" : "s"),
            "&Save",
            "!&Cancel",
            "Discard"
        );
        if (answer == "&Cancel") {
            return false;
        }
        else if (answer == "Discard") {
            return true;
        }
    }
    auto tabindex = 0;
    auto editor   = tabs_editor_by_index(tabindex);
    while (editor != nullptr) {
        if (editor->text_is_readonly() == false && editor->text_is_dirty() == true && file_save(editor) == false) {
            return false;
        }
        else {
            editor = tabs_editor_by_index(tabindex);
        }
    }
    return true;
}
void FlEdit::tabs_save_visibility() {
    _tabs.tabs1_vis = _tabs.tabs1->visible();
    _tabs.tabs2_vis = _tabs.tabs2->visible();
}
void FlEdit::tabs_sort(bool left, bool ascending) {
    if (left == true) {
        _tabs.tabs1->sort(ascending);
    }
    else {
        _tabs.tabs2->sort(ascending);
    }
}
void FlEdit::tabs_trailing_all() {
    tabs_check_external_update();
    auto tabindex = 0;
    auto editor   = tabs_editor_by_index(tabindex);
    auto files    = 0;
    auto lines    = 0;
    auto org      = _editor;
    while (editor != nullptr) {
        auto count = editor->text_remove_trailing();
        editor = tabs_editor_by_index(tabindex);
        lines += count;
        if (count > 0) {
            files++;
        }
    }
    if (org != nullptr) {
        org->view().take_focus();
    }
    if (lines == 0) {
        _findbar->statusbar().label_message("unable to remove any whitespace!");
    }
    else {
        _findbar->statusbar().label_message(gnu::str::format("removed whitespace from %d lines in %d files", lines, files));
    }
}
#include <FL/platform.H>
int main(int argc, const char** argv) {
    Fl::keyboard_screen_scaling(0);
    flw::theme::load("oxy");
    if (Fl::lock() != 0) {
        flw::dlg::msg_error("flEdit", "Missing thread support!\nI have to quit.");
        exit(1);
    }
    fl_open_display();
    try {
        auto arg    = 1;
        auto fledit = FlEdit(800, 600);
        fledit.executable = argv[0];
        fle::APPLICATION = "flEdit";
        flw::util::sleep(18);
        Fl::check();
        if (argc > arg && fledit.project_exist_in_db(argv[arg]) == true) {
            fledit.tabs_close_all();
            fledit.project_load_from_db(argv[arg]);
            arg++;
        }
        if (argc > arg) {
            auto files = std::vector<std::string>();
            auto lines = std::vector<int>();
            auto rx    = gnu::pcre8::PCRE("(.*):(\\d+)$");
            for (int f = arg; f < argc; f++) {
                auto filename = std::string(argv[f]);
                auto fileline = 0;
                auto m        = rx.exec(filename);
                if (m.size() == 3) {
                    filename = m[1].word();
                    fileline = gnu::str::to_int(m[1].word(), 0);
                }
                auto file = gnu::file::File(filename);
                if (file.is_file() || file.is_missing()) {
                    files.push_back(file.filename());
                    lines.push_back(fileline);
                }
            }
            if (files.size() > 0) {
                fledit.file_load_list(nullptr, files, lines);
            }
        }
        Fl::run();
    }
    catch (const std::string& e) {
        flw::dlg::msg_error("flEdit", flw::util::format("Sorry I have to terminate!\n%s", e.c_str()));
    }
    catch (const char* e) {
        flw::dlg::msg_error("flEdit", flw::util::format("Sorry I have to terminate!\n%s", e));
    }
    catch (const std::exception& e) {
        flw::dlg::msg_error("flEdit", flw::util::format("Sorry I have to terminate!\n%s", e.what()));
    }
    catch (...) {
        flw::dlg::msg_error("flEdit", "Sorry I have to terminate!");
    }
    return 0;
}
